{"meta":{"title":"荣先森","subtitle":null,"description":null,"author":"Rong","url":"http://SlectRxz.github.io"},"pages":[],"posts":[{"title":"SpringMVC学习日志（3）","slug":"java/SpringMVC(3)","date":"2019-04-28T16:00:00.000Z","updated":"2019-04-29T14:08:26.758Z","comments":true,"path":"2019/04/29/java/SpringMVC(3)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/29/java/SpringMVC(3)/","excerpt":"SpringMVC的参数绑定（get/post请求方式），@RequestMapping,Controller返回值。","text":"SpringMVC的参数绑定（get/post请求方式），@RequestMapping,Controller返回值。 引入：在实际开发中，控制层需要接收从浏览器提交的数据，通过该数据调用服务层去处理。那么，其是如何实现的呢？ 1.SrpingMvc的参数绑定 理解：当浏览器选择提交（GET/POST等）方式，究竟提交的是哪些东西？ 1）GET方式提交 12345678GET /day09/testMethod.html?name=eric&amp;password=123456 HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost:8080/day09/testMethod.htmlConnection: keep-alive a）地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。 b）GET提交参数数据有限制，不超过1KB。 c）GET方式不适合提交敏感密码。 d）注意： 浏览器直接访问的请求，默认提交方式是GET方式 2）POST方式提交12345678POST /day09/testMethod.html HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost:8080/day09/testMethod.htmlConnection: keep-alive name=eric&amp;password=123456 a）参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。 b）POST提交的参数数据没有限制。 c）POST方式提交敏感数据。 1.1基本参数类型(int,double,Integer,String…)1.可以使用request获取参数 View对象可以使用String返回值代替 【ModelMap：使用效果与Model相同，是Model接口的实现类，如果使用的是Model，springmvc会将其实例化】 【不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据】 123456789 @RequestMapping(&quot;itemEdit&quot;) public String queryItemById(HttpServletRequest request,Model model)&#123; Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;)); Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 但是我们一直使用request获取麻烦了，当请求参数名称与处理器形参参数名称一致时，将会请求参数进行绑定 (参数绑定)接收简单的参数传递（每次都从Request获取比较麻烦） 其他基本类型 String Integer Double Float。。 说明：对于布尔类型的参数，请求的参数值为true或false。或者1/0 请求url：1* 处理器方法：```public String editItem(Model model,Integer id,Boolean status) 【注：必须要求处理器形参与表单中的提交name字段名称相同】后面介绍不同如何处理 12345678@RequestMapping(&quot;itemEdit&quot;) public String queryItemById(int id,Model model)&#123; Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 那么问题来了，当我们处理器形参参数与请求参数不一致时咋办呢？ @RequestParam value:参数名字，需要与表单提交的名字相同 1&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id123=$&#123;item.id&#125;&quot;&gt; required:默认true，Request请求中一定要有相应的参数，找不到将报错400 defaultValue:默认值，如果找不到给其一个默认值 12345678@RequestMapping(&quot;itemEdit&quot;)public String queryItemById(@RequestParam(value=&quot;id123&quot;,required=true,defaultValue=&quot;1&quot;)int ids,Model model)&#123; Item item = itemService.queryItemById(ids); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;; &#125; 1.2 POJO类型(对象类型) 如果我们一次性提交的参数很多，我们可以使用一个对象来接收 要求：pojo对象的属性名与表单中的input的name一致 需求：将页面修改后的商品保存在数据库中 请求url：/updateItem.action 响应内容：给一个更新成功的提示 12345678910@RequestMapping(&quot;/updateItem.action&quot;)public String queryItemById(Model model,Item item)&#123; itemService.update(item); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //返回一个成功的信息 model.addAttribute(&quot;msg&quot;, &quot;商品信息更新成功&quot;); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 1.3封装的POJO(自定义实体类)封装类： 1234567public class QueryVo &#123; private Item item; private String message; private List&lt;Item&gt; items; . . .get/set方法... 通过成员.属性来访问 需要更改表单的传递形式 12345678910@RequestMapping(&quot;/queryItem&quot;) public String queryItem(Model model,QueryVo item)&#123; //直接输出返回的封装对象的值 System.out.println(item.getItem().getName()); System.out.println(item.getItem().getPrice()); System.out.println(item.getMessage()); List&lt;Item&gt; list = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, list); return &quot;itemList&quot;;&#125; 对应的表单： 123456789&lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot;pattern=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 1.4数组 情景：列表中每个商品前有一个checkbook，选中多个商品后点击删除按钮，把商品id传递给Controller，得到一个ids[] 可以直接接收或使用pojo属性接收，前者相当于是用一个数组接收了多个ids(JSP里的name属性)，后者是直接对应pojo的属性 12345678910111213141516@RequestMapping(&quot;/queryItem&quot;) public String queryItem(Model model,int[]ids,QueryVo vo)&#123; if(vo.getItem()!=null)&#123; System.out.println(vo); &#125; //问题：checkbox如果不选，则返回空指针异常，不知道咋整 //直接输出返回的封装对象的值 if(ids.length&gt;0 &amp;&amp; ids!=null)&#123; for (Integer integer : ids) &#123; System.out.println(integer); &#125; &#125; List&lt;Item&gt; list = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, list); return &quot;itemList&quot;;&#125; 1.5List、Map类型 场景需求：在类表中实现批量修改提交后的商品数据 定义pojo 12345public class QueryVo &#123; private Item item; private String message; private List&lt;Item&gt; items; ... 修改jspname属性必须是list属性名+下表+元素属性注：此处日期类型无妨自动绑定，需要自定义参数绑定日期类型12345678910&lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;$&#123;item.id &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].name&quot;value=&quot;$&#123;item.name &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].price&quot; value=&quot;$&#123;item.price &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].createtime&quot;value=&apos;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&apos; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].detail&quot; value=&quot;$&#123;item.detail &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 返回的是一个List的集合，在jsp显示中，需要先将单个对象取出，故需要加下标访问。12345678910111213@RequestMapping(value=&quot;/queryItem&quot;,method=&#123;RequestMethod.POST&#125;) public String queryItem(Model model,QueryVo vo)&#123; List&lt;Item&gt; items = vo.getItems(); //注意：如果进行更新操作，那么需要更改jsp，把id传给vo中的item，不然没有主键无法更新 for (Item item : items) &#123; itemService.update(item); System.out.println(item); &#125; List&lt;Item&gt; itemList = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, itemList); //这个return是跳转到/WEB-INF/下面的jsp页面，而不是跳转到控制器的URL因是个很 return &quot;itemList&quot;; &#125; 2.@RequestMapping 作用：通过@RequestMapping注解可以定义不同的处理器映射规则 URL路径映射value的值是数组，将多个url映射到同一个方法上 1@RequestMapping(value=&#123;&quot;/itemList&quot;,&quot;/itemList2&quot;&#125;) 添加在类上 作用：指定通用请求前缀，可对url进行分类管理 此时访问地址为：http://localhost:8080/item/itemList.action12345@RequestMapping(&quot;/item&quot;)public class ItemController &#123; //绑定请求地址 @RequestMapping(value=&#123;&quot;/itemList&quot;,&quot;/itemList2&quot;&#125;) public ModelAndView queryItemList()&#123; 限定请求方法1@RequestMapping(value=&quot;/queryItem&quot;,method=&#123;RequestMethod.POST&#125;) 3.Controller的返回值3.1返回ModelAndView123456789@RequestMapping(&quot;/itemList&quot;) public ModelAndView queryItemList()&#123; List&lt;Item&gt; list = itemService.queryItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemList&quot;,list); //设置逻辑视图，告诉要返回到哪一个jsp modelAndView.setViewName(&quot;itemList&quot;); return modelAndView; &#125; 3.2返回void request 不经过视图解析器的，返回路径必须是全路径 12345@RequestMapping(&quot;/itemReturn1&quot;) public void MyReturn1(HttpServletRequest request,HttpServletResponse response) throws Exception&#123; //通过request请求转发,不会改变URL的地址栏 request.getRequestDispatcher(&quot;/WEB-INF/jsp/itemList.jsp&quot;).forward(request, response);&#125; response 通过response请求重定向 【注：】response.sendRedirect(“”); 参数是URL，即浏览器中的地址 response是响应，而Model返回，经过视图解析器，springmvc已经帮我们解码了,区别：一个是直接找到jsp，另外一个是找到一个控制类/ 1234@RequestMapping(&quot;/itemReturn1&quot;) public void MyReturn1(HttpServletRequest request,HttpServletResponse response) throws Exception&#123; response.sendRedirect(&quot;/itemList.action&quot;); &#125; 3.3返回String 返回视图名字（逻辑视图名） 返回的通过视图解析器解析为物理视图地址/WEB-INF/jsp/itemList.jspreturn “itemList”- Model传递数据（向jsp） View对象可以使用String返回值代替 ModelMap：使用效果与Model相同，是Model接口的实现类，如果使用的是Model，springmvc会将其实例化 不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据】 123456789@RequestMapping(&quot;itemEdit&quot;) public String queryItemById(HttpServletRequest request,Model model)&#123; Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;)); Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; redirect与forward 实现从一个控制器跳转到另外一个控制器 123456789101112@RequestMapping(&quot;/itemReturn2&quot;) public String MyReturn2()&#123; //相当于走的视图解析器，直接访问jsp页面 //return &quot;itemList&quot;; //相当于走的视图解析器，直接访问jsp页面 //return &quot;forward:/WEB-INF/jsp/itemList.jsp&quot;; /** * 这种形式是直接跳转到另外控制器Controller */ return &quot;forward:/itemList2.action&quot;;//请求地址不会变 //return &quot;redirect:/itemList2.action&quot;; &#125; 4.异常处理器5.拦截器6.图片上传","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"SpringMVC学习日志（2）","slug":"java/SpringMVC(2)","date":"2019-04-19T16:00:00.000Z","updated":"2019-04-19T09:07:56.474Z","comments":true,"path":"2019/04/20/java/SpringMVC(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/20/java/SpringMVC(2)/","excerpt":"SpringMVC整合Mybatis框架。","text":"SpringMVC整合Mybatis框架。 SpringMVC整合Mybatis思路：Dao层 SqlConfig.xml applicationContext-dao.xml 数据库连接池 SqlSessionFactroy对象 配置mapper包扫描 Service层 applicationContext-service.xml包扫描其，扫描@Service的注解 applicationContext-trans.xml配置事务 Controller层 springmvc.xml 包扫描器，扫描@Controller注解 配置注解驱动 配置视图解析器 配置全局异常处理器 配置多媒体处理器 配置拦截器 Web.xml 配置Spring容量监听器（找到spring文件） 配置前端控制器（springmvc） 配置文件1.SqlConfig.xml 空客文件（都在applicationContext中可以完成配置），但是必须要有。1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; 2.applicationContext-dao.xml 1.数据库连接池的配置；2.SqlSessionFactroy配置3.mapper包扫描123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.pojo&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置包扫描mapper --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;ctgu.mapper&quot; /&gt; &lt;!-- optional unless there are multiple session factories defined --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 3.applicationContext-service.xml 配置Service注解扫描123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置service扫描 --&gt; &lt;context:component-scan base-package=&quot;ctgu.service&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 4.applicationContext-trans.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;query*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.itcast.ssm.service.*.*(..))&quot; /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 5.springmvc.xml 1.包扫描器，扫描@Controller注解2.配置注解驱动3.配置视图解析器1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 配置@Controller处理器，包扫描器 --&gt; &lt;context:component-scan base-package=&quot;ctgu.controller&quot; /&gt; &lt;!-- =================配置处理器映射器=========================== --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; &lt;!-- =================配置处理器适配器============================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; &lt;!-- =================配置注解驱动，可以一次性代替上述过程============ --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- =================配置视图解析器================================ --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 配置视图响应后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!-- 比如逻辑视图名为itemList，最终返回的jsp地址为/WEB-INF/jsp/itemList.jsp --&gt; &lt;/bean&gt;&lt;/beans&gt; 6.Web.xml 1.spring容量监听器2.解决乱码3.前端控制器12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;springmvc-web&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 自动装配ApplicationContext.xml的配置信息。 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring提供的过滤器 解决乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置编码参是UTF8 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; controller类 注意：Autowired是把ItemService注入（参考mybatis学习（2）中是必须要从spring获取接口，而在spring已经扫描了mapper包）12345678910111213141516171819package ctgu.controller;import ctgu.pojo.*;import ctgu.service.ItemService;//标识这是一个控制类@Controllerpublic class ItemController &#123; @Autowired private ItemService itemService; //绑定请求地址 @RequestMapping(&quot;/itemList&quot;) public ModelAndView queryItemList()&#123; List&lt;Item&gt; list = itemService.queryItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemList&quot;,list); //设置逻辑视图，告诉要返回到哪一个jsp modelAndView.setViewName(&quot;itemList&quot;); return modelAndView; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"SpringMVC学习日志（1）","slug":"java/SpringMVC(1)","date":"2019-04-18T16:00:00.000Z","updated":"2019-04-29T12:23:47.396Z","comments":true,"path":"2019/04/19/java/SpringMVC(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/19/java/SpringMVC(1)/","excerpt":"SpringMVC的入门程序的搭建，框架默认加载的三大组件","text":"SpringMVC的入门程序的搭建，框架默认加载的三大组件 SpringMVC与structs2的区别 springmvc入门程序的搭建 导入jar包 编写Controller类 控制类用于接收jsp页面（浏览器）传递过来的数据并加以处理，用于处理各个视图之间的跳转 123456789101112131415 @Controllerpublic class HelloController &#123; @RequestMapping(&quot;hello&quot;)//请求地址 public ModelAndView hello()&#123; System.out.println(&quot;hello springmvc....&quot;); //创建ModelAndView对象 响应用户的视图 ModelAndView mav = new ModelAndView(); //设置模型数据 mav.addObject(&quot;msg&quot;, &quot;hello springmvc...&quot;); //设置视图名字 jsp的目录 mav.setViewName(&quot;/WEB-INF/jsp/hello.jsp&quot;); return mav; &#125;&#125; 创建jsp页面 123456789101112 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;我的输出：&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 配置springmvc核心配置文件 需要配置：1.配置@Controller包扫描器，用于扫描@Controller注解2.配置视图解析器，用于访问时设置默认的前缀和后缀3.配置处理器映射器HandlerMapping，用于处理用户的URL请求，返回一个处理器执行链，表示将由哪一个处理器处理。4.配置处理器适配器HandleAdapter(还不太清楚)5.配置注解驱动，可替代3、4两步，并支持json响应 123456789101112131415161718192021222324252627 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 配置@Controller处理器，包扫描器 --&gt; &lt;context:component-scan base-package=&quot;ctgu.controller&quot; /&gt; &lt;!-- =================配置处理器映射器=========================== --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; &lt;!-- =================配置处理器适配器============================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; &lt;!-- =================配置注解驱动，可以一次性代替上述过程============ --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- =================配置视图解析器================================ --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 配置视图响应后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!-- 比如逻辑视图名为itemList，最终返回的jsp地址为/WEB-INF/jsp/itemList.jsp --&gt; &lt;/bean&gt;&lt;/beans&gt; 在web.xml配置前端控制器 1.配置加载Springmvc的核心文件 123456789101112131415 &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc核心配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 配置拦截路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; springmvc代码执行流程（重要！！！） 客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户 Springmvc的三大组件 处理器映射器1&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 处理器适配器1&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; 【注】:注解驱动可以代替映射器和适配器的单独设置，同时也支持json的响应（推荐使用下面这种配置）1&lt;mvc:annotation-driven /&gt; 视图解析器 配置视图解析器后我们不需要返回视图的完整路径 1234567&lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应的前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 配置视图响应的后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis整合Spring","slug":"java/Mybatis与Spring整合","date":"2019-04-14T16:00:00.000Z","updated":"2019-04-12T09:38:11.351Z","comments":true,"path":"2019/04/15/java/Mybatis与Spring整合/","link":"","permalink":"http://SlectRxz.github.io/2019/04/15/java/Mybatis与Spring整合/","excerpt":"MyBatis与Spring框架的整合。","text":"MyBatis与Spring框架的整合。 mybatis与spring如何整合？ 整合思路：1.SqlsessionFactory对象应该放到Spring容器中作为单利存在；2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。 整合步骤： 1.创建一个java工程。 2.导入jar包。 3.mybatis的配置文件sqlmapConfig.xml mapper包扫描可以直接交给Spring管理此处是应用于传统dao开发123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.编写Spring的配置文件 主要以下配置：1.数据库连接池的配置；2.sqlSessionFactory的配置(其中配置数据库源，SqlMapConfig路径，别名配置)；3.动态包扫描 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 连接池的最大数据库连接数 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.mybatis.pojo&quot; /&gt; &lt;/bean&gt; &lt;!-- ============传统dao开发 接口-类继承模式===================== --&gt; &lt;bean id=&quot;UserDao&quot; class=&quot;ctgu.mybatis.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ============动态dao开发 接口-配置文件模式==================== --&gt; &lt;!-- =============单个接口配置 =============================================================== 相当于mybatis中sqlMapConfig中的.class扫描（dao动态代理 接口+关系映射文件） &lt;mapper class=&quot;Mapper.mapper&quot;/&gt;============================================================ --&gt; &lt;!-- &lt;bean id=&quot;baseMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot; abstract=&quot;true&quot; lazy-init=&quot;true&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;bean parent=&quot;baseMapper&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;ctgu.mybatis.Mapper.mapper&quot; /&gt; &lt;/bean&gt; --&gt; &lt;!-- =============包扫描=============好像只能用一种，两个同时配置将会报错==================================================== 相当于mybatis中sqlMapConfig中的&lt;package name=&quot;Mapper&quot;/&gt; basePackage：配置映射包扫描，多个包时用&quot;,&quot;或者&quot;;&quot;分隔(Value配置) --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;ctgu.mybatis.Mappe;ctgu.ssm.mapper&quot; /&gt; &lt;!-- optional unless there are multiple session factories defined --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1数据库连接及连接池 db.properties配置1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root 4.2 sqlsessionFactory对象，配置到spring容器中 在applicationContext.xml中配置123456789&lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.mybatis.pojo&quot; /&gt; &lt;/bean&gt; 测试：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package ctgu.ssm.Test;import static org.junit.Assert.fail;import java.util.Date;import java.util.List;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import ctgu.ssm.mapper.UserMapper;import ctgu.ssm.pojo.User;import ctgu.ssm.pojo.UserExample;import ctgu.ssm.pojo.UserExample.Criteria;/** * 这个是逆向工程的生成测试类 * testSelectByExample是用来拼装查询条件 的 * * @author rong * */public class UserMapperTest &#123; private ApplicationContext applicationContext; @Before public void init()&#123; this.applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); &#125; @Test public void testDeleteByPrimaryKey() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); mapper.deleteByPrimaryKey(40); &#125; @Test public void testInsertSelective() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); User user = new User(); user.setUsername(&quot;大虎32&quot;); user.setAddress(&quot;宜昌&quot;); user.setSex(&quot;1&quot;);// mapper.insert(user) 与insertSelective的区别在于，insertSelective会判断其是否为空，只会将非空数据插入 mapper.insertSelective(user); &#125; @Test public void testSelectByExample() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); /* * 用来拼装查询条件 的 */ UserExample example = new UserExample(); //需求：查询姓大的男性 Criteria criteria = example.createCriteria(); criteria.andUsernameLike(&quot;%大%&quot;);//注意：此时必须手动添加%% criteria.andSexEqualTo(&quot;1&quot;); List&lt;User&gt; users = mapper.selectByExample(example); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testSelectByPrimaryKey() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); ctgu.ssm.pojo.User user = mapper.selectByPrimaryKey(31); System.out.println(user); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis逆向工程","slug":"java/MyBatis逆向工程","date":"2019-04-11T16:00:00.000Z","updated":"2019-04-12T09:38:02.849Z","comments":true,"path":"2019/04/12/java/MyBatis逆向工程/","link":"","permalink":"http://SlectRxz.github.io/2019/04/12/java/MyBatis逆向工程/","excerpt":"MyBatis逆向工程的实现。","text":"MyBatis逆向工程的实现。 逆向工程是干嘛的？我的理解是：逆向工程是根据数据库的表帮助我们直接生成pojo以及mapper中的接口以及关系映射文件。 那么我们应该如何修改配置文件？在generatorConfig.xml中配置mapper生成的详细信息，注意改下几点：1.添加要生成的数据库表2、po文件所在包路径3、mapper文件所在包路径 generatorConfig.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/springmvc&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;ctgu.pojo&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;ctgu.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;ctgu.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;items&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis学习（2）","slug":"java/Mybatis学习(2)","date":"2019-04-09T16:00:00.000Z","updated":"2019-04-12T09:37:31.759Z","comments":true,"path":"2019/04/10/java/Mybatis学习(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/10/java/Mybatis学习(2)/","excerpt":"MyBatis输入输出映射、动态sql、关联查询的使用。","text":"MyBatis输入输出映射、动态sql、关联查询的使用。 由mybatis学习（1）中我们了解到如何搭建mybatis工程，传统dao开发以及动态dao开发，本节主要讨论关系映射配置文件的具体配置。 1.输入映射与输出映射1.1输入映射1.1.1简单参数传递 包括String，Integer，Double，Float… 12345678&lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！ 如果你要传入的是基本类型【注：此时传入类型指的是parameterType】，括号里面一定要写value！！！ 【注：&apos;&apos;不能省，否则报错】--&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE&apos;%$&#123;value&#125;%&apos;;&lt;/select&gt; 1.1.2传递pojo对象1234&lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125;&lt;/update&gt; 1.1.3传递封装pojo对象12345678&lt;!-- 输入参数为pojo的包装对象，即有一个成员是pojo类 --&gt; &lt;select id=&quot;getByQueryUser&quot; parameterType=&quot;QueryUser&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;user.username&#125;%&apos;;&lt;/select&gt; 1.2输出映射1.2.1输出简单类型 查询用户总记录数，演示返回简单类型 123&lt;select id=&quot;getUserCount&quot; resultType=&quot;int&quot;&gt; SELECT COUNT(1) FROM USER&lt;/select&gt; 1.2.2输出pojo对象 根据id查询用户信息 1234&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.User&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125;&lt;/select&gt; 1.2.3输出pojo列表 根据名字的姓进行查询，返回一个12 &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #{name111} --&gt; &lt;!-- 注意： ${}是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%${value}%&apos;; &lt;/select&gt; 12345## 2.动态sql### 2.1 if&gt;多查询条件拼装引出if标签&gt;if标签的使用： 注意：```&lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;中间不是&amp;&amp; 1234567891011&lt;select id=&quot;getUserByNameSex&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like&apos;%$&#123;username&#125;%&apos; &lt;/if&gt; &lt;if test=&quot;sex!=null and sex!=&apos;&apos;&quot;&gt; and sex=#&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 2.1 where where标签的使用： 作用：添加where关键字，去掉多余的and 12345678910111213&lt;select id=&quot;getUserByNameSex&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like&apos;%$&#123;username&#125;%&apos; &lt;!-- 此处的可能多余的and会由where标签去掉 --&gt; &lt;/if&gt; &lt;if test=&quot;sex!=null and sex!=&apos;&apos;&quot;&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 2.1 foreach foreach标签的使用： collection：要遍历的集合，来源入参，下面的例子的list—是QueryUser.list items:设置循环变量 open:循环开始前输出的sql内容，其实不写直接放在foreach外面也是可行的 separator:分隔符 close:循环结束拼接的sql需求：查询用户id在某一个范围内的用户信息数据使用：由于mybatis不支持直接传递集合，所以需要在pojo中创建一个集合的属性，我们需要做的就是把(1,10,25,30,34)装入集合里面，再想办法把sql语句拼装出来 123456789&lt;select id=&quot;getUserByIds&quot; parameterType=&quot;QueryUser&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;user_list&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;!-- id IN (1,3,7,8,9) --&gt; &lt;foreach collection=&quot;list&quot; item=&quot;ids&quot; open=&quot;id IN(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 2.1 SQL片段 作用：将公共的SQl片段抽取出来，有点相当于jsp中把公共页面包含起来。 抽取： 1234&lt;sql id=&quot;user_list&quot;&gt; select * from user&lt;/sql&gt; 使用：1&lt;include refid=&quot;user_list&quot;&gt;&lt;/include&gt; 3.关联查询 在实际开发当中，我们往往需要对多张表进行关联查询，表与表之间有一对一与一对多的关系（多对多属于两个一对多） 3.1 一对一查询 从A表出发在B表当中只有唯一的数据行与之对应，结果最多返回一个数据集。 3.1.1 使用resultType 使用resultType接收，那么必须要有一个与之对应的pojo（因为查询结果有两张表的属性）。需要：重新定义一个pojo，继承其中的一张表对应的pojo。 新建pojo 1234567891011121314package pojo;/** * 为了实现多表连接查询 * 通过resultType返回 * @author rong * */public class UserOrder extends Order &#123; //这两个属性是来自于Order表，即B表中的属性 private String username; private Integer id; . . .(实现其get/set方法) 修改order的映射文件 1234567891011121314&lt;!-- ===================多表关联查询-1-1使用resultMap===================== --&gt;&lt;select id=&quot;getOrderUser&quot; resultType=&quot;pojo.UserOrder&quot;&gt; SELECT o.`id`, o.`user_id` userId, o.`number`, o.`createtime`, o.`note`, u.`username`, u.`address` FROM `order` o LEFT JOIN `user` u ON u.id = o.`user_id`&lt;/select&gt; 测试 1234567891011@Test public void testGetOrderUser() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); OrderMaper orderMaper = openSession.getMapper(OrderMaper.class); List &lt;UserOrder&gt;orderList = orderMaper.getOrderUser(); for (UserOrder order: orderList) &#123; System.out.println(order); &#125; openSession.close(); &#125; 3.1.2 使用resultMap 基于面向对象的思想，我们直接对原有的pojo对象进行改造，使之能够接收到返回的属性（添加属性）。添加一个User类型的属性（面向对象的思想） 123456789101112131415public class Order &#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; private User user1; . . .（set/get方法） 修改关系映射文件type：指定映射到哪一个pojo，就是返回的定义普通属性property:在pojo中的属性名column：在数据库中的列名association–配置一对一查询property：绑定Order中的用户属性 即Order.user1【注：为了区别pojo中的user对象，在Order中定义的是user1成员】 property对应的是需要你告知来自哪个pojo中的哪个属性【注：一定要与javaType（pojo类）中对应的属性名称相同，参考前面定义的user1】 javaType是property的数据类型，支持别名 123456789101112131415161718192021&lt;resultMap type=&quot;Order&quot; id=&quot;order_user_map&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;userId&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt; &lt;!-- association配置一对一查询 property：绑定Order中的用户属性 即Order.user1【注：为了区别pojo中的user对象，在Order中定义的是user1成员】 javaType：属性的数据类型 property的数据类型，支持别名 我感觉： property对应的是需要你告知来自哪个pojo中的哪个属性 javaType是property的数据类型，支持别名 --&gt; &lt;association property=&quot;user1&quot; javaType=&quot;pojo.User&quot;&gt; &lt;!-- 感觉：每一个块块都要有一个主键，而user表中的主键就对应Order表中的user_id --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; sql语句使用resultMap的名字使用前面定义的resultMap的名字。 12345678910111213&lt;select id=&quot;getOrderUserByMap&quot; resultMap=&quot;order_user_map&quot;&gt; SELECT o.`id`, o.`user_id`, o.`number`, o.`createtime`, o.`note`, u.`username`, u.`address` FROM `order` o LEFT JOIN `user` u ON u.id = o.`user_id` &lt;/select&gt; 3.2 一对多查询 当我们查询用户张三下了多少订单时，此时返回的是多个数据，基于一对多查询。改造pojo 12345678910111213public class User &#123; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private String uuid2;//uuid private List&lt;Order&gt; order123; . . . (Get/Set方法) 改造关系映射文件property:在pojo中的属性名column：在数据库中的列名collection:配置一对多的关系 property:用户的Order属性【注：在pojo.user中的属性，为了以示区别，这里我定义的是一个order123的属性】 ofType:property的数据类型，支持别名 其余配置与一对一相同 12345678910111213141516&lt;resultMap type=&quot;user&quot; id=&quot;user_order_map&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;!-- collection:配置一对多的关系 property:用户的Order属性【注：在pojo.user中的属性，为了以示区别，这里我定义的是一个order123的属性】 ofType:property的数据类型，支持别名 --&gt; &lt;collection property=&quot;order123&quot; ofType=&quot;pojo.Order&quot;&gt; &lt;id property=&quot;userId&quot; column=&quot;oid&quot;/&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; SQL语句 123456789101112131415&lt;select id=&quot;getUserOrderByMap&quot; resultMap=&quot;user_order_map&quot;&gt; SELECT u.`id`, u.`username`, u.`birthday`, u.`sex`, u.`address`, u.`uuid2`, o.`id` oid, o.`number`, o.`createtime` FROM `user` u LEFT JOIN `order` o ON o.`user_id` = u.`id` &lt;/select&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis学习（1）","slug":"java/MyBatis学习(1)","date":"2019-04-03T16:00:00.000Z","updated":"2019-04-05T12:31:09.153Z","comments":true,"path":"2019/04/04/java/MyBatis学习(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/04/java/MyBatis学习(1)/","excerpt":"MyBatis环境的搭建以及基本操作","text":"MyBatis环境的搭建以及基本操作 介绍MyBatis 目前最主流的持久层框架为hibernate与mybatis，而且国内目前情况使用Mybatis的公司比hibernate要多。 Hibernate学习门槛不低，要精通门槛更高。门槛高在怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate缓存与数据加载策略方面需要你的经验和能力都很强才行。国内目前前的情况精通hibernate技术大牛非常少。 sql优化方面，Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。当然了，Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。说得更深入一些，如果有个查询要关联多张表，比如5张表，10张表时，而且，我们要取的字段只是其中几张表的部分字段。这时用hibernate时就会显得非常力不从心。就算用hibernate的sqlquery，后续的维护工作也会让人发狂。1.工程搭建 我感觉框架的工作就是把许多事情都帮你去完成了，越是简洁的代码，背后实现的原理也就越复杂，每一个框架学习最难适应的就是工程的搭建，即入门。 1.1导jar包1.2准备pojo类（实体类相当于JavaBean） mybatis的查询返回，查询参数的输入都是以对象为实参进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 package pojo; import java.util.Date; public class User &#123; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private String uuid2;//uuid public String getUuid2() &#123; return uuid2; &#125; public void setUuid2(String uuid2) &#123; this.uuid2 = uuid2; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, sex=&quot; + sex + &quot;, birthday=&quot; + birthday + &quot;, address=&quot; + address + &quot;, uuid2=&quot; + uuid2 + &quot;]&quot;; &#125;&#125; 1.3配置SqlMapConfig.xml(核心配置文件一个)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 先加载内部标签，再加载外部文件，属性名称一致时，替换内容 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root1&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt;&lt;!-- 别名配置： 为什么要使用别名： 我们的关系映射文件的parameterType往往是一个类名.包名， 此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;package name=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;!-- 加载mapper映射文件有四种方式 1.加载resource &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; 2.class扫描（dao动态代理 接口+关系映射文件）&lt;mapper class=&quot;Mapper.mapper&quot;/&gt; 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.&lt;mapper url=&quot;&quot;/&gt;绝对路径（从磁盘上找，一般不使用该方法） --&gt; &lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;!--&lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper class=&quot;Mapper.mapper&quot;/&gt; --&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;package name=&quot;Mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.4配置关系映射文件（多个） 关系映射配置文件一般是对某一个实体的增删查改操作封装在一个映射文件中，在SqlMapConfig.xml中注入，实际开发中有多个。 user.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- nameSpace：命名空间，用于分离sql语句 --&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;!-- id:statementId 语句的唯一标识符 1. resultType:返回结果集的数据类型 ========&gt;包名.类名(如果是查询所有集) 2. parameterType:查询的入参的数据类型 规定死了等一下要传入参数的类型 3. #&#123;&#125;:点位符，相当于JDBC中的 ？ 4.$&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125; &lt;/select&gt;&lt;!-- ======================================================================== --&gt; &lt;!-- 如果你返回值是为集合（例如一个list），那么你只需要返回 值类型填返回list中的类型就行 --&gt; &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一 次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;value&#125;%&apos;; &lt;/select&gt;&lt;!-- =============================================================================== --&gt; &lt;!--插入用户 mysql内部函数：select LAST_INSERT_ID()返回最后一次插入值的ID #&#123;&#125;占位符里面填User类中的属性 尝试过，必须使用User类中的属性，否则报错 useGeneratedKeys:使用自增 keyProperty，这里是user的主键 这两个配置会自动调用 select LAST_INSERT_ID() mysql自带函数，返回最后一次插入值的ID --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 需求：当我们插入一条语句时， 我们往往可能将对另外一张表产生影响， 需要得到该插入数据的主键ID selectKey:主键返回 keyProperty:user表中的主键的属性 考虑的是UUID要交给user类的哪一个属性 resultType：主键的数据类型 order：指selectKey在何时执行，AFTER表示在之后，BEFORE表示在之前 将返回的主键返回到user类中的id属性 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; --&gt; INSERT INTO mybatis.user ( username, birthday, sex, address) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;); &lt;/insert&gt;&lt;!-- =================================================================================== --&gt; &lt;!-- 一般我们数据表中有时候没有ID，此时需要我们定义一个标识来标致主键 mysql内部函数 select UUID 返回其查询数据表中的唯一标识 --&gt; &lt;insert id=&quot;insertUserUUID&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 将会将会生成每条数据对应的唯一标识UUID并返回 但是，当使用selectKey的时候，就相当于我们自己定义每条数据的返回标识（主键）， useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;不会生效 而generateKey默认使用id为表示并返回，二者取其一 --&gt; &lt;selectKey keyProperty=&quot;uuid2&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&gt; select UUID() &lt;/selectKey&gt; INSERT INTO mybatis.user ( username, birthday, sex, address,uuid2) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;,#&#123;uuid2&#125;); &lt;/insert&gt;&lt;!-- ========================================================================= --&gt; &lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;!-- ========================================================================= --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 1.5测试类（增删查改）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package Test;import java.io.InputStream;import java.util.Date;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import Utils.SqlSessionFactoryUtils;import pojo.User;public class testDemo1 &#123; //根据用户ID查询用户信息，查询结果是一个 @Test public void test1() throws Exception&#123; //1.创建sqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.查找配置文件创建输入流 InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //3.加载配置文件，创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //注意：SQL中的增删改查方法都在SqlSession对象中 User user = sqlSession.selectOne(&quot;user.getUserById&quot;,1); System.out.println(user); //5.释放资源 sqlSession.close(); &#125; //根据用户的姓进行模糊查询，返回值是一个集合 @Test public void test2()&#123; //通过工具类得到SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); //创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //查询，返回一个list List&lt;User&gt; user = sqlSession.selectList(&quot;user.getUserByName&quot;,&quot;张&quot;); for(User u:user)&#123; System.out.println(u); &#125; //关闭资源 sqlSession.close(); &#125; //插入用户 @Test public void test3()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); //设置为true，sqlSession会默认提交 就不用手动提交 openSession.commit();// SqlSession openSession = sqlSessionFactory.openSession(true); User user = new User(); user.setUsername(&quot;大虎22&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); //通过selectKey将插入后生成的主键返回 openSession.insert(&quot;user.insertUser&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //插入用户，返回UUID @Test public void test4()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); //设置为true，sqlSession会默认提交 就不用手动提交 openSession.commit();// SqlSession openSession = sqlSessionFactory.openSession(true); User user = new User(); user.setUsername(&quot;大虎24&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); //通过selectKey将插入后生成的主键返回 openSession.insert(&quot;user.insertUserUUID&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //更新 //--------------------------------注意：更新与删除后一定要提交事务 @Test public void test5()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(10); user.setUsername(&quot;大虎25&quot;); //通过selectKey将插入后生成的主键返回// openSession.insert(&quot;user.updateUserName&quot;, user); //注意：此处用insert、select都可以达到相同的效果，但是为了规范 openSession.update(&quot;user.updateUserName&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //删除 @Test public void test6()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); openSession.delete(&quot;user.deleteUser&quot;,30); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125;&#125; mybatis的核心类：SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession 1.6入门小结 连接池的配置是在SqlMapConfig.xml映射文件中配置完毕的。其中就包括了数据库的连接。 sql查询语句的配置是在关系映射文件中实现的，在此工程下是user.xml 框架图（记）框架图的解释：MyBatis有两种配置文件 核心配置文件SqlMapConfig.xml(一个) 关系映射配置文件（多个）一般对应表的数量通过SqlSeessionFactoryBulder类连加载SqlSession只是一个接口，真正干活的是底层的执行器（Executor）2.MyBatis的dao开发(两种实现方式，推荐第二种)2.1原始dao开发注：使用原有的user.xml关系配置文件 定义一个UserDao接口 12345678910111213141516171819202122232425262728293031323334package dao;import java.util.List;import pojo.User;/*当我们@param id* @return* 这些的时候，在我们从别的类里面去调用的时候，也会看到其中的注释* 养成好习惯，便于调用接口的时候，知道该接口是干嘛用的*//** * 用户信息持久化接口 * @author rong * */public interface UserDao &#123; /** * 根据用户ID查询用户信息 * @param id * @return */ public User getUserById(Integer id); /** * 根据用户名查找用户列表 * @param name * @return */ public List&lt;User&gt;getUserByName(String name); /** * 添加用户 * @param user */ public void insertUser(User user);&#125; 定义接口的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package dao.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import Utils.SqlSessionFactoryUtils;import dao.UserDao;import pojo.User;/** * 用户信息接口实现类 * @author rong * */public class UserDaoImpl implements UserDao &#123; @Override public User getUserById(Integer id) &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); User user = openSession.selectOne(&quot;user.getUserById&quot;,10); openSession.close(); return user; &#125; @Override public List&lt;User&gt; getUserByName(String name) &#123; // TODO Auto-generated method stub SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); List&lt;User&gt; users = openSession.selectList(&quot;user.getUserByName&quot;, name); openSession.close(); return users; &#125; @Override public void insertUser(User user) &#123; // TODO Auto-generated method stub SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); openSession.insert(&quot;user.insertUser&quot;, user); openSession.commit(); openSession.close(); &#125;&#125; 测试类小技巧：使用dao测试 一键生成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package Test;import static org.junit.Assert.fail;import java.util.Date;import java.util.List;import org.junit.Test;import dao.UserDao;import dao.impl.UserDaoImpl;import pojo.User;/** * 直接针对接口生成测试类 * @author rong * */public class UserDaoTest &#123; @Test public void testGetUserById() &#123; UserDao userDao=new UserDaoImpl(); User user = userDao.getUserById(10); System.out.println(user); &#125; @Test public void testGetUserByName() &#123; UserDao userDao=new UserDaoImpl(); List&lt;User&gt; users = userDao.getUserByName(&quot;张&quot;); for(User u:users)&#123; System.out.println(u); &#125; &#125; @Test public void testInsertUser() &#123; UserDao userDao=new UserDaoImpl(); User user = new User(); user.setUsername(&quot;大虎25&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); userDao.insertUser(user); &#125;&#125; 2.2接口动态代理(只有接口，没有实现类)1 定义dao接口123456789101112131415161718192021222324252627282930313233343536package Mapper;import java.util.List;import pojo.User;/*当我们@param id* @return* 这些的时候，在我们从别的类里面去调用的时候，也会看到其中的注释* 养成好习惯，便于调用接口的时候，知道该接口是干嘛用的*//** * 用户信息持久化接口（dao动态代理）核心方法openSession.getMapper(mapper.class)得到代理对象 * @author rong * */public interface mapper&#123; /** * 根据用户ID查询用户信息 * @param id * @return */ public User getUserById(Integer id); /** * 根据用户名查找用户列表 * @param name * @return */ public List&lt;User&gt;getUserByName(String name); /** * 添加用户 * @param user */ public void insertUser(User user);&#125; 关系配置文件的规则 1.namespace必需是接口的全路径名2.接口的方法名必需与映射文件的sql id一致3.接口的输入参数必需与映射文件的parameterType类型一致4.接口的返回类型必须与映射文件的resultType类型一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- dao的动态代理规则： 1.namespace必须是dao接口类的全路径 2.映射文件的sql ID必须与接口的方法名一致 3.映射文件parameterType的类型必须与接口输入参数一致 4.映射文件的resultType的类型必须与接口的输出参数一致 --&gt;&lt;mapper namespace=&quot;Mapper.mapper&quot;&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.User&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125; &lt;/select&gt;&lt;!-- =================================================================================================== --&gt; &lt;!-- 如果你返回值是为集合（例如一个list），那么你只需要返回值类型填返回list中的类型就行 --&gt; &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;value&#125;%&apos;; &lt;/select&gt;&lt;!-- =================================================================================================== --&gt; &lt;!--插入用户 mysql内部函数：select LAST_INSERT_ID()返回最后一次插入值的ID #&#123;&#125;占位符里面填User类中的属性 尝试过，必须使用User类中的属性，否则报错 useGeneratedKeys:使用自增 keyProperty，这里是user的主键 这两个配置会自动调用 select LAST_INSERT_ID() mysql自带函数，返回最后一次插入值的ID --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 需求：当我们插入一条语句时，我们往往可能将对另外一张表产生影响，需要得到该插入数据的主键ID selectKey:主键返回 keyProperty:user表中的主键的属性 考虑的是UUID要交给user类的哪一个属性 resultType：主键的数据类型 order：指selectKey在何时执行，AFTER表示在之后，BEFORE表示在之前 将返回的主键返回到user类中的id属性 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; --&gt; INSERT INTO mybatis.user ( username, birthday, sex, address) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;); &lt;/insert&gt;&lt;!-- ================================================================================================ --&gt; &lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;!-- ================================================================================================== --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 在SqlMapConfig中加载映射文件 12345&lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;/mappers&gt; 测试类那么，动态代理将会自动帮我们 核心方法 openSession.getMapper(mapper.class)返回该类口的一个匿名实现类，你只需要用接口去接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package Test;import java.util.Date;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import Mapper.mapper;import Utils.SqlSessionFactoryUtils;import pojo.User;/** * dao动态代理的测试类 * @author rong * */public class mapperTest &#123; @Test public void testGetUserById() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象，传入的参数是接口的class文件 mapper mapp = openSession.getMapper(mapper.class); User user = mapp.getUserById(10); System.out.println(user); openSession.close(); &#125; @Test public void testGetUserByName() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象 mapper mapp = openSession.getMapper(mapper.class); List&lt;User&gt; users = mapp.getUserByName(&quot;大&quot;); for(User user:users)&#123; System.out.println(user); &#125; openSession.close(); &#125; @Test public void testInsertUser() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象 mapper mapp = openSession.getMapper(mapper.class); User user = new User(); user.setUsername(&quot;大虎26&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); mapp.insertUser(user); openSession.commit(); openSession.close(); &#125;&#125; 3.SqlMapConfig.xml配置 SqlMapConfig.xml作为mybatis的核心配置文件，其约束采用DTD，其各个标签的含义如下： 3.1 properties配置配置原因：在我们配置数据库连接词时往往有许多参数，我们需要把这些参数抽取出来方便统一化管理。db.properties1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root 3.2 typeAliases(别名配置) 别名配置： 为什么要使用别名：我们的关系映射文件的parameterType往往是一个类名.包名，此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 3.3mappers(映射器配置) 加载mapper映射文件有四种方式 1.加载resource 2.class扫描（dao动态代理 接口+关系映射文件） 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.绝对路径（从磁盘上找，一般不使用该方法） 最后将上述操作放在一起SqlMapConfig.xml如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 先加载内部标签，再加载外部文件，属性名称一致时，替换内容 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root1&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt;&lt;!-- 别名配置： 为什么要使用别名：我们的关系映射文件的parameterType往往是一个类名.包名，此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;package name=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;!-- 加载mapper映射文件有四种方式 1.加载resource &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; 2.class扫描（dao动态代理 接口+关系映射文件）&lt;mapper class=&quot;Mapper.mapper&quot;/&gt; 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.&lt;mapper url=&quot;&quot;/&gt;绝对路径（从磁盘上找，一般不使用该方法） --&gt; &lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;!--&lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper class=&quot;Mapper.mapper&quot;/&gt; --&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;package name=&quot;Mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MySql连接异常解决","slug":"java基础/MySql","date":"2019-03-23T16:00:00.000Z","updated":"2019-03-24T13:04:40.330Z","comments":true,"path":"2019/03/24/java基础/MySql/","link":"","permalink":"http://SlectRxz.github.io/2019/03/24/java基础/MySql/","excerpt":"关于服务器启动MySql服务失败，以及密码错误如何修改","text":"关于服务器启动MySql服务失败，以及密码错误如何修改 MYSQL修复日志 最近很手残的把MYSQL中的mysql数据库中的user表给删掉了，然后在服务中MYSQL就无法启动，windows无法启动MySQL服务报错1067 的解决办法。 在网上找了许多资料，其中大概都是卸载重装，作为程序员永不放弃的精神，终于让我找到了一篇大佬的博客，不用重新安装。 链接如下：错误1067解决博客大致意思就是把安装MySQL路径下的文件copy到C盘下的ProgramData下的MySQL因为windows无法启动MySQL服务报错1067的原因是由于C:\\ProgramData\\MySQL\\MySQL Server 5.5\\data\\mysql下面缺少文件（反正我是由于删掉了user），正是如此，我们把MySQL安装目录下mysql文件夹下的文件，看缺什么就copy什么。 1.找文件 2.缺啥补啥，两个对应的 然后此时此刻，发现服务中MYSQL服务可以正常启动了，但是！！！数据库链接错误1045Access denied for user ‘root‘@’localhost’ (using password:YES) 这就是密码错误嘛。我估计是由于我换了那三个user文件导致的，此时此刻，只想说一句MMP MySQL修改登录密码解决方法经过不懈努力，终于找到了修改密码的方法。1.找到MYSQL安装路径下的my.ini文件，用记事本打开2.添加语句skip-grant-tables在如下位置添加：（图片来自网络）大佬的解释skip-grant-tables的作用是： skip-grant-tables作为启动参数的作用：MYSQL服务器不加载权限判断，任何用户都能访问数据库。也就是说，添加后数据库的安全性将会降低。 3.在cmd下mysql -u root -p,遇到Enter password直接回车 注意：如果你显示无效命令，就先进入到MYSQL目录下的bin目录在连接 4.进入mysql数据库，修改密码 use mysql//使用这个数据库update user set password=password(“123456”) where user=”root”//修改数据库密码flush privileges//刷新数据库 此时修改密码已经完成，再将my.ini中添加的语句删掉，再重启MySQL服务即可。","categories":[{"name":"MySql","slug":"MySql","permalink":"http://SlectRxz.github.io/categories/MySql/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Spring学习日志（2）","slug":"java/Spring学习(2)","date":"2019-03-19T16:00:00.000Z","updated":"2019-03-20T08:25:07.750Z","comments":true,"path":"2019/03/20/java/Spring学习(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/03/20/java/Spring学习(2)/","excerpt":"Spring框架的AOP的注解开发，SpringJDBC模板的使用","text":"Spring框架的AOP的注解开发，SpringJDBC模板的使用 Spring（1）回顾 Spring的IOC的注解开发 注解的入门 引入aop的包 引入context约束 开启扫描类上的注解&lt;context:component-scan /&gt; 开启扫描方法、成员上的注解&lt;context:annotation-config/&gt; 使用注解开发 @Component ：定义Bean @Controller ：WEB层 @Service ：Service层 @Repository ：DAO层 属性注入： 普通属性 ：@Value 对象属性 ：@Resource 不是Spring中的 @Autowired ：按类型注入属性，按名称@Qulifier XML方式和注解方式比较 XML方式 ：适用性更广，结构更加清晰。 注解方式 ：适用类是自己定义，开发更方便。 XML和注解的整合开发（重点） XML定义类 注解属性注入 Spring的AOP的基于AspectJ的XML的开发 AOP的概述 AOP：面向切面编程，是OOP的扩展和延伸，是用来解决OOP遇到问题。 Spring的AOP 底层的实现 JDK的动态代理 Cglib的动态代理 AOP的相关术语 连接点：可以被拦截的点。 切入点：真正被拦截的点。 通知：增强方法 引介：类的增强 目标：被增强的对象 织入：将增强应用到目标的过程。 代理：织入增强后产生的对象 切面：切入点和通知的组合 AOP的入门开发 引入jar包 编写目标类并配置 编写切面类并配置 进行aop的配置123456&lt;aop:config&gt; &lt;aop:pointcut expression=”execution(表达式)” id=”pc1”/&gt; &lt;aop:aspect &gt; &lt;aop:before method=”” pointcut-ref=”pc1”/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 前置通知 后置通知 环绕通知 异常抛出通知 最终通知 切入点表达式写法Spring的基于ApspectJ的注解的AOP开发###1. 实现步骤1.1创建项目，导入jar包1.2引入配置文件12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;事务管理&lt;/beans&gt; 1.3编写目标类并配置12&lt;bean id=&quot;orderDao&quot; class=&quot;Spring.demo2.OrderDao&quot;&gt;&lt;/bean&gt; 也可以直接使用类上注解的方式，此时开启类上注解扫描 &lt;context:component-scan base-package=”Spring.demo2”&gt;&lt;/context:component-scan&gt; 1.4编写切面类并配置 说明：1.需要在类上配置@Aspect，说明这是一个切面类2.在方法上配置如何增强，中的属性会告诉你Spring在哪个方法上的哪个类上应用增强。1234567891011121314151617181920212223242526272829package Spring.demo2;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component(value=&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(value=&quot;execution(* Spring.demo2.OrderDao.add(..))&quot;) public void befor()&#123; System.out.println(&quot;----------前置增强-----&quot;); &#125; //可以获取被增强方法的返回值，注意两个result必须相同 @AfterReturning(value=&quot;execution(* Spring.demo2.OrderDao.delete(..))&quot;,returning=&quot;result&quot;) public void after(Object result)&#123; System.out.println(&quot;-------后置增强-----&quot;+result); &#125; @Around(value=&quot;execution(* Spring.demo2.OrderDao.update(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;-------环绕前增强------&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;----环绕后增强-------&quot;); return proceed; &#125;&#125; 1.5编写测试类1234567891011121314151617181920212223242526272829303132package Spring.demo2;import javax.annotation.Resource;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * Spring的AOP的基于AspectJ注解开发 * 注意事项： * 1.导包 * 2.导入XML中的配置文件 * 3.在XML中开启AOP注解开发&lt;aop:aspectj-autoproxy/&gt; * 4.扫描类上的注解&lt;context:component-scan base-package=&quot;Spring.demo2&quot;&gt;&lt;/context:component-scan&gt; * 或者 &lt;context:annotation-config/&gt; 在没有扫描的情况下，使用注解 @Resource @value、@Autowired、@Qulifier * @author rong * */@RunWith(SpringJUnit4ClassRunner.class)//固定写法@ContextConfiguration(&quot;classpath:applicationContextAop.xml&quot;)public class Test &#123; @Resource(name=&quot;OrderDao&quot;) private OrderDao orderDao; @org.junit.Test public void test1()&#123; orderDao.find(); orderDao.add(); orderDao.delete(); orderDao.update(); &#125;&#125; 2.Spring的注解的AOP通知类型2.1@Befor前置通知1234@Before(value=&quot;execution(* Spring.demo2.OrderDao.add(..))&quot;) public void befor()&#123; System.out.println(&quot;----------前置增强-----&quot;); &#125; 2.2@AfterReturning后置通知12345//可以获取被增强方法的返回值，注意两个result必须相同 @AfterReturning(value=&quot;execution(* Spring.demo2.OrderDao.delete(..))&quot;,returning=&quot;result&quot;) public void after(Object result)&#123; System.out.println(&quot;-------后置增强-----&quot;+result); &#125; 2.3@Around环绕通知12345678//注意：写方法的时候需要返回一个Object,返回的是被增强的方法@Around(value=&quot;execution(* Spring.demo2.OrderDao.update(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;-------环绕前增强------&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;----环绕后增强-------&quot;); return proceed; &#125; 2.4@AfterThrowing：异常抛出通知 2.5@After最终通知 3.Spring的注解AOP切入点的配置 使用情景：假设在同一个方法上我需要进行多个通知，那么比较麻烦的是我需要在每个方法上都配置，但是如果有一天我增强的方法改了，导致我 需要在每个方法上都进行修改配置 3.1Spring的AOP的注解切入点的配置 4.Spring的JDBC模板的使用 Spring是EE开发的一站式的框架，有EE开发的每层的解决方案。Spring对持久层也提供了解决方案：ORM模块和JDBC的模板。Spring提供了很多的模板用于简化开发 4.1如何使用 以下使用分为以下几步：1.导入jar包2.准备数据库。3.使用JDBC模板保存数据4.将连接池和模板类交给Spring管理5.编写测试类 4.1.1 导入jar包 4.1.2 使用Spring提供的JDBC模板 核心类：JdbcTemplate jdbc=new JdbcTemplate(dataSource);注意： 需要传入的是一个连接池对象，也支持无参的构造方法，可以使用jdbc.setDataSource(dataSource)配置。12345678910111213//1.不使用Spring管理 @Test public void test1()&#123; //获取连接池（Spring自带的一个） DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //创建JDBC模板 JdbcTemplate jdbc=new JdbcTemplate(dataSource); jdbc.update(&quot;insert into stu values (?,?,?,?)&quot;,101,&quot;张大胖1&quot;,&quot;男&quot;,25); &#125; 4.1.3 把连接池和模板交给Spring管理 说明： 一直我都在想，所谓的交给Spring管理，意思就是把那些需要我们new的对象用注解去代替new的过程。123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/student&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1.4编写测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package SpringJDBC.demo3;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * 使用Spring提供的JDBC模板 * Spring提供的JDBC模板核心类： * JdbcTemplate jdbc=new JdbcTemplate(dataSource); * 其中连接池的核心类： * 1.Spring提供的连接池 * DriverManagerDataSource dataSource = new DriverManagerDataSource(); * 2.c3p0连接池 * ComboPooledDataSource dataSource2 = new ComboPooledDataSource(); * 3.DBCP连接池 * new BasicDataSource(); * @author rong * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContextJDBC.xml&quot;)public class JDBCTest &#123; //1.不使用Spring管理 @Test public void test1()&#123; //获取连接池（Spring自带的一个） DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //创建JDBC模板 JdbcTemplate jdbc=new JdbcTemplate(dataSource); jdbc.update(&quot;insert into stu values (?,?,?,?)&quot;,101,&quot;张大胖1&quot;,&quot;男&quot;,25); &#125; //2.将其交给Spring管理 //说明：那个类需要new的时候，就可以把这个类交给Spring管理，不需要自己去new @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void test2()&#123; jdbcTemplate.update(&quot;insert into stu values (?,?,?,?)&quot;,103,&quot;张大胖3&quot;,&quot;男&quot;,25); &#125; //3.使用c3p0连接池 /** * 导包 * 有使用配置文件和不使用配置文件两种方式 */ @Test public void test3()&#123; jdbcTemplate.update(&quot;insert into stu values (?,?,?,?)&quot;,105,&quot;张大胖5&quot;,&quot;男&quot;,25); &#125;&#125; 4.2抽取配置信息到属性文件 使用场景： 在实际开发中，将配置文件的参数单独放在一个配置文件，在XML文件中再将其引入进来 ，username，password 4.2.1 定义一个属性文件 创建一个properties的文件1234jdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/studentjdbc.username=rootjdbc.password=root 4.2.2 如何在Spring的配追文件（XML）中引入属性文件 有两种方式1.(用的少)123&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:properties&quot;/&gt;&lt;/bean&gt; 2.(常用)1&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; 就会去加载类路径下的属性文件了，我猜测是放在域对象中，后面直接${key}取出。 4.2.3 对应在配置文件中的写法 注意property中的value的写法12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"数据库连接池以及JDBUtils使用","slug":"java基础/JDBC","date":"2019-03-05T16:00:00.000Z","updated":"2019-03-06T08:05:44.028Z","comments":true,"path":"2019/03/06/java基础/JDBC/","link":"","permalink":"http://SlectRxz.github.io/2019/03/06/java基础/JDBC/","excerpt":"数据库连接池，包括DBCP以及C3P0，DBUtils工具的使用","text":"数据库连接池，包括DBCP以及C3P0，DBUtils工具的使用 数据库连接池 数据库的连接对象创建工作，比较消耗性能。 2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。 后面需要连接的话，直接从池子里面去。不要去自己创建连接了。 使用完毕， 要记得归还连接。确保连接对象能循环利用。 下面内容是我搬运别人写的比较好的内容 没有池的情况 认识池说明：123451、 池就是一种容纳对象的容器2、 连接池就是保存数据库连接对象的容器3、 在连接池中我们会预先创建一定数量的连接对象，当需要数据库连接的时候，只要从数据库连接池中取出一个，使用完毕之后就再放回去，这些连接对象是以一种循环队列来存放的，取的时候从头开始，放回的时候放在尾部。4、 通过设置最大连接数量来防止系统无止尽的与数据库连接5、 连接池中可以设置监听机制，用来测试连接的数量 连接池中的属性 连接池的使用 自定义数据库连接池 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package 连接池;import java.io.PrintWriter;import java.sql.Connection;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.ArrayList;import java.util.List;import java.util.logging.Logger;import javax.sql.DataSource;/** * * @author rong *这是一个数据库连接池 *1. 一开始先往连接池中放10个连接 *2. 来的程序通过getConnection()连接 *3. 用完通过addBack()归还 *4. 扩容 *//** * * @author rong *有缺陷 *1. 需要额外记住addBack()方法 *2. 无法面向接口编程 *DaoSource datasource=new MyDataSource(); * *JAVA多态 *编译时候看左边，运行时候看右边 *解释：编译的时候看接口中有没有定义这个方法，运行的时候是运行继承类口的类中的方法 */public class MyDataSource implements DataSource&#123; List&lt;Connection&gt; list=new ArrayList&lt;Connection&gt;(); public MyDataSource()&#123; for(int i=0;i&lt;10;i++)&#123; Connection conn = JDBCUtil.getConn(); list.add(conn); &#125; &#125; //该连接池对外公布的获取连接的方法 @Override public Connection getConnection() throws SQLException &#123; // TODO Auto-generated method stub if(list.size()==0)&#123;//连接不够再创建5个 for(int i=0;i&lt;5;i++)&#123; Connection conn = JDBCUtil.getConn(); list.add(conn); &#125; &#125; Connection connection = list.remove(0);//永远移除第一个 return connection; &#125; public void addBack(Connection conn)&#123; list.add(conn); &#125; //---------------后面的方法暂时用不到-----------------------// @Override public PrintWriter getLogWriter() throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public void setLogWriter(PrintWriter out) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public void setLoginTimeout(int seconds) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public int getLoginTimeout() throws SQLException &#123; // TODO Auto-generated method stub return 0; &#125; @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123; // TODO Auto-generated method stub return null; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return false; &#125; @Override public Connection getConnection(String username, String password) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125;&#125; 出现的问题： 需要额外记住 addBack方法 单例。 无法面向接口编程。 UserDao dao = new UserDaoImpl();dao.insert(); DataSource dataSource = new MyDataSource(); 因为接口里面没有定义addBack方法。 4. 怎么解决? 以addBack 为切入点。 解决自定义数据库连接池出现的问题。 由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。 我们打算修改接口中的那个close方法。 原来的Connection对象的close方法，是真的关闭连接。打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。 如何扩展某一个方法? 原有的方法逻辑，不是我们想要的。 想修改自己的逻辑 直接改源码 无法实现。 继承， 必须得知道这个接口的具体实现是谁。 使用装饰者模式。 开源连接池DBCP（database connection pool） 导入jar文件 不使用配置文件： public void testDBCP01(){ Connection conn = null; PreparedStatement ps = null; try { //1. 构建数据源对象 BasicDataSource dataSource = new BasicDataSource(); //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。 //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admin&quot;); ps.setInt(2, 1000); ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } 使用配置文件方式： Connection conn = null; PreparedStatement ps = null; try { BasicDataSourceFactory factory = new BasicDataSourceFactory(); Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;); properties.load(is); DataSource dataSource = factory.createDataSource(properties); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;liangchaowei&quot;); ps.setInt(2, 100); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 配置文件dbcpconfig.properties 1234567891011121314151617181920212223242526272829303132#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcusername=rootpassword=#&lt;!-- 初始化连接 --&gt;initialSize=10#最大连接数量maxActive=50#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=gbk#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_UNCOMMITTED C3P0 拷贝jar文件 到 lib目录 不使用配置文件方式Connection conn = null; PreparedStatement ps = null; try { //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 使用配置文件方式1234567891011121314151617181920212223242526272829303132333435363738394041package 连接池;import java.sql.Connection;import org.junit.Test;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * C3P0数据库连接（使用XML作为配置文件） * 注意：当配置文件的名字为c3p0-config.xml时，在new ComboPooledDataSource()对象 * 时，会自动使用类加载器加载XML文件 * * @author rong * */public class C3P0Demo1 &#123; @Test public void test1()&#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); //注意： Connection conn=null; java.sql.PreparedStatement ps=null; try &#123; //获取连接对象 conn = comboPooledDataSource.getConnection(); //准备查询sql String sql=&quot;insert into stu value(16,?,?,42)&quot;; //获取statement ps= conn.prepareStatement(sql); ps.setString(1, &quot;胖虎&quot;); ps.setString(2, &quot;男&quot;); ps.executeUpdate(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; JDBCUtil.release(conn, ps); &#125; &#125;&#125; XML配置文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;!-- default-config 默认的配置， --&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost/student&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- This app is massive! --&gt; &lt;named-config name=&quot;oracle&quot;&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;1000&lt;/property&gt; &lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt; &lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;!-- he&apos;s important, but there&apos;s only one of him --&gt; &lt;user-overrides user=&quot;master-of-the-universe&quot;&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;50&lt;/property&gt; &lt;/user-overrides&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; DBUtils增删改//dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //增加 //queryRunner.update(&quot;insert into account values (null , ? , ? )&quot;, &quot;aa&quot; ,1000); //删除 //queryRunner.update(&quot;delete from account where id = ?&quot;, 5); //更新 //queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 10000000 , 6); 查询（两种方式） 直接new接口的匿名实现类 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;(){ //去执行查询，查询到的数据还是在那个result里面，然后调用下面的handle方法，由用户手动封装 @Override public Account handle(ResultSet rs) throws SQLException { Account account = new Account(); while(rs.next()){ String name = rs.getString(&quot;name&quot;); int money = rs.getInt(&quot;money&quot;); account.setName(name); account.setMoney(money); } return account; } }, 6); System.out.println(account.toString()); 直接使用框架已经写好的实现类。 * 查询单个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //查询单个对象 Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 8); * 查询多个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); List&lt;Account&gt; list = queryRunner.query(&quot;select * from account &quot;, new BeanListHandler&lt;Account&gt;(Account.class)); ResultSetHandler 常用的实现类以下两个是使用频率最高的 BeanHandler, 查询到的单个数据封装成一个对象 BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt; ArrayHandler, 查询到的单个数据封装成一个数组 ArrayListHandler, 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 MapHandler, 查询到的单个数据封装成一个map MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 ColumnListHandlerKeyedHandlerScalarHandler 总结数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 queryRunner.update();增删改 queryRunner.query查","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://SlectRxz.github.io/categories/JDBC/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"事务","slug":"java基础/事务","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-06T03:28:49.248Z","comments":true,"path":"2019/03/04/java基础/事务/","link":"","permalink":"http://SlectRxz.github.io/2019/03/04/java基础/事务/","excerpt":"包括事务的特性ACID","text":"包括事务的特性ACID 事务事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库 rollback ; 数据回滚，回到最初的状态。 关闭自动提交功能。 演示事务 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); @Test public void testTransaction(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); int a = 10 /0 ; //加钱， 给ID为2 加100块钱 ps.setInt(1, -100); ps.setInt(2, 2); ps.executeUpdate(); //成功： 提交事务。 conn.commit(); } catch (SQLException e) { try { //事变： 回滚事务 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } } 注意： 关闭事务conn.setAutoCommit(false); 事务的提交conn.commit(); 回滚事务 conn.rollback(); 事务的特性ACID（面试会问） 原子性 指的是 事务中包含的逻辑，不可分割。 一致性 指的是 事务执行前后。数据完整性 隔离性 指的是 事务在执行期间不应该受到其他事务的影响 持久性 指的是 事务执行成功，那么数据应该持久保存到磁盘上。 事务的安全隐患 不考虑隔离级别设置，那么会出现以下（读和写）问题。 读 脏读 不可重读读 幻读. 脏读 一个事务读到另外一个事务还未提交的数据 不可重复读 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。 读未提交 演示 设置A窗口的隔离级别为 读未提交 两个窗口都分别开启事务 写 丢失更新 读已提交演示 设置A窗口的隔离级别为 读已提交 A B 两个窗口都开启事务， 在B窗口执行更新操作。 在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。 这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题 ，不可重复读。 可串行化 如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。 但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。 按效率划分，从高到低 读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 可串行化 按拦截程度 ，从高到底 可串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交 事务总结需要掌握的 在代码里面会使用事务 conn.setAutoCommit(false); conn.commit(); conn.rollback(); 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 事务是会自动提交的。 需要了解的安全隐患读 脏读 一个事务读到了另一个事务未提交的数据 不可重复读 一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致 幻读 一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。 写 丢失更新。 隔离级别读未提交 引发问题： 脏读 读已提交 解决： 脏读 ， 引发： 不可重复读 可重复读 解决： 脏读 、 不可重复读 ， 未解决： 幻读 可串行化 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读 Oracle 默认的隔离级别是 读已提交 丢失更新 解决丢失更新 悲观锁 可以在查询的时候，加入 for update 乐观锁 要求程序员自己控制。 总结事务使用命令行演示 使用代码演示 脏读、 不可重复读、 幻读 丢失更新 悲观锁 乐观锁 4个隔离级别 读未提交 读已提交 可重复读 可串行化","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://SlectRxz.github.io/categories/JDBC/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"四大域对象","slug":"java基础/javaWeb基础之域对象","date":"2019-02-27T16:00:00.000Z","updated":"2019-04-10T09:53:47.427Z","comments":true,"path":"2019/02/28/java基础/javaWeb基础之域对象/","link":"","permalink":"http://SlectRxz.github.io/2019/02/28/java基础/javaWeb基础之域对象/","excerpt":"四大域对象的生命周期、作用范围、作用的总结。","text":"四大域对象的生命周期、作用范围、作用的总结。 根据有作用范围由小到大：page(jsp有效)——》page域指的是pageContext.request(一次请求)—》request域request HttpServletContextsession(一次会话)—》session域session HttpSessionapplication(当前web应用)—》application域指的是application ServletContext；之所以他们是域对象，原因是他们都内置了map集合，都有setAttribute和getAttribute方法。 一、 PageContext域1.生命周期：当对JSP的请求开始，当相应结束时销毁。 jsp页面被执行，声明周期开始； jsp页面执行完毕，声明周期结束；2.作用范围：整个JSP页面，是四大作用域中最小的一个。3.作用： 获取其它八大隐式对象，可以认为是一个入口对象。 获取其所有域中的数据 pageContext 操作所有域中属性的方法public java.lang.Object getAttribute(java.lang.String name,int scope) public void setAttribute(java.lang.String name, java.lang.Object value,int scope)public void removeAttribute(java.lang.String name,int scope) pageContext 中代表域的常量 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPEfindAttribute方法,在四大域中搜寻属性，搜寻的顺序是page域、request域、session域、application域，从小域到大域开始搜索，如果搜索到就直接获取该值，如果所有域中都找不到，返回一个null(与el表达式不同，此处返回null，对网页是不友好的) （3）跳转到其他资源 其身上提供了forward和include方法，简化重定向和转发的操作二、Request域1.生命周期： 在Service方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。 用户发送一个请求，开始，服务器返回响应，请求结束，生命周期结束；2.作用范围：整个请求链（请求转发也存在）3.作用：在整个请求链中共享数据，经常用到：在servlet中处理好的数据交给JSP显示，此时参数就可以放在Request域中。三、HttpSession 域1.生命周期： 在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个session并返回。（1）当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。（2）如果服务器非正常关闭，没有到期的session也会跟着销毁。（3）如果调用session提供的invalidate()，可以立即销毁session。用户打开浏览器访问，创建session（开始），session超时或者被声明失效，该对象生命周期结束；2.作用范围：一次会话。HttpSession 在服务器中，为浏览器创建独一无二的内存空间，在其中保存会话相关的信息注意：服务器正常关闭，再启动，Session对象会进行钝化和活化操作。同时如果服务器钝化的时间在session 默认销毁时间之内， 则活化后session还是存在的。否则Session不存在。 如果JavaBean 数据在session钝化时，没有实现Serializable 则当Session活化时，会消失。 四、ServletContext1.生命周期： 当WEB应用被加载进容器创建代表整个WEB应用的ServletContext对象； 当服务器关闭或WEB应用被移除时，ServletContext对象跟着被销毁。2.作用范围：整个WEB应用。3、作用：a)在不同Servlet 之间转发this.getServletContext().getRequestDispatcher(“/servlet/Demo10Servlet”).forward(request,response);方法执行结束，service就会返回到服务器，再有服务器去调用目标servlet，其中request会重新创建，并将之前的request的数据拷贝进去。b)读取资源文件。1、由于相对路径默认相对的是java虚拟机启动的目录，所以我们直接写相对路径将会是相对于tomcat/bin目录，所以是拿不到资源的。如果写成绝对路径，当项目发布到其他环境时，绝对路径就错了。为了解决这个问题ServletContext提供了：this.getServletContext().getRealPath(“/1.properties”)，给进一个资源的虚拟路径，将会返回该资源在当前环境下的真实路径。 this.getServletContext().getResourceAsStream(“/1.properties”)，给一个资源的虚拟路径返回到该资源真实路径的流。2、当在非servlet下获取资源文件时，就没有ServletContext对象用了，此时只能用类加载器classLoader.getResourceAsStream(“../../1.properties”)，此方法利用类加载器直接将资源加载到内存中，有更新延迟的问题，以及如果文件太大，占用内存过大。classLoader.getResource(“../1.properties”).getPath()，直接返回资源的真实路径，没有更新延迟的问题。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"监听器与过滤器","slug":"java基础/Listener&Filter","date":"2019-02-26T16:00:00.000Z","updated":"2019-03-07T08:43:07.629Z","comments":true,"path":"2019/02/27/java基础/Listener&Filter/","link":"","permalink":"http://SlectRxz.github.io/2019/02/27/java基础/Listener&Filter/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Listener &amp; FilterListener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 监听器使用： 定义一个类，实现接口 注册 | 配置监听器 1.监听三个作用域创建和销毁request —httpServletRequest session —httpSession application — ServletContext 1. ServletContextListener servletcontext在什么时候创建？ 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 2. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 public class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 销毁了&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 初始化了&quot;); } } &lt;listener&gt; &lt;listener-class&gt;com.itheima.listener.MyRequestListener&lt;/listener-class&gt; &lt;/listener&gt; 3. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;创建session了&quot;); } @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;销毁session了&quot;); } } 作用： ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 2.监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 （就是监听这个值在不在session中） 1. 让javaBean 实现该接口即可 @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被绑定进来了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被解除绑定&quot;); } HttpSessionActivationListener 用于监听检测现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作注意：serializable接口，标志着该类可以实现序列化与反序列化，要想该类能够实现序列化与反序列化，必须继承该类 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 1. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:8080 3. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\\tomcat\\apache-tomcat-7.0.52\\work\\Catalina\\localhost\\ListenerDemo\\itheima &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;itheima&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { } } 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 ###Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain chain.doFilter(request, response); 放行， 让请求到达下一个目标。 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;写法格式与servlet一样。/*代表着你过滤谁 全路径匹配 以 / 开始 /LoginServlet 只有访问这个servlet时才拦截 以目录匹配 以 / 开始 以 * 结束 /demo01/* 只有访问demo01目录下的文件才会拦截 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。 自动登录 需求分析 1. 搭建环境 搭建数据库 搭建页面 登录servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String autoLogin = request.getParameter(&quot;auto_login&quot;); UserBean user = new UserBean(); user.setUsername(userName); user.setPassword(password); UserDao dao = new UserDaoImpl(); UserBean userBean = dao.login(user); if(userBean != null){ //成功了，进入首页 request.getSession().setAttribute(&quot;userBean&quot;, userBean); response.sendRedirect(&quot;index.jsp&quot;); }else{ //不成功... request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response); } } catch (SQLException e) { e.printStackTrace(); } } 过滤器代码(见AutoLogin代码) 过滤器的核心不是完成拦截不给 ， 还是放行显示。 它的核心是在放行之前，帮用户完成登录的功能。 实现思路 先判断session是否有效， 如果有效，就不用取cookie了，直接放行。 如果session失效了，那么就取 cookie。 没有cookie 放行 有cookie 1. 取出来cookie的值，然后完成登录 2. 把这个用户的值存储到session中 3. 放行。 /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest req, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { HttpServletRequest request = (HttpServletRequest) req; //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //先判断，现在session中还有没有那个userBean. UserBean userBean = (UserBean) request.getSession().getAttribute(&quot;userBean&quot;); //还有，有效。 if(userBean != null){ chain.doFilter(request, response); }else{ //代表session失效了。 //2. 看cookie。 //1. 来请求的时候，先从请求里面取出cookie , 但是cookie有很多的key-value Cookie[] cookies = request.getCookies(); //2. 从一堆的cookie里面找出我们以前给浏览器发的那个cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;auto_login&quot;); //第一次来 if(cookie == null){ chain.doFilter(request, response); }else{ //不是第一次。 String value = cookie.getValue(); String username = value.split(&quot;#itheima#&quot;)[0]; String password = value.split(&quot;#itheima#&quot;)[1]; //完成登录 UserBean user = new UserBean(); user.setUsername(username); user.setPassword(password); UserDao dao = new UserDaoImpl(); userBean = dao.login(user); //使用session存这个值到域中，方便下一次未过期前还可以用。 request.getSession().setAttribute(&quot;userBean&quot;, userBean); chain.doFilter(request, response); } } } catch (Exception e) { e.printStackTrace(); chain.doFilter(req, response); } } BeanUtils的使用 导包注意：BeanUtils可以帮我们转换int，String等类型，但是日期类型转换不了总结如下： 如果form参数是String类型，javabean属性String类型 —- 调用BeanUtils.populate 将form数据封装 javabean 如果JavaBean属性类型不是String —- 将form数据封装javabean 需要转换器 —– 在BeanUtils API 提供很多默认转换器（完成常见转换） 如果需要转换类型非常特殊，可以通过自定义转换器完成 定义类实现Converter接口，实现convert方法 ，在populate调用之前通过ConvertUtils.register注册转换器 BeanUtils.populate(bean, map); //注册自己的日期转换器 ConvertUtils.register(new MyDateConverter(), Date.class); //转化数据 Map map = request.getParameterMap(); UserBean bean = new UserBean(); 转化map中的数据，放置到bean对象身上 BeanUtils.populate(bean, map); 总结Listener8个 三种类型 针对三个作用域的创建和销毁 针对三个作用域的值改变 【添加 | 替换 | 移除】 针对session中的值 【钝化 活化】 ， 【绑定 解绑】 钝化 ( 序列化 ) 内存中的对象存储到硬盘 超时失效。 session销毁了。 非正常关闭服务器， 钝化 。 正常关闭服务器 销毁 设置了session，多久时间。 context.xml 活化 (反序列化) 从硬盘里面读取到内存 ServletContextListner ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。HttpSessionListener ： 统计在线人数HttpSessionActivationListener ： 钝化活化处理 ##Filter 使用频率更高 如果要写一个过滤器。 定义一个类，实现接口 Filter 注册 . web.xml . 与servlet相似。 过滤器放行。 chain.doFilter(request, response); 过滤器生命周期 创建： 服务器加载这个项目的时候创建实例 销毁： 关闭服务器或者从服务器中移除项目的时候。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Spring学习日志（1）","slug":"java/Spring学习(1)","date":"2019-02-24T16:00:00.000Z","updated":"2019-02-27T02:00:53.542Z","comments":true,"path":"2019/02/25/java/Spring学习(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/02/25/java/Spring学习(1)/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Spring的简介什么是Spring Spring是一个开源框架，于2003年兴起的轻量级java开发框架，简单而言，Spring是一个分层的JAVASE/EEfull-stack（一站式）开源框架 Spring入门（IOC）一、什么是IOC IOC（Inversion of Control）：控制反转。控制反转：将对象的控制权反转交给Spring 导包 (官网：http://SPring.io/) 引入约束文件 在spring的解压路径下spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Spring底层实现原理： Spring学习路线 把类交给Spring处理，有两种方式 1 . 通过XML配置方式123456789package Spring.demo1;/** * 业务管理层的接口 * @author rong * */public interface UserService &#123; public void add();&#125; 123456789101112131415161718package Spring.demo1;/** * 业务管理层的实现类 * @author rong * */public class UserServiceImp implements UserService &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void add() &#123; // TODO Auto-generated method stub System.out.println(&quot;UserServiceImp被执行了&quot;+name); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package Spring.demo1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Test &#123; @org.junit.Test public void demo1()&#123;// UserService user=new UserServiceImp(); UserServiceImp user=new UserServiceImp(); user.setName(&quot;张三&quot;); user.add(); &#125; /** * Spring 方式的调用 */ @org.junit.Test public void demo2()&#123; /** * 创建Spring工厂 */ ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;application.xml&quot;); UserService User = (UserService) applicationContext.getBean(&quot;UserService&quot;); User.add(); &#125; @org.junit.Test public void demo3()&#123; /** * 加载磁盘上的配置文件 */ ApplicationContext applicationContext=new FileSystemXmlApplicationContext(&quot;D:\\\\111\\\\application.xml&quot;); UserService user = (UserService) applicationContext.getBean(&quot;UserService&quot;); user.add(); &#125;&#125; XML配置文件其中包括了属性的注入（通过构造函数或Set方法）SPEL的/font&gt;的注入集合的注入的注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring 入门的配置 id 相当于Spring生成类时，该类的一个编号，，，用于getBean() name 作用与上面相同 class 生成类的地址 包名.类名 init-method Spring在初始化该类的时候所执行的方法 destory-method Spring在关闭工厂的时候所执行的方法 scope 所创建的类是 单例模式-无论getBean几次，都只new一次（singleton） 多例模式-getBean几次就new几次 （prototype） request 生成的对象存放在域中 session 同上 globalsession 作用见word factory-method 在类初始化时，若不写默认调用无参的构造方法，若想指定构造方法，则使用该方法 --&gt; &lt;bean id=&quot;UserService&quot; class=&quot;Spring.demo1.UserServiceImp&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;Custom&quot; class=&quot;Spring.demo2.CustomImp&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; scope=&quot;prototype&quot; &gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;Spring.demo3.person&quot; &gt; &lt;/bean&gt; &lt;!-- 属性的注入 有两种方式 1.通过构造方式（有参构造） &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; 2.通过类的set方法 &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; 注意： 当成员不在是简单的属性，而实某一个对象时，value变为ref --&gt; &lt;bean id=&quot;car1&quot; class=&quot;Spring.demo4.car1&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;12220.0&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;东风&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; &lt;/bean &gt; --&gt; &lt;!-- 改用P名称空间注入 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot; p:name=&quot;东风&quot; p:price=&quot;4212.0&quot; &gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; --&gt; &lt;!-- 改用P名称 空间注入 注意： P名称空间注入走的也是set方法, 官方目的是简化set注入的property标签的写法 有set方法就不要有 有参的构造方法 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot; p:name=&quot;张三&quot; p:car-ref=&quot;car1&quot;&gt; &lt;/bean&gt; --&gt; &lt;!-- SPEL注入 使用#&#123;&#125;作为定界符 就是给改变了 value的赋值 没有改变的是 property 可以为数、字符串、boolean、其他对象、其他对象的属性和方法、支持运算符 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;张三&apos;&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 调用其他类的方法 --&gt; &lt;bean id=&quot;calculate&quot; class=&quot;Spring.demo4.calculate&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;calculate.name&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 集合属性的注入======================一般用于不同的框架的整合= --&gt; &lt;bean id=&quot;collectionBean&quot; class=&quot;Spring.demo5.collectionBean&quot;&gt; &lt;!-- int数组的注入 --&gt; &lt;property name=&quot;arr&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- List&lt;String&gt;集合注入 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set&lt;String&gt;set集合注入 --&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- map&lt;int,String&gt;集合的注入 --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;张三&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;2&quot; value=&quot;李四&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;3&quot; value=&quot;王五&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2 . 通过注解方式 导包除了引入基本的开发包，还需要引入AOP包 引入约束文件哪里找？spring-framework-4.2.4.RELEASE-docs\\spring-framework-reference\\html中找xsd-configuration.html中找到Context约束（其中包含了beans约束，beans约束是Spring中最基本的约束） 开启组件扫描(在XML文件中)12 &lt;!--=====扫描是为了扫描类上的注解 ============--&gt;&lt;context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan&gt; 编写测试类 12345package demo1;public interface UserDao &#123; public void sava();&#125; 1234567891011121314151617181920212223242526package demo1;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(value=&quot;UserDaoImp&quot;)//相当于&lt;bean id=&quot;UserDaoImp&quot; class=&quot;demo1.UserDaoImp&quot;&gt;&lt;/bean&gt;public class UserDaoImp implements UserDao &#123; @Value(&quot;张三&quot;) private String name; //可以不提供set方法，则需要将属性的注解添加到属性上；若有set方法，则需要将属性的注入添加到set方法上 /*@Value(&quot;张三&quot;) public void setName(String name) &#123; this.name = name; &#125;*/ @Override public void sava() &#123; // TODO Auto-generated method stub System.out.println(&quot;sava()方法执行了。。&quot;); &#125; @Override public String toString() &#123; return &quot;UserDaoImp [name=&quot; + name + &quot;]&quot;; &#125;&#125; 说明：属性注入的注解分为以下类型 普通类型 @value（“”）设置普通属性的值 对象类型@Autowired：设置对象的属性的值。注意：按照类型完成属性注入，而不是名称，与Component（“CLassName”）无关 一般我们习惯按名称匹配下面两个同时写 @Autowired@Qualifier(value=”ClassName”) //强制使它按照名称的属性注入@Resource(name=”ClassName”)：完成对象属性的注入，等价于上面连续两个(开发中常用) Bean的其他注解 1234567891011121314151617181920212223package demo2;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component(value=&quot;custom&quot;)//&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt;@Scope(&quot;prototype&quot;)public class custom &#123; @PostConstruct//初始化注解，相当于nit-method=&quot;init&quot; public void init()&#123; System.out.println(&quot;初始化方法执行了&quot;); &#125; public void save()&#123; System.out.println(&quot;save方法执行了&quot;); &#125; @PreDestroy//destory注解，相当于destory-method=&quot;destory&quot; public void destory()&#123; System.out.println(&quot;destory方法执行了&quot;); &#125;&#125; 说明： 生命周期相关的注解1&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt; @PostConstruct：初始化方法@PreDestory：销毁方法 Bean的作用范围注解(重要)@Scope( “ ”) ：作用范围 Prototype : 多例 Request : Session: Globalsession:测试案例： 123456789101112131415package demo2;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void test1()&#123; ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); custom c = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c); custom c2 = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c2); &#125;&#125; 输出结果： 1234初始化方法执行了demo2.custom@1d9d4b初始化方法执行了demo2.custom@1227d8d 说明：由于使用了@Scope(“prototype”)，多例模式初始化了两次，得到两个不同的id； 3 . 两种方式的比较 适用场景 XML：可以使用任何场景 结构清晰，维护方便 注解：必须修改源代码（如果你无法修改源代码，只能用XML） 开发方便，速度快 4 . XML与注解的整合开发思路：用XML用来管理类的注入，用注解完成属性的注入。测试案例：123456789package Demo3;import org.springframework.stereotype.Component;//@Component(&quot;order&quot;)public class order &#123; public void play() &#123; System.out.println(&quot;生产产品&quot;); &#125;&#125; 12345678910111213141516package Demo3;import javax.annotation.Resource;import org.springframework.stereotype.Component;//@Component(&quot;orderService&quot;)//相当于&lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;public class orderService &#123; @Resource(name=&quot;order&quot;)//这个name就是配置文件(applicationContext.xml)里面的或者 //如果是用的类上注解等同于@Component(value=”id/name”)中的id private order od; public orderService() &#123; System.out.println(&quot;无参构造方法被调用...&quot;); // TODO Auto-generated constructor stub &#125; public void t()&#123; od.play(); &#125;&#125; 12345678910111213141516package Demo3;import javax.annotation.Resource;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class Test &#123; @Resource(name=&quot;orderService&quot;) private orderService se; @org.junit.Test public void test1()&#123; se.t(); &#125;&#125; 配置文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--=====扫描是为了扫描类上的注解 ============--&gt; &lt;!-- context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan--&gt; &lt;context:annotation-config/&gt; &lt;!-- =======在没有扫描的情况下，使用注解 @Resource @value、@Autowired、@Qulifier --&gt; &lt;bean id=&quot;peopleImp&quot; class=&quot;Demo1.peopleImp&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;order&quot; class=&quot;Demo3.order&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"Servlet注解开发","slug":"java基础/Servlet注解","date":"2019-02-22T16:00:00.000Z","updated":"2019-02-23T07:56:01.625Z","comments":true,"path":"2019/02/23/java基础/Servlet注解/","link":"","permalink":"http://SlectRxz.github.io/2019/02/23/java基础/Servlet注解/","excerpt":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter","text":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter 在Servlet3.0中新增注解的功能，降低了配置XML所花费的时间与精力。注意：Tmocat7.0以上支持 一、@WebServlet注解 作用：用来配置Servlet，其将会在服务器启动时被tomcat容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet，个人感觉就是替代了传统的在web.xml中的配置。 参数说明 属性名 类型 属性描述 name String 指定Servlet的name属性，相当于 value String[] 等价于urlPatterns,二者不能共存. urlpatterns String[] 指定一组servlet的url的匹配模式,等价于标签. loadOnStartup int 指定servlet的加载顺序,等价于标签. initParams WebInitParam[] 指定一组初始化参数,等价于标签. asyncSupported boolean 申明servlet是否支持异步操作模式,等价于标签. displayName String servlet的显示名,等价于标签. description String servlet的描述信息,等价于标签. 与传统Servlet相比注解实现 12345678910111213141516171819202122232425262728package annotate;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name=&quot;test2&quot;, value=&quot;/test2&quot; )public class test2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;页面执行了。。。&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 传统的Servlet的配置需要在Web.xml中添加Servlet的映射 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;servlet-class&gt;annotate.test1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;url-pattern&gt;/test1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 二、@WebFilter 用来配置过滤器","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"注解开发","slug":"注解开发","permalink":"http://SlectRxz.github.io/tags/注解开发/"}]},{"title":"MVC+三层架构开发模式","slug":"java/MVC开发模式","date":"2019-01-16T16:00:00.000Z","updated":"2019-03-06T11:49:33.666Z","comments":true,"path":"2019/01/17/java/MVC开发模式/","link":"","permalink":"http://SlectRxz.github.io/2019/01/17/java/MVC开发模式/","excerpt":"Web开发模式","text":"Web开发模式 MVC Model:javabean:封装业务数据，模型 View：jsp：显示数据，视图 Controller:servlet:调度jsp和javabean资源，控制器 三层结构： dao层： 和数据访问相关的操作 service层： 和业务逻辑相关的操作 web层： 和用户直接交互相关的操作（传接参数，跳转页面） MVC+三层架构个人理解： service层(业务逻辑层)，比如说当我们添加用户时需要判断用户的id是否为空，此时service层负责判断后再调用dao层的方法，dao层只负责对数据的增删查改。 servlet负责调用业务逻辑（页面的调度），而不处理业务逻辑。真正处理业务逻辑的是service层。 从servlet-&gt;jsp (页面跳转过程) 123456789101112131415161718 //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;);request.setCharacterEncoding(&quot;utf-8&quot;);//拿到对象 ，通过调用dao中的方法Contact contact=new ContactPerson();List&lt;Person&gt; list = contact.search();////shift+alt+A 区块选择，按一次进入选择模式，再按一次回来/** * ctrl+F 正则替换 ^(.*)$ \\1&quot;; * ^一行表示 * $结束表示 * \\1匹配里面的一行内容 替换为这个&quot;; *///将对象保存在域中request.setAttribute(&quot;contacts&quot;,list);//跳转到显示页面request.getRequestDispatcher(&quot;/listContact.jsp&quot;).forward(request, response); 从jsp-&gt;servlet一般我们用${pageContext.request.contextPath }来获取当前路径/QueryContactServlet?id=${con.id}是页面跳转的同时将id作为参数传递过去 123456789101112131415&lt;!-- 直接用EL表达式从域对象中获取数据--&gt;&lt;c:forEach items=&quot;$&#123;contacts&#125;&quot; var=&quot;con&quot; varStatus=&quot;varsta&quot;&gt; &lt;tr&gt; &lt;th&gt;$&#123;varsta.count&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.name&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.gender&#125; &lt;/th&gt; &lt;th&gt;$&#123;con.email &#125;&lt;/th&gt; &lt;th&gt;$&#123;con.qq&#125;&lt;/th&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/QueryContactServlet?id=$&#123;con.id&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/DeleteContactServlet?id=$&#123;con.id&#125;&quot;&gt;删除&lt;/a&gt; //说明，此处的pageContext.request相当于pageContext.getRequest()方法，其在于先得到request对象，再调用request的方法。 &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 注意：此处设计到EL表达式 语法：${表达式或变量}表达式/变量是从域对象中得到的，也就是说，我们必须先往域对象中存储输出对象的某个成员：${student.name},其中student的对象必须有方法getName() form表单形式：1&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/AddContactServlet&quot; method=&quot;post&quot;&gt; 项目结构：注意：不管是获取数据还是发送数据，都是以对象为基本单位，即JavaBean。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java反射","slug":"java/反射","date":"2019-01-06T16:00:00.000Z","updated":"2019-01-07T07:37:34.823Z","comments":true,"path":"2019/01/07/java/反射/","link":"","permalink":"http://SlectRxz.github.io/2019/01/07/java/反射/","excerpt":"Java反射机制","text":"Java反射机制 Java反射机制一、什么是反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 “程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。Java不是动态语言。但是Java有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的class。 二、理解Java反射要想理解反，必须得从“正”开始理解，一般而言，先有类再去实例化对象。1234567891011package com.wz.reflectdemo;import java.util.Date;//先有类public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date();//再产对象 System.out.println(date); &#125;&#125; 而“反”就是通过对象找到类。在Object类中提供一个方法得到class对象。1public final Class &lt;?&gt;getClass() 注：反射之中的所有泛型都定义为？，返回值为Object 三、Class类对象的实例化java.lang.Class是一个类，它与一般类一样继承Object。这个类是反射操作的源头，即所有的反射都从此类开始进行，下面介绍获取的三种方式。 方式一：调用Object的getClass()方法12345678910package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;?&gt; cls = date.getClass(); System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：这种方式相当于通过实例对象反向得到Class对象。 方式二、使用“类.class”获得123456789101112package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; //Date date = new Date(); Class&lt;?&gt; cls = Date.class; System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：方法一中取得Class对象之前需要实例化，但是直接通过类名.Class没有实例化。 方法三、forName(String className) 注意：注意此字符串必须是真实路径，就是带包名的类路径，包名.类名1public static Class&lt;?&gt;forName(String className) throws ClassNotFoundException 代码如下：1234567891011package com.wz.reflectdemo;//import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 注意：三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 四、反射实例化对象通过前面的步骤得到了Class对象，接下来利用反射实例化得到对象，得到方法和属性。 1、获取实例对象1public T newInstance() throws InstantiationException,IllegalAccessException eg:123456789101112131415161718192021222324252627package com.wz.reflectdemo;class Book&#123; public Book()&#123; System.out.println(&quot;Book类的无参构造方法&quot;); &#125; @Override public String toString() &#123; return &quot;This a book !&quot;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book); &#125;&#125; 运行结果：12Book类的无参构造方法This a book ! 注意：newInstance()只能调用默认无参构造方法。当我们所实例化的类中没有提供无参的构造方法时，会报错。此时我们需要获取有参的构造方法。 在Class类中，提供了方法来获取构造函数：（1）获取所有的构造函数：1public Constructor&lt;?&gt;[] getConstructors() throws SecurityException （2）获取指定参数顺序的构造函数：1public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityExceptio 说明：以上两个类都返回“java.lang.reflect.Constructor”类的对象。该类中提供明确传递有参构造的方法：12public T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException 实例：1234567891011121314151617181920package com.wz.reflectdemo;import java.lang.reflect.Constructor;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); /*Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book);*/ Constructor&lt;?&gt; con = cls.getConstructor(String.class,double.class); Object obj = con.newInstance(&quot;Java开发&quot;,79.8);//实例化对象 System.out.println(obj); &#125;&#125; 执行结果：1图书名称：Java开发 ,价格：79.8 2、调用方法和属性在Class类中获取方法有以下方式： （1）取得一个类中的全部方法1public Method[] getMethods() throws SecurityException （2）得到指定方法12public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throwsNoSuchMethodException, SecurityException 以上方法返回都是“java.lang.reflect.Method”对象，在这个类中有一个调用方法：12public Object invoke(Object obj, Object... args) throws IllegalAccessException,IllegalArgumentException, InvocationTargetException eg:12345678910111213141516171819package com.wz.reflectdemo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance(); Method setMet = cls.getMethod(&quot;setTitle&quot;, String.class); setMet.invoke(obj, &quot;Java开发&quot;);//等价于Book类的setTitle(&quot;Java开发&quot;) Method getMet = cls.getMethod(&quot;getTitle&quot;); System.out.println(getMet.invoke(obj));//等价于Book类的getTitle() &#125;&#125; 输出结果：1java 开发","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java注解","slug":"java/注解","date":"2019-01-04T16:00:00.000Z","updated":"2019-03-08T02:18:48.571Z","comments":true,"path":"2019/01/05/java/注解/","link":"","permalink":"http://SlectRxz.github.io/2019/01/05/java/注解/","excerpt":"有关java注解","text":"有关java注解 Java注解 出处：https://blog.csdn.net/briblue/article/details/73824058 注解的定义： 官方定义：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的 （看不懂） 注意：=注解要求：在开发中地位，类似于dom4j解析XML文件，XML文件的解析程序员不会去解析，配置XML文件。 容易理解的： 注解就是一个标签，标签上有着各种各样的含义，不同的标签可以贴在不同的代码上 自定义注解格式： 注解通过 @interface 关键字进行定义。 12345Public @interface TestAnnotation&#123;&#125;@TestAnnotationPublic void Test()&#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，它的目的是给普通的注解进行说明的，说明某一注解的存活期、范围等等。 格式: public @interface 注解名称{ public 属性类型 属性名称1(); public 属性类型 属性名称2() default 默认值; }支持类型：基础类型，String，annotation，枚举类型，字节码class类型注意：不支持自定义类型元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable @RetentionRetention的英文为保留期的意思，当其应用到某一个注解上时，表达了这个注解的存活时间它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 可以理解为当使用@Retention解释标签时，指定了该标签的生命周期。123@Retention(Retention.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码指定了标签TestAnotation可在程序运行的时候获取到。 @Documented作用：将注解的元素包含到JavaDoc当中。 @Target作用：指定了注解运用在何处。可以理解为当被@Target注解，就被限定了应用场景。类比标签，原本标签可以贴到任何地方，当我限制后，只能贴到指定的地方。@Target有下面的取值： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。这样引用网上的例子理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。老子的孙子长大了，自然也是富豪。这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理(注：好的产品经理一般都是懂技术的，更容易沟通)。123456789101112@interface Persons&#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;coder&quot;)@person(role=&quot;PM&quot;)public class CM&#123;&#125; 注意上面的代码，Repeatable注解了Person，而@Repeatable后面括号里的类相当于一个容器注解 容器注解就是用来存放其他注解的地方，本身也是一个注解123@interface Persons&#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 CM 贴上，相当于同时给他贴了程序员、产品经理的标签。我们可能对于 @Person(role=”PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"JSP基础语法","slug":"java基础/JSP基础(一)","date":"2018-11-12T02:01:44.000Z","updated":"2018-12-03T08:37:26.813Z","comments":true,"path":"2018/11/12/java基础/JSP基础(一)/","link":"","permalink":"http://SlectRxz.github.io/2018/11/12/java基础/JSP基础(一)/","excerpt":"JSP基础语法","text":"JSP基础语法 ##Jsp基础## 4.1 Jsp引入 Servlet的作用： 用java语言开发动态资源的技术！！！Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！ Jsp就是servlet！！！ 4.2 Jsp的特点 1）jsp的运行必须交给tomcat服务器！！！！ tomcat的work目录： tomcat服务器存放jsp运行时的临时文件 2）jsp页面既可以写html代码，也可以写java代码。 （html页面不能写java代码 。而jsp页面可以写java代码） 4.3 体验jsp页面作用 需求：显示当前时间到浏览器上 可以把jsp页面当做html页面在tomcat中访问！！！ 4.4 Jsp的执行过程 问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 1）访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件 (01.hello.jsp-&gt; _01_hello_jsp.java) （翻译） 2）tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） 3）tomcat服务器构造_01_hello_jsp类对象 4）tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 1.第一次访问jsp：2.走（1）（2）（3）（4）3.第n次访问jsp：4.走（4）注意： 1）jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译（2）的过程 4.5 疑问 问题： 为什么Jsp就是servlet！！！ jsp翻译的java文件： public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage { 结论： Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 1）构造方法（第1次访问） 2）init方法（第1次访问） 3）service方法 4）destroy方法 Jsp的生命周期 1）翻译： jsp-&gt;java文件 2）编译： java文件-&gt;class文件（servlet程序） 3）构造方法（第1次访问） 4）init方法（第1次访问）：_jspInit() 5）service方法：_jspService() 6）destroy方法：_jspDestroy() ##Jsp语法## 5.1 Jsp模板 jsp页面中的html代码就是jsp的模板 5.2 Jsp表达式 语法：&lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式计算的结果 注意： 1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容 2）表达式后面不需要带分号结束。 5.3 Jsp的脚本 语法：&lt;%java代码 %&gt; 作用： 执行java代码 注意： 原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 就是在service方法中执行了一段java代码 5.4 Jsp的声明 语法：&lt;%! 变量或方法 %&gt; 作用： 声明jsp的变量或方法 注意: 1）变量翻译成成员变量，方法翻译成成员方法。 5.5 Jsp的注释 语法： &lt;%– jsp注释 –%&gt; 注意; 1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 ##Jsp的三大指令## 6.1 include指令 作用： 在当前页面用于包含其他页面 语法： &lt;%@include file=”common/header.jsp”%&gt; 注意： 1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一 个java源文件，再编译运行！！，这种包含叫静态包含（源码包含） 2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、 body） 6.2 page指令 作用： 告诉tomcat服务器如何翻译jsp文件 &lt;%@ page language=”java” –告诉服务器使用什么动态语言来翻译jsp文件 import=”java.util.*” –告诉服务器java文件使用什么包 导入包，多个包之间用逗号分割 pageEncoding=”utf-8” –告诉服务器使用什么编码翻译jsp文件（成java文件） contentType=”text/html; charset=utf-8” 服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage=”error.jsp” isErrorPage=”false” buffer=”8kb” session=”true” isELIgnored=”false” %&gt; 6.3 taglib指令 总结： 1）编码实战： 1.1 servlet应用 1.2 初步了解软件开发流程 2）Jsp基础 2.1 Jsp的执行原理（翻译-》编译-》servlet的生命周期） 2.2 语法（jsp表达式，jsp脚本） 2.3 指令 include指令 page指令","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"背景音乐添加步骤","slug":"addmusic","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-12T03:15:28.400Z","comments":true,"path":"2018/11/04/addmusic/","link":"","permalink":"http://SlectRxz.github.io/2018/11/04/addmusic/","excerpt":"关于博客如何添加背景音乐","text":"关于博客如何添加背景音乐 1、打开网易云音乐首页，然后搜索你要添加的背景音乐 2、搜索到歌曲点击生成外链播放器，进去下一个界面3、打开主题下的_partial文件夹下的left-col.ejs文件，选择iframe插件，赋值HTML代码到&lt;div&gt;&lt;/div&gt;中 注意：因为我想把这个播放器放在博客页面的左侧栏里，所以就把以上代码复制到主题文件夹下实现左侧栏的那个模板文件里，也就是left-col.ejs文件，（需要值得注意的是，因为所使用的主题不同，可能文件也就不一样，但是大致原理就如刚才我所提到的：想放在哪个区域，就把代码复制到实现那块区域的模板文件里）。 我的主题目录是YourBlogName\\themes\\smackdown\\layout\\_partial\\left-col.ejs。123&lt;div style=&quot;position:absolute;bottom:100px;left:15px;width:60%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=250 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=543681750&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 注意： width与height调节播放页的大小","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://SlectRxz.github.io/categories/环境搭建/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"算法","slug":"first","date":"2018-10-14T13:58:57.005Z","updated":"2018-10-16T12:22:42.879Z","comments":true,"path":"2018/10/14/first/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/first/","excerpt":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。","text":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 Code block123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#define MAX 20#define max(a,b) a&gt;b?a:busing namespace std;int D[MAX][MAX];int fill(int n,int v[],int b[],int c)&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=c;j++) &#123; If( j&lt;v[ I ] ) D[i][j]=D[i-1][j]; else D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);//解释：当背包的容量慢慢增加，此时大于这个物品v[i]，那么，我们需要判断//放物品 与 不放物品的价值哪个高。。。。。 &#125; return 1;&#125;int main()&#123; int n,v[MAX],b[MAX],c; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; cin&gt;&gt;c; fill(n,v,b,c); cout&lt;&lt;D[n][c];&#125;","categories":[{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"http://SlectRxz.github.io/categories/0-1背包问题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://SlectRxz.github.io/tags/算法/"}]},{"title":"My first blog","slug":"hello-world","date":"2018-10-14T07:40:00.425Z","updated":"2018-11-08T09:07:05.337Z","comments":true,"path":"2018/10/14/hello-world/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/hello-world/","excerpt":"博客搭建记录","text":"博客搭建记录 找了很多教程，也看了一些视频，最后终于将其搭建好了，第一次写，有误请指正。 ####搭建环境准备： 安装Git：Git下载包64位. 下载node.js node.js下载地址 安装Hexo 利用npm命令即可安装。单击鼠标i右键，选着Git Bash","categories":[{"name":"搭建说明","slug":"搭建说明","permalink":"http://SlectRxz.github.io/categories/搭建说明/"}],"tags":[{"name":"blog记录","slug":"blog记录","permalink":"http://SlectRxz.github.io/tags/blog记录/"}]},{"title":"Linux基础（四）","slug":"Linux基础（四）","date":"2017-05-12T02:01:44.000Z","updated":"2018-10-16T11:40:21.032Z","comments":true,"path":"2017/05/12/Linux基础（四）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/12/Linux基础（四）/","excerpt":"Linux网络配置与使用","text":"Linux网络配置与使用 4、虚拟机linux上网问题4.1、VMware中虚拟机网络的三种设置第一种：桥接（bridged）第二种：NAT第三种：Host only 。该模式下仅主机可以上网，虚拟机不能上网。 4.2、虚拟机上网方式1：NAT方式设置步骤：第一步：在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择NAT模式第二步： vi /etc/network/interfaces，打开该文件，将内容编辑成为： auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 第三步：执行/etc/init.d/networking restart重启网卡 4.3、虚拟机上网方式2：桥接方式第一步：桥接。在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择桥接模式。第二步：桥接到可以上网的网卡。在菜单栏 编辑 -&gt; 虚拟网络编辑器，选择桥接到自己Windows中可以上网的网卡上（一般就是Wifi网络或者有线网络）第三步：设置dhcp并重启网卡。 vi /etc/network/interfaces，打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 保存退出。然后命令行执行/etc/init.d/networking restart重启网卡 4.4、总结第一，NAT方式设置上网比较简单，但是不能用在嵌入式开发中。第二，桥接方式设置上网较繁琐，但是在嵌入式开发中比较有用。 使用技巧：1、使用shell的Tab键自动补全Tab在linux命令行输入中可以自动完成。在linux 命令行中使用Tab键会极大提高输入效率2、使用shell的历史记录shell会记录用户执行命令的历史记录，而我们一般使用命令都会在短时间内集中反复使用因此当你需要使用一条刚才还使用过的命令时，不需再次花时间输入，只要按下键盘上下箭头按键，就可实现上下翻页，翻出刚才用过的命令，直接回车执行。就好像电话机的通话记录和快速回拨一样。3、linux命令行中一些符号的含义： . 代表当前目录 .. 代表上一层目录，当前目录的父目录 - 代表前一个目录，我刚才从哪个目录cd过来 ~ 代表当前用户的宿主目录 / 代表根目录 $ 普通用户的命令行提示符 # root用户的命令行提示符 * 万能匹配符 宿主目录：所谓宿主目录，就是操作系统为当前用户所设计的用来存放文件、工作的默认目录。如Windows中的“我的文档”目录，就是Windows为我们设计的宿主目录。Linux中每个用户都有自己的宿主目录，这个目录对于普通用户来说，在/home/username/，而对于root用户来说，在/root。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（三）","slug":"Linux基础（三）","date":"2017-05-11T02:01:44.000Z","updated":"2018-10-16T11:40:22.000Z","comments":true,"path":"2017/05/11/Linux基础（三）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/11/Linux基础（三）/","excerpt":"vi编辑器的使用","text":"vi编辑器的使用 3、编辑器vi的使用（vi和vim的联系）什么是编辑器？编辑器就是一款软件，它的主要作用就是用来编辑。譬如编写文件，编写代码。Windows中的常用编辑器，如自带的notepad。比较好用的notepad++，UltraEditor，SlickEditorLinux中常用编辑器，自带的最古老的vi。比较好用的vim，gedit。注：vi和vim的关系：vim是vi的升级版，推荐使用vim。我们在后面提到vi时，其实都是指vim。 3.1、vi基础使用使用vi来打开/创建一个文件，vi pathname vi的两种模式：命令模式：当vi打开时默认为命令模式，要转入输入模式，需要按a或者i键。在命令模式下，此时键盘上输入的所有东西都被vi当作命令来对待。在命令模式下，最好不要乱输入。此时应该输入相应的命令，来让vi做相应的事。输入模式：输入模式用来向文件输入内容。可以从命令模式中按a或者i进入输入模式。进入输入模式后，就可以随意按键盘进行输入了。输入完成后如果要保存，要先退回到命令模式（因为保存也是一种命令）。在输入模式下按ESC键退回到命令模式。注：注意看屏幕左下角，当命令模式时无提示信息或者提示文件名等信息，等处于输入模式时，提示 – INSERT –在命令模式下如何保存：:wq 保存并且退出:w 只保存不推出:q 不保存退出 进来看了一下没改退出:q! 不保存强制退出:wq! 保存并强制退出 3.2、vi的高级使用 查找在命令模式下，输入/xxx，就可以查找到xxx 快速切换行在命令模式下，输入:num，就可以快速切换到num行 设置显示行号在命令模式下，输入:set nu，就可以显示行号 注：设置不显示行号，命令模式输入:set nonu设置永久显示行号，需要修改vi的配置文件。打开vi的配置文件~/.vimrc，在其中输入set nu即可。 行删除命令模式下，先将光标移动到要删除的行，然后输入dd如果要删除连续多行，譬如要删除连续的3行，使用3dd 行复制粘贴复制：命令模式下，nyy粘贴：命令模式下，p细节，复制时要把光标放在多行的第一行，粘贴时实际粘贴到当前光标所在行的下一行。 3.3、linux中权限表示&amp;管理3.3.1、普通用户与特权用户 su命令切换用户Windows中有普通用户和特权用户，特权用户是Administrator，普通用户可以有很多个。特权用户是系统的管理员，对系统内所有文件具有操作权限。每个普通用户只能处理自己的文件，不能访问其他用户的文件，更不能随意处理操作系统的文件。Linux中也有普通用户和特权用户的区别。特权用户就是root用户。普通用户权限受到限制，譬如说普通用户不能cd /root，普通用户不能使用apt-get install 来装软件。 可以使用su 用户名来在不同用户间切换。譬如要从普通用户切换到root，可以su root，然后输入root的密码即可转入root用户。从root要切换到普通用户gec，则su gec即可。 3.3.2、rwx与权限表示ls -l显示详细信息drwxr-xr-x 10个字符，第一个表示文件类型。剩下的9个分成3组，表示文件权限。前三个表示此文件的属主对文件的权限中间三个表示此文件属主所在的组对文件的权限最后三个表示其他用户对文件的权限rwx怎么解析：r代表可读，w代表可写，x代表可执行rwx：可读，可写，可执行r-x: 可读，不可写，可执行r–: 可读，不可写，不可执行 3.3.3、使用sudo暂时获取root权限这是ubuntu的一个特点，在ubuntu中可以使用sudo命令让普通用户暂时获取root用户的权限，而不必进行用户切换。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（二）","slug":"Linux基础（二）","date":"2017-05-08T02:01:44.000Z","updated":"2018-10-16T11:40:15.881Z","comments":true,"path":"2017/05/08/Linux基础（二）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/08/Linux基础（二）/","excerpt":"关于Linux的基本介绍以及简单命令的概述","text":"关于Linux的基本介绍以及简单命令的概述 2、linux基础知识与技能2.1、linux内核、发行版linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。ubuntu、redhat就是linux的不同的发行版。 2.2、GUI（图形用户界面）和cmdline（命令行）GUI：grahics user interface，图形用户界面。cmdline：command line，命令行。人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。但是，在linux中我们常用命令行，在Windows中常用GUI 2.3、linux常用命令：(1) ls（list，列表）作用：使用列表把当前文件夹下所有文件显示出来 ls -a 显示所有文件，包括隐藏文件 ls -l 以详细信息显示 ls -a -l ls -l -a ls -la ls -al 四种方式都是可以的 ls -al ~ ：列出自己主文件夹下的所有隐藏文件与相关的文件属性 (2) cd（change directory，更改目录）作用：用来切换目录涉及到相对路径和绝对路径cd .. ..代表上一层目录 .代表当前目录 (3) pwd（print work directory，打印工作目录）作用：打印出当前的绝对路径 (4) mkdir（make directory，创建文件夹）作用：创建空文件夹 mkdir -p 级联创建文件夹(5) mv（move，移动）作用：在目录间移动文件，重命名文件 mv 源文件pathname 目的文件pathname (6) touch作用：创建空文件 touch pathname (7) cp（copy，复制）作用：复制文件或文件夹 cp 源文件pathname 目标文件pathname cp -r 用来复制文件夹 cp -f 强制复制实际操作时，一般都是cp -f复制文件，cp -rf复制文件夹 (8) rm（remove，去除，删除）作用：用来删除文件，文件夹 rm 文件pathname rm -r 文件夹pathname (9) cat作用：直接在命令行下显示文件内容 也可以用来向文件输入，暂时不管 (10)rmdir（remove directory，删除文件夹）作用：删除空文件夹rmdir和rm -r的区别：rmdir只能删除空文件夹，而rm -r可以删除空文件夹和非空文件夹 (11) ln（link，连接文件）基础：windows中快捷方式，实际上快捷方式和它指向的文件是独立的两个文件，两个都占硬盘空间，只不过用户访问快捷方式时，其效果等同于访问指向的文件。 linux中有两种连接文件：一种叫软连接（符号连接），等同于windows中快捷方式一种叫硬连接创建软连接文件： ln -s 源文件名 符号连接文件名举例：ln -s src.c，linker.c， linker.c就是src.c的一个符号连接文件 硬连接：ln 源文件名 连接文件名硬连接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬连接存在，这个文件就不会被真正删除。只有等所有的连接文件都删除掉了，这个文件才会被真正从硬盘上删除。 基础知识：1、ls -l显示的详细信息中：-rw-r–r–drwxr-xr-x一共10个字符，第一个字符表示文件类型，后面9个字符表示文件权限。文件类型： 表示普通文件。普通文件指文本文件和二进制 文件，如a.c 1.txt a.out都是普通文件d 表示文件夹，d是directory的缩写l 表示符号连接文件，后面会用-&gt;打印出它指向的文件s 表示socket文件p 表示管道文件 pipe","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（一）","slug":"Linux基础（一）","date":"2017-05-05T02:01:44.000Z","updated":"2018-10-16T11:40:10.897Z","comments":true,"path":"2017/05/05/Linux基础（一）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/05/Linux基础（一）/","excerpt":"操作系统、相对路径与绝对路径的简介","text":"操作系统、相对路径与绝对路径的简介 1、操作系统基础概念1.1、Windows与linux的关系当前主流的操作系统：windows、、android、iOS、symbian、linux/unix Windows：傻瓜式、好学习、工资低Linux：linux认为每一个用户都是专业人士，操作麻烦，学习比较难，免费的、开源的，linux性能好，可移植性好，好的设计理念Android：移动操作系统，android基于linuxiOS：很优秀，创造性，走钢丝 嵌入式操作系统：linux + WinCE当前：消费电子Android，工业linux 1.2、多机开发：双系统与虚拟机开发嵌入式程序，需要linux环境。但是因为：windows中有许多很好用的软件，如notepad++、SourceInsight，所以也需要windows。 第一种：双系统 不方便第二种：虚拟机 方便，损失性能，与 真机微小差异第三种：两台电脑：不方便 现实中：个人开发者：虚拟机大公司：服务器+客户端 1.3、搭建开发环境涉及到两个东西：虚拟机软件+linux系统虚拟机软件：就是一个单纯的在windows中运行的软件，跟word、360没有本质区别。现在主流的虚拟机软件有VMWare和VirtualBox虚拟机软件在windows系统中运行，运行后它会模拟出来一个电脑，所以叫虚拟机。然后我们可以在该虚拟机中安装别的操作系统。当前，可以先使用事先安装好的aston_ubuntu，密码是root。自己上网搜索安装教程。 1.4、隐藏文件与非隐藏文件Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件和文件夹。Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls） 1.5、相对路径与绝对路径什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。举例：D:\\winshare\\enum.c全路径pathnameD:\\winshare路径 path`enum.c文件名 name 绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\\），linux中从根目录/开始相对路径：指明路径的时候，是从当前所在的位置开始的。 举例：D:\\我的文档\\123\\123.txtD:\\我的文档\\abc\\abc.txt当前在123.txt，但是要去abc.txt方式1：采用绝对路径。D:\\我的文档\\abc\\abc.txt方式2：采用相对路径。../abc/abc.txt从当前路径开始，往上走一层，再往下走一层（abc）就到了 测试：/abc/123/def.txt 是linux绝对路径abc/123/def.txt 不是linux绝对路径F:\\abc\\123\\def.txt 是windows绝对路径abc\\123\\def.txt 不是windows绝对路径","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]}]}