{"meta":{"title":"荣先森","subtitle":null,"description":null,"author":"Rong","url":"http://SlectRxz.github.io"},"pages":[],"posts":[{"title":"MVC+三层架构开发模式","slug":"java/MVC开发模式","date":"2019-01-16T16:00:00.000Z","updated":"2019-01-17T08:42:48.269Z","comments":true,"path":"2019/01/17/java/MVC开发模式/","link":"","permalink":"http://SlectRxz.github.io/2019/01/17/java/MVC开发模式/","excerpt":"Web开发模式","text":"Web开发模式 MVC Model:javabean:封装业务数据，模型 View：jsp：显示数据，视图 Controller:servlet:调度jsp和javabean资源，控制器 三层结构： dao层： 和数据访问相关的操作 service层： 和业务逻辑相关的操作 web层： 和用户直接交互相关的操作（传接参数，跳转页面） MVC+三层架构个人理解： service层(业务逻辑层)，比如说当我们添加用户时需要判断用户的id是否为空，此时service层负责判断后再调用dao层的方法，dao层只负责对数据的增删查改。 servlet负责调用业务逻辑（页面的调度），而不处理业务逻辑。真正处理业务逻辑的是service层。 从servlet-&gt;jsp (页面跳转过程) 123456789101112131415161718 //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;);request.setCharacterEncoding(&quot;utf-8&quot;);//拿到对象 ，通过调用dao中的方法Contact contact=new ContactPerson();List&lt;Person&gt; list = contact.search();////shift+alt+A 区块选择，按一次进入选择模式，再按一次回来/** * ctrl+F 正则替换 ^(.*)$ \\1&quot;; * ^一行表示 * $结束表示 * \\1匹配里面的一行内容 替换为这个&quot;; *///将对象保存在域中request.setAttribute(&quot;contacts&quot;,list);//跳转到显示页面request.getRequestDispatcher(&quot;/listContact.jsp&quot;).forward(request, response); 从jsp-&gt;servlet一般我们用${pageContext.request.contextPath }来获取当前路径/QueryContactServlet?id=${con.id}是页面跳转的同时将id作为参数传递过去 1234567891011121314&lt;!-- 直接用EL表达式从域对象中获取数据--&gt;&lt;c:forEach items=&quot;$&#123;contacts&#125;&quot; var=&quot;con&quot; varStatus=&quot;varsta&quot;&gt; &lt;tr&gt; &lt;th&gt;$&#123;varsta.count&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.name&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.gender&#125; &lt;/th&gt; &lt;th&gt;$&#123;con.email &#125;&lt;/th&gt; &lt;th&gt;$&#123;con.qq&#125;&lt;/th&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/QueryContactServlet?id=$&#123;con.id&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/DeleteContactServlet?id=$&#123;con.id&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; form表单形式：1&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/AddContactServlet&quot; method=&quot;post&quot;&gt; 项目结构：注意：不管是获取数据还是发送数据，都是以对象为基本单位，即JavaBean。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java反射","slug":"java/反射","date":"2019-01-06T16:00:00.000Z","updated":"2019-01-07T07:37:34.823Z","comments":true,"path":"2019/01/07/java/反射/","link":"","permalink":"http://SlectRxz.github.io/2019/01/07/java/反射/","excerpt":"Java反射机制","text":"Java反射机制 Java反射机制一、什么是反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 “程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。Java不是动态语言。但是Java有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的class。 二、理解Java反射要想理解反，必须得从“正”开始理解，一般而言，先有类再去实例化对象。1234567891011package com.wz.reflectdemo;import java.util.Date;//先有类public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date();//再产对象 System.out.println(date); &#125;&#125; 而“反”就是通过对象找到类。在Object类中提供一个方法得到class对象。1public final Class &lt;?&gt;getClass() 注：反射之中的所有泛型都定义为？，返回值为Object 三、Class类对象的实例化java.lang.Class是一个类，它与一般类一样继承Object。这个类是反射操作的源头，即所有的反射都从此类开始进行，下面介绍获取的三种方式。 方式一：调用Object的getClass()方法12345678910package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;?&gt; cls = date.getClass(); System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：这种方式相当于通过实例对象反向得到Class对象。 方式二、使用“类.class”获得123456789101112package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; //Date date = new Date(); Class&lt;?&gt; cls = Date.class; System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：方法一中取得Class对象之前需要实例化，但是直接通过类名.Class没有实例化。 方法三、forName(String className) 注意：注意此字符串必须是真实路径，就是带包名的类路径，包名.类名1public static Class&lt;?&gt;forName(String className) throws ClassNotFoundException 代码如下：1234567891011package com.wz.reflectdemo;//import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 注意：三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 四、反射实例化对象通过前面的步骤得到了Class对象，接下来利用反射实例化得到对象，得到方法和属性。 1、获取实例对象1public T newInstance() throws InstantiationException,IllegalAccessException eg:123456789101112131415161718192021222324252627package com.wz.reflectdemo;class Book&#123; public Book()&#123; System.out.println(&quot;Book类的无参构造方法&quot;); &#125; @Override public String toString() &#123; return &quot;This a book !&quot;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book); &#125;&#125; 运行结果：12Book类的无参构造方法This a book ! 注意：newInstance()只能调用默认无参构造方法。当我们所实例化的类中没有提供无参的构造方法时，会报错。此时我们需要获取有参的构造方法。 在Class类中，提供了方法来获取构造函数：（1）获取所有的构造函数：1public Constructor&lt;?&gt;[] getConstructors() throws SecurityException （2）获取指定参数顺序的构造函数：1public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityExceptio 说明：以上两个类都返回“java.lang.reflect.Constructor”类的对象。该类中提供明确传递有参构造的方法：12public T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException 实例：1234567891011121314151617181920package com.wz.reflectdemo;import java.lang.reflect.Constructor;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); /*Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book);*/ Constructor&lt;?&gt; con = cls.getConstructor(String.class,double.class); Object obj = con.newInstance(&quot;Java开发&quot;,79.8);//实例化对象 System.out.println(obj); &#125;&#125; 执行结果：1图书名称：Java开发 ,价格：79.8 2、调用方法和属性在Class类中获取方法有以下方式： （1）取得一个类中的全部方法1public Method[] getMethods() throws SecurityException （2）得到指定方法12public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throwsNoSuchMethodException, SecurityException 以上方法返回都是“java.lang.reflect.Method”对象，在这个类中有一个调用方法：12public Object invoke(Object obj, Object... args) throws IllegalAccessException,IllegalArgumentException, InvocationTargetException eg:12345678910111213141516171819package com.wz.reflectdemo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance(); Method setMet = cls.getMethod(&quot;setTitle&quot;, String.class); setMet.invoke(obj, &quot;Java开发&quot;);//等价于Book类的setTitle(&quot;Java开发&quot;) Method getMet = cls.getMethod(&quot;getTitle&quot;); System.out.println(getMet.invoke(obj));//等价于Book类的getTitle() &#125;&#125; 输出结果：1java 开发","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java注解","slug":"java/注解","date":"2019-01-04T16:00:00.000Z","updated":"2019-01-05T12:37:55.948Z","comments":true,"path":"2019/01/05/java/注解/","link":"","permalink":"http://SlectRxz.github.io/2019/01/05/java/注解/","excerpt":"有关java注解","text":"有关java注解 Java注解 出处：https://blog.csdn.net/briblue/article/details/73824058 注解的定义： 官方定义：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的 （看不懂） 容易理解的：注解就是一个标签，标签上有着各种各样的含义，不同的标签可以贴在不同的代码上 自定义注解格式： 注解通过 @interface 关键字进行定义。 12345Public @interface TestAnnotation&#123;&#125;@TestAnnotationPublic void Test()&#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，它的目的是给普通的注解进行说明的，说明某一注解的存活期、范围等等。元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable @RetentionRetention的英文为保留期的意思，当其应用到某一个注解上时，表达了这个注解的存活时间它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 可以理解为当使用@Retention解释标签时，指定了该标签的生命周期。123@Retention(Retention.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码指定了标签TestAnotation可在程序运行的时候获取到。 @Documented作用：将注解的元素包含到JavaDoc当中。 @Target作用：指定了注解运用在何处。可以理解为当被@Target注解，就被限定了应用场景。类比标签，原本标签可以贴到任何地方，当我限制后，只能贴到指定的地方。@Target有下面的取值： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。这样引用网上的例子理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。老子的孙子长大了，自然也是富豪。这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理(注：好的产品经理一般都是懂技术的，更容易沟通)。123456789101112@interface Persons&#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;coder&quot;)@person(role=&quot;PM&quot;)public class CM&#123;&#125; 注意上面的代码，Repeatable注解了Person，而@Repeatable后面括号里的类相当于一个容器注解 容器注解就是用来存放其他注解的地方，本身也是一个注解123@interface Persons&#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 CM 贴上，相当于同时给他贴了程序员、产品经理的标签。我们可能对于 @Person(role=”PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"JSP基础语法","slug":"java/JSP基础(一)","date":"2018-11-12T02:01:44.000Z","updated":"2018-12-03T08:37:26.813Z","comments":true,"path":"2018/11/12/java/JSP基础(一)/","link":"","permalink":"http://SlectRxz.github.io/2018/11/12/java/JSP基础(一)/","excerpt":"JSP基础语法","text":"JSP基础语法 ##Jsp基础## 4.1 Jsp引入 Servlet的作用： 用java语言开发动态资源的技术！！！Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！ Jsp就是servlet！！！ 4.2 Jsp的特点 1）jsp的运行必须交给tomcat服务器！！！！ tomcat的work目录： tomcat服务器存放jsp运行时的临时文件 2）jsp页面既可以写html代码，也可以写java代码。 （html页面不能写java代码 。而jsp页面可以写java代码） 4.3 体验jsp页面作用 需求：显示当前时间到浏览器上 可以把jsp页面当做html页面在tomcat中访问！！！ 4.4 Jsp的执行过程 问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 1）访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件 (01.hello.jsp-&gt; _01_hello_jsp.java) （翻译） 2）tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） 3）tomcat服务器构造_01_hello_jsp类对象 4）tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 1.第一次访问jsp：2.走（1）（2）（3）（4）3.第n次访问jsp：4.走（4）注意： 1）jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译（2）的过程 4.5 疑问 问题： 为什么Jsp就是servlet！！！ jsp翻译的java文件： public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage { 结论： Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 1）构造方法（第1次访问） 2）init方法（第1次访问） 3）service方法 4）destroy方法 Jsp的生命周期 1）翻译： jsp-&gt;java文件 2）编译： java文件-&gt;class文件（servlet程序） 3）构造方法（第1次访问） 4）init方法（第1次访问）：_jspInit() 5）service方法：_jspService() 6）destroy方法：_jspDestroy() ##Jsp语法## 5.1 Jsp模板 jsp页面中的html代码就是jsp的模板 5.2 Jsp表达式 语法：&lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式计算的结果 注意： 1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容 2）表达式后面不需要带分号结束。 5.3 Jsp的脚本 语法：&lt;%java代码 %&gt; 作用： 执行java代码 注意： 原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 就是在service方法中执行了一段java代码 5.4 Jsp的声明 语法：&lt;%! 变量或方法 %&gt; 作用： 声明jsp的变量或方法 注意: 1）变量翻译成成员变量，方法翻译成成员方法。 5.5 Jsp的注释 语法： &lt;%– jsp注释 –%&gt; 注意; 1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 ##Jsp的三大指令## 6.1 include指令 作用： 在当前页面用于包含其他页面 语法： &lt;%@include file=”common/header.jsp”%&gt; 注意： 1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一 个java源文件，再编译运行！！，这种包含叫静态包含（源码包含） 2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、 body） 6.2 page指令 作用： 告诉tomcat服务器如何翻译jsp文件 &lt;%@ page language=”java” –告诉服务器使用什么动态语言来翻译jsp文件 import=”java.util.*” –告诉服务器java文件使用什么包 导入包，多个包之间用逗号分割 pageEncoding=”utf-8” –告诉服务器使用什么编码翻译jsp文件（成java文件） contentType=”text/html; charset=utf-8” 服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage=”error.jsp” isErrorPage=”false” buffer=”8kb” session=”true” isELIgnored=”false” %&gt; 6.3 taglib指令 总结： 1）编码实战： 1.1 servlet应用 1.2 初步了解软件开发流程 2）Jsp基础 2.1 Jsp的执行原理（翻译-》编译-》servlet的生命周期） 2.2 语法（jsp表达式，jsp脚本） 2.3 指令 include指令 page指令","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"背景音乐添加步骤","slug":"addmusic","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-12T03:15:28.400Z","comments":true,"path":"2018/11/04/addmusic/","link":"","permalink":"http://SlectRxz.github.io/2018/11/04/addmusic/","excerpt":"关于博客如何添加背景音乐","text":"关于博客如何添加背景音乐 1、打开网易云音乐首页，然后搜索你要添加的背景音乐 2、搜索到歌曲点击生成外链播放器，进去下一个界面3、打开主题下的_partial文件夹下的left-col.ejs文件，选择iframe插件，赋值HTML代码到&lt;div&gt;&lt;/div&gt;中 注意：因为我想把这个播放器放在博客页面的左侧栏里，所以就把以上代码复制到主题文件夹下实现左侧栏的那个模板文件里，也就是left-col.ejs文件，（需要值得注意的是，因为所使用的主题不同，可能文件也就不一样，但是大致原理就如刚才我所提到的：想放在哪个区域，就把代码复制到实现那块区域的模板文件里）。 我的主题目录是YourBlogName\\themes\\smackdown\\layout\\_partial\\left-col.ejs。123&lt;div style=&quot;position:absolute;bottom:100px;left:15px;width:60%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=250 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=543681750&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 注意： width与height调节播放页的大小","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://SlectRxz.github.io/categories/环境搭建/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"算法","slug":"first","date":"2018-10-14T13:58:57.005Z","updated":"2018-10-16T12:22:42.879Z","comments":true,"path":"2018/10/14/first/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/first/","excerpt":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。","text":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 Code block123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#define MAX 20#define max(a,b) a&gt;b?a:busing namespace std;int D[MAX][MAX];int fill(int n,int v[],int b[],int c)&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=c;j++) &#123; If( j&lt;v[ I ] ) D[i][j]=D[i-1][j]; else D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);//解释：当背包的容量慢慢增加，此时大于这个物品v[i]，那么，我们需要判断//放物品 与 不放物品的价值哪个高。。。。。 &#125; return 1;&#125;int main()&#123; int n,v[MAX],b[MAX],c; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; cin&gt;&gt;c; fill(n,v,b,c); cout&lt;&lt;D[n][c];&#125;","categories":[{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"http://SlectRxz.github.io/categories/0-1背包问题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://SlectRxz.github.io/tags/算法/"}]},{"title":"My first blog","slug":"hello-world","date":"2018-10-14T07:40:00.425Z","updated":"2018-11-08T09:07:05.337Z","comments":true,"path":"2018/10/14/hello-world/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/hello-world/","excerpt":"博客搭建记录","text":"博客搭建记录 找了很多教程，也看了一些视频，最后终于将其搭建好了，第一次写，有误请指正。 ####搭建环境准备： 安装Git：Git下载包64位. 下载node.js node.js下载地址 安装Hexo 利用npm命令即可安装。单击鼠标i右键，选着Git Bash","categories":[{"name":"搭建说明","slug":"搭建说明","permalink":"http://SlectRxz.github.io/categories/搭建说明/"}],"tags":[{"name":"blog记录","slug":"blog记录","permalink":"http://SlectRxz.github.io/tags/blog记录/"}]},{"title":"Linux基础（四）","slug":"Linux基础（四）","date":"2017-05-12T02:01:44.000Z","updated":"2018-10-16T11:40:21.032Z","comments":true,"path":"2017/05/12/Linux基础（四）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/12/Linux基础（四）/","excerpt":"Linux网络配置与使用","text":"Linux网络配置与使用 4、虚拟机linux上网问题4.1、VMware中虚拟机网络的三种设置第一种：桥接（bridged）第二种：NAT第三种：Host only 。该模式下仅主机可以上网，虚拟机不能上网。 4.2、虚拟机上网方式1：NAT方式设置步骤：第一步：在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择NAT模式第二步： vi /etc/network/interfaces，打开该文件，将内容编辑成为： auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 第三步：执行/etc/init.d/networking restart重启网卡 4.3、虚拟机上网方式2：桥接方式第一步：桥接。在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择桥接模式。第二步：桥接到可以上网的网卡。在菜单栏 编辑 -&gt; 虚拟网络编辑器，选择桥接到自己Windows中可以上网的网卡上（一般就是Wifi网络或者有线网络）第三步：设置dhcp并重启网卡。 vi /etc/network/interfaces，打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 保存退出。然后命令行执行/etc/init.d/networking restart重启网卡 4.4、总结第一，NAT方式设置上网比较简单，但是不能用在嵌入式开发中。第二，桥接方式设置上网较繁琐，但是在嵌入式开发中比较有用。 使用技巧：1、使用shell的Tab键自动补全Tab在linux命令行输入中可以自动完成。在linux 命令行中使用Tab键会极大提高输入效率2、使用shell的历史记录shell会记录用户执行命令的历史记录，而我们一般使用命令都会在短时间内集中反复使用因此当你需要使用一条刚才还使用过的命令时，不需再次花时间输入，只要按下键盘上下箭头按键，就可实现上下翻页，翻出刚才用过的命令，直接回车执行。就好像电话机的通话记录和快速回拨一样。3、linux命令行中一些符号的含义： . 代表当前目录 .. 代表上一层目录，当前目录的父目录 - 代表前一个目录，我刚才从哪个目录cd过来 ~ 代表当前用户的宿主目录 / 代表根目录 $ 普通用户的命令行提示符 # root用户的命令行提示符 * 万能匹配符 宿主目录：所谓宿主目录，就是操作系统为当前用户所设计的用来存放文件、工作的默认目录。如Windows中的“我的文档”目录，就是Windows为我们设计的宿主目录。Linux中每个用户都有自己的宿主目录，这个目录对于普通用户来说，在/home/username/，而对于root用户来说，在/root。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（三）","slug":"Linux基础（三）","date":"2017-05-11T02:01:44.000Z","updated":"2018-10-16T11:40:22.000Z","comments":true,"path":"2017/05/11/Linux基础（三）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/11/Linux基础（三）/","excerpt":"vi编辑器的使用","text":"vi编辑器的使用 3、编辑器vi的使用（vi和vim的联系）什么是编辑器？编辑器就是一款软件，它的主要作用就是用来编辑。譬如编写文件，编写代码。Windows中的常用编辑器，如自带的notepad。比较好用的notepad++，UltraEditor，SlickEditorLinux中常用编辑器，自带的最古老的vi。比较好用的vim，gedit。注：vi和vim的关系：vim是vi的升级版，推荐使用vim。我们在后面提到vi时，其实都是指vim。 3.1、vi基础使用使用vi来打开/创建一个文件，vi pathname vi的两种模式：命令模式：当vi打开时默认为命令模式，要转入输入模式，需要按a或者i键。在命令模式下，此时键盘上输入的所有东西都被vi当作命令来对待。在命令模式下，最好不要乱输入。此时应该输入相应的命令，来让vi做相应的事。输入模式：输入模式用来向文件输入内容。可以从命令模式中按a或者i进入输入模式。进入输入模式后，就可以随意按键盘进行输入了。输入完成后如果要保存，要先退回到命令模式（因为保存也是一种命令）。在输入模式下按ESC键退回到命令模式。注：注意看屏幕左下角，当命令模式时无提示信息或者提示文件名等信息，等处于输入模式时，提示 – INSERT –在命令模式下如何保存：:wq 保存并且退出:w 只保存不推出:q 不保存退出 进来看了一下没改退出:q! 不保存强制退出:wq! 保存并强制退出 3.2、vi的高级使用 查找在命令模式下，输入/xxx，就可以查找到xxx 快速切换行在命令模式下，输入:num，就可以快速切换到num行 设置显示行号在命令模式下，输入:set nu，就可以显示行号 注：设置不显示行号，命令模式输入:set nonu设置永久显示行号，需要修改vi的配置文件。打开vi的配置文件~/.vimrc，在其中输入set nu即可。 行删除命令模式下，先将光标移动到要删除的行，然后输入dd如果要删除连续多行，譬如要删除连续的3行，使用3dd 行复制粘贴复制：命令模式下，nyy粘贴：命令模式下，p细节，复制时要把光标放在多行的第一行，粘贴时实际粘贴到当前光标所在行的下一行。 3.3、linux中权限表示&amp;管理3.3.1、普通用户与特权用户 su命令切换用户Windows中有普通用户和特权用户，特权用户是Administrator，普通用户可以有很多个。特权用户是系统的管理员，对系统内所有文件具有操作权限。每个普通用户只能处理自己的文件，不能访问其他用户的文件，更不能随意处理操作系统的文件。Linux中也有普通用户和特权用户的区别。特权用户就是root用户。普通用户权限受到限制，譬如说普通用户不能cd /root，普通用户不能使用apt-get install 来装软件。 可以使用su 用户名来在不同用户间切换。譬如要从普通用户切换到root，可以su root，然后输入root的密码即可转入root用户。从root要切换到普通用户gec，则su gec即可。 3.3.2、rwx与权限表示ls -l显示详细信息drwxr-xr-x 10个字符，第一个表示文件类型。剩下的9个分成3组，表示文件权限。前三个表示此文件的属主对文件的权限中间三个表示此文件属主所在的组对文件的权限最后三个表示其他用户对文件的权限rwx怎么解析：r代表可读，w代表可写，x代表可执行rwx：可读，可写，可执行r-x: 可读，不可写，可执行r–: 可读，不可写，不可执行 3.3.3、使用sudo暂时获取root权限这是ubuntu的一个特点，在ubuntu中可以使用sudo命令让普通用户暂时获取root用户的权限，而不必进行用户切换。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（二）","slug":"Linux基础（二）","date":"2017-05-08T02:01:44.000Z","updated":"2018-10-16T11:40:15.881Z","comments":true,"path":"2017/05/08/Linux基础（二）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/08/Linux基础（二）/","excerpt":"关于Linux的基本介绍以及简单命令的概述","text":"关于Linux的基本介绍以及简单命令的概述 2、linux基础知识与技能2.1、linux内核、发行版linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。ubuntu、redhat就是linux的不同的发行版。 2.2、GUI（图形用户界面）和cmdline（命令行）GUI：grahics user interface，图形用户界面。cmdline：command line，命令行。人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。但是，在linux中我们常用命令行，在Windows中常用GUI 2.3、linux常用命令：(1) ls（list，列表）作用：使用列表把当前文件夹下所有文件显示出来 ls -a 显示所有文件，包括隐藏文件 ls -l 以详细信息显示 ls -a -l ls -l -a ls -la ls -al 四种方式都是可以的 ls -al ~ ：列出自己主文件夹下的所有隐藏文件与相关的文件属性 (2) cd（change directory，更改目录）作用：用来切换目录涉及到相对路径和绝对路径cd .. ..代表上一层目录 .代表当前目录 (3) pwd（print work directory，打印工作目录）作用：打印出当前的绝对路径 (4) mkdir（make directory，创建文件夹）作用：创建空文件夹 mkdir -p 级联创建文件夹(5) mv（move，移动）作用：在目录间移动文件，重命名文件 mv 源文件pathname 目的文件pathname (6) touch作用：创建空文件 touch pathname (7) cp（copy，复制）作用：复制文件或文件夹 cp 源文件pathname 目标文件pathname cp -r 用来复制文件夹 cp -f 强制复制实际操作时，一般都是cp -f复制文件，cp -rf复制文件夹 (8) rm（remove，去除，删除）作用：用来删除文件，文件夹 rm 文件pathname rm -r 文件夹pathname (9) cat作用：直接在命令行下显示文件内容 也可以用来向文件输入，暂时不管 (10)rmdir（remove directory，删除文件夹）作用：删除空文件夹rmdir和rm -r的区别：rmdir只能删除空文件夹，而rm -r可以删除空文件夹和非空文件夹 (11) ln（link，连接文件）基础：windows中快捷方式，实际上快捷方式和它指向的文件是独立的两个文件，两个都占硬盘空间，只不过用户访问快捷方式时，其效果等同于访问指向的文件。 linux中有两种连接文件：一种叫软连接（符号连接），等同于windows中快捷方式一种叫硬连接创建软连接文件： ln -s 源文件名 符号连接文件名举例：ln -s src.c，linker.c， linker.c就是src.c的一个符号连接文件 硬连接：ln 源文件名 连接文件名硬连接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬连接存在，这个文件就不会被真正删除。只有等所有的连接文件都删除掉了，这个文件才会被真正从硬盘上删除。 基础知识：1、ls -l显示的详细信息中：-rw-r–r–drwxr-xr-x一共10个字符，第一个字符表示文件类型，后面9个字符表示文件权限。文件类型： 表示普通文件。普通文件指文本文件和二进制 文件，如a.c 1.txt a.out都是普通文件d 表示文件夹，d是directory的缩写l 表示符号连接文件，后面会用-&gt;打印出它指向的文件s 表示socket文件p 表示管道文件 pipe","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（一）","slug":"Linux基础（一）","date":"2017-05-05T02:01:44.000Z","updated":"2018-10-16T11:40:10.897Z","comments":true,"path":"2017/05/05/Linux基础（一）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/05/Linux基础（一）/","excerpt":"操作系统、相对路径与绝对路径的简介","text":"操作系统、相对路径与绝对路径的简介 1、操作系统基础概念1.1、Windows与linux的关系当前主流的操作系统：windows、、android、iOS、symbian、linux/unix Windows：傻瓜式、好学习、工资低Linux：linux认为每一个用户都是专业人士，操作麻烦，学习比较难，免费的、开源的，linux性能好，可移植性好，好的设计理念Android：移动操作系统，android基于linuxiOS：很优秀，创造性，走钢丝 嵌入式操作系统：linux + WinCE当前：消费电子Android，工业linux 1.2、多机开发：双系统与虚拟机开发嵌入式程序，需要linux环境。但是因为：windows中有许多很好用的软件，如notepad++、SourceInsight，所以也需要windows。 第一种：双系统 不方便第二种：虚拟机 方便，损失性能，与 真机微小差异第三种：两台电脑：不方便 现实中：个人开发者：虚拟机大公司：服务器+客户端 1.3、搭建开发环境涉及到两个东西：虚拟机软件+linux系统虚拟机软件：就是一个单纯的在windows中运行的软件，跟word、360没有本质区别。现在主流的虚拟机软件有VMWare和VirtualBox虚拟机软件在windows系统中运行，运行后它会模拟出来一个电脑，所以叫虚拟机。然后我们可以在该虚拟机中安装别的操作系统。当前，可以先使用事先安装好的aston_ubuntu，密码是root。自己上网搜索安装教程。 1.4、隐藏文件与非隐藏文件Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件和文件夹。Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls） 1.5、相对路径与绝对路径什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。举例：D:\\winshare\\enum.c全路径pathnameD:\\winshare路径 path`enum.c文件名 name 绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\\），linux中从根目录/开始相对路径：指明路径的时候，是从当前所在的位置开始的。 举例：D:\\我的文档\\123\\123.txtD:\\我的文档\\abc\\abc.txt当前在123.txt，但是要去abc.txt方式1：采用绝对路径。D:\\我的文档\\abc\\abc.txt方式2：采用相对路径。../abc/abc.txt从当前路径开始，往上走一层，再往下走一层（abc）就到了 测试：/abc/123/def.txt 是linux绝对路径abc/123/def.txt 不是linux绝对路径F:\\abc\\123\\def.txt 是windows绝对路径abc\\123\\def.txt 不是windows绝对路径","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]}]}