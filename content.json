{"meta":{"title":"荣先森","subtitle":null,"description":null,"author":"Rong","url":"http://SlectRxz.github.io"},"pages":[{"title":"categories","date":"2018-10-14T03:19:41.000Z","updated":"2018-10-14T03:20:17.064Z","comments":true,"path":"categories/index.html","permalink":"http://SlectRxz.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-14T03:20:38.000Z","updated":"2018-10-14T03:21:15.422Z","comments":true,"path":"tags/index.html","permalink":"http://SlectRxz.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-14T03:21:36.000Z","updated":"2018-10-14T03:21:53.111Z","comments":true,"path":"about/index.html","permalink":"http://SlectRxz.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"这是一个测试页面","slug":"taotao/主题测试","date":"2019-12-19T16:00:00.000Z","updated":"2019-12-20T11:15:47.065Z","comments":true,"path":"2019/12/20/taotao/主题测试/","link":"","permalink":"http://SlectRxz.github.io/2019/12/20/taotao/主题测试/","excerpt":"","text":"1号标题2号标题3号标题4号标题5号标题6号标题 Gallery相冊","categories":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://SlectRxz.github.io/categories/Spring-Data-JPA/"}],"tags":[{"name":"Java框架","slug":"Java框架","permalink":"http://SlectRxz.github.io/tags/Java框架/"}]},{"title":"Spring Data JPA底层实现原理","slug":"Spring Data JPA/SpringDataJPA_底层实现原理","date":"2019-12-14T16:00:00.000Z","updated":"2019-12-20T11:53:11.020Z","comments":true,"path":"2019/12/15/Spring Data JPA/SpringDataJPA_底层实现原理/","link":"","permalink":"http://SlectRxz.github.io/2019/12/15/Spring Data JPA/SpringDataJPA_底层实现原理/","excerpt":"对Spring Data JPA内部原理解析","text":"对Spring Data JPA内部原理解析 [TOC] Spring Data JPA常用接口分析在入门案例中，我们仅仅定义了CustomerDao的接口，并没有提供任何的方法，那么我们所调用的增删改查的方法来自哪里呢？答案很简单，对于我们自定义的Dao接口，由于继承了JpaRepository和JpaSpecificationExecutor，所以我们可以使用这两个接口的所有方法。 进入JpaRepository，在类上按住ctrl+F2： 在JpaSpecificationExecutor中也是类似的情况。 但是我们注意到，JpaRepository和JpaSpecificationExecutor是接口，其只是一些方法声明，没有具体的实现方式，那么在 Spring Data JPA中它又是怎么实现的呢？ Spring Data JPA的实现过程已根据id查询用户代码为例： 打断点，观察我们定义的customerdao的实现对象是谁： 我们可以看到产生了一个动态代理对象JdkDynamicAopProxy，而该对象是Spring内部通过AOP帮助我们创建对象的，单机右键，查看源码： 进如到JdkDynamicAopProxy对象中： 我们发现JdkDynamicAopProxy对象实现了InvocationHandler接口，找到invoke方法，其中target对象就是生成的动态代理对象，打断点查看： 让我们查询一下target对象的源代码（其实是SimpleJpaRepository对象） 可以看到SimpleJpaRepository对象继承实现了JpaRepository和JpaSpecificationExecutor接口中的方法。 由于我们的测试案例是根据用户id查询用户，实际上调用了findOne()方法，那么究竟是不是调用了SimpleJpaRepository对象中的findOne()方法呢？我们打断点测试一下： 我们可以看到，页面跳转到SimpleJpaRepository对象中的findOne()方法中，且接收到参数为1，与测试案例相吻合。 顺带一提，上述findOne()方法返回了一个em.find()，其实em就是EntityManager对象，而他是JPA原生的实现方式，所以我们得到结论Spring Data JPA只是对标准JPA操作进行了进一步封装，简化了Dao层代码的开发。 Spring Data JPA完整调用过程分析","categories":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://SlectRxz.github.io/categories/Spring-Data-JPA/"}],"tags":[{"name":"Java框架","slug":"Java框架","permalink":"http://SlectRxz.github.io/tags/Java框架/"}]},{"title":"Spring Data JPA入门案例","slug":"Spring Data JPA/SpringDataJPA_入门案例","date":"2019-12-13T16:00:00.000Z","updated":"2019-12-20T11:50:59.848Z","comments":true,"path":"2019/12/14/Spring Data JPA/SpringDataJPA_入门案例/","link":"","permalink":"http://SlectRxz.github.io/2019/12/14/Spring Data JPA/SpringDataJPA_入门案例/","excerpt":"对Spring Data JPA做了一个基本的简介，包括springdatajpa与hibernate、jpa之间的关系；Spring Data JPA的入门案例环境的搭建、CRUD等操作。","text":"对Spring Data JPA做了一个基本的简介，包括springdatajpa与hibernate、jpa之间的关系；Spring Data JPA的入门案例环境的搭建、CRUD等操作。 [TOC] SpringDataJPA的概述 Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！在JPA的基础上再做了一层封装。 特性： Spring Data JPA 极大的简化了数据库访问层代码（持久层）。如何简化呢？使用了Spring Data JPA,我们的dao层只需要写接口，再配置包扫描，我们只需要调用接口对象，将会自动生成动态代理对象执行增删查改、分页等操作。 Spring Data JPA与JPA与hibernate之间的关系JPA是一套规范，内部由接口和抽象类实现；hibernate是一套成熟的ORM框架，且hibernate实现了JPA规范，所以hibernate是JPA的一种实现方式，我们使用JPA中的API编程，意味着站在更高的角度看代问题（面向接口编程。） Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装。 Spring Data JPA快速入门 环境搭建 Maven工程 依赖 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ctgu.rxz&lt;/groupId&gt; &lt;artifactId&gt;springdataJpa01&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--是spring对orm相关支持的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring end --&gt; &lt;!-- hibernate beg --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- hibernate end --&gt; &lt;!-- c3p0 beg --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 end --&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--springdatajpa的坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.9.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el beg 使用spring data jpa 必须引入 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.el&lt;/groupId&gt; &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.el&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- el end --&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件 1.配置数据库连接池 2.配置entityManageFactory对象交给Spring容器管理 1）配置实体类包扫描 2）配置JPA的实现厂家 3）配置JPA的供应适配器（指定数据库） 3.设置JPA事务管理器 4.整合Spring Data JPA，指定dao接口的包名称，声明要对此包下的dao接口进行动态代理 5.AOP事务管理 6.配置spring包扫描 xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/data/jpa http://www.springframework.org/schema/data/jpa/spring-jpa.xsd\"&gt; &lt;!--spring和spring data jpa的配置--&gt; &lt;!--配置包扫描--&gt; &lt;context:component-scan base-package=\"ctgu\"/&gt; &lt;!--1.配置数据库连接池--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt; &lt;/bean&gt; &lt;!--2.配置entityManageFactory对象交给spring容器管理 指定实体类所在的包名称--&gt; &lt;bean id=\"entityManagerFactory\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--i 配置的是扫描的包（实体类所在的包）--&gt; &lt;property name=\"packagesToScan\" value=\"ctgu.pojo\"/&gt; &lt;!--ii 配置Jpa的实现厂家--&gt; &lt;property name=\"persistenceProvider\"&gt; &lt;bean class=\"org.hibernate.jpa.HibernatePersistenceProvider\"/&gt; &lt;/property&gt; &lt;!--iii 配置JPA的供应商适配器--&gt; &lt;property name=\"jpaVendorAdapter\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"&gt; &lt;!--配置是否自动创建数据库表--&gt; &lt;property name=\"generateDdl\" value=\"false\"/&gt; &lt;!--指定数据库类型，注意全部是大写--&gt; &lt;property name=\"database\" value=\"MYSQL\"/&gt; &lt;!--数据库方言：支持的特有语法（每个数据库都有细微的差别）--&gt; &lt;property name=\"databasePlatform\" value=\"org.hibernate.dialect.MySQLDialect\"/&gt; &lt;property name=\"showSql\" value=\"true\"/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;!--配置Jpa的方言：高级的特性，不同的实现厂商有各自的特性，比如Hibernate--&gt; &lt;property name=\"jpaDialect\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaDialect\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.JPA事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.orm.jpa.JpaTransactionManager\"&gt; &lt;property name=\"entityManagerFactory\" ref=\"entityManagerFactory\"/&gt; &lt;/bean&gt; &lt;!--4.整合spring dataJpa 指定dao接口的包名称 声明要对此包下的dao接口进行动态代理增强，生成simpleJpaRepository代理类--&gt; &lt;jpa:repositories base-package=\"ctgu.dao\" transaction-manager-ref=\"transactionManager\" entity-manager-factory-ref=\"entityManagerFactory\"/&gt; &lt;!--5.txAdvice--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"insert*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete*\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 6.aop--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* cn.itcast.service.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 编写实体类，完成数据库和实体类之间的关系映射 1.配置实体类与表的映射关系（此pojo与数据库中的那一张表关系映射） @Entiy @Table(name=”数据库表的名称”) 2.实体类中属性与表中字段的映射关系 @Id(“name”)数据库中的主键字段名 @GeneratedValue(value) strategy=GenerationType.IDENTITY:自增 Mysql（底层数据库支持的自增长方式对id自增） strategy=GenerationType.SEQUENCE：序列 Oracle（底层数据库必须支持序列） strategy=GenerationType.TABLE：jpa提供的一种机制，通过一张数据库表的形式帮助我们完成自增 strategy=GenerationType.AUTO:有程序自动的帮助我们选择主键生成策略 @Column（name=”value”）数据库中表的字段名 注意： 默认@Column()配置是可以省略的，遵从驼峰式命名，也就是遇到大写字母会转成 ‘_’ ，但是如果配置下面的代码就不能省略了，属于无修改命名。比如数据库中字段名是：user_name, 则对应实体类中写成 userName javapackage ctgu.pojo;import javax.persistence.*;@Entity@Table(name = \"cst_customer\")public class Customer &#123; /** * @ Id声明主键的设置 * @ GeneratedValue配置主键是生成策略（自动增长） * GenerationType.IDENTITY * @ Column(name = \"cust_id\")数据库中表中字段的名字 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"cust_id\") private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; public Long getCustId() &#123; return custId; &#125; public void setCustId(Long custId) &#123; this.custId = custId; &#125; public String getCustName() &#123; return custName; &#125; public void setCustName(String custName) &#123; this.custName = custName; &#125; public String getCustSource() &#123; return custSource; &#125; public void setCustSource(String custSource) &#123; this.custSource = custSource; &#125; public String getCustIndustry() &#123; return custIndustry; &#125; public void setCustIndustry(String custIndustry) &#123; this.custIndustry = custIndustry; &#125; public String getCustLevel() &#123; return custLevel; &#125; public void setCustLevel(String custLevel) &#123; this.custLevel = custLevel; &#125; public String getCustAddress() &#123; return custAddress; &#125; public void setCustAddress(String custAddress) &#123; this.custAddress = custAddress; &#125; public String getCustPhone() &#123; return custPhone; &#125; @Override public String toString() &#123; return \"Customer&#123;\" + \"custId=\" + custId + \", custName='\" + custName + '\\'' + \", custSource='\" + custSource + '\\'' + \", custIndustry='\" + custIndustry + '\\'' + \", custLevel='\" + custLevel + '\\'' + \", custAddress='\" + custAddress + '\\'' + \", custPhone='\" + custPhone + '\\'' + '&#125;'; &#125; public void setCustPhone(String custPhone) &#123; this.custPhone = custPhone; &#125;&#125; 编写dao接口 编写接口需要遵循： 实现JpaRepository&lt;T,V&gt;和JpaSpecificationExecutor接口。 JpaRepository&lt;T,V&gt;:用于完成基本的CRUD操作。 T：与数据库表对应的实体类型 V：与数据库表对应实体的主键类型 JpaSpecificationExecutor:与数据库表对应的实体类型 提供相应的泛型 javapackage ctgu.dao;import ctgu.pojo.Customer;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;import org.springframework.data.jpa.repository.Modifying;import org.springframework.data.jpa.repository.Query;import java.util.List;/** * 符合springDataJpa的dao层接口规范 * JpaRepository&lt;操作的实体类型,实体类型中的 主键 属性的类型&gt; * i 封装了基本的CRUD的操作 * JpaSpecificationExecutor&lt;操作的实体类类型&gt; * i 封装了复杂查询（分页操作） */public interface CustomerDao extends JpaRepository&lt;Customer,Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;&#125; 测试 javapackage ctgu.test;import ctgu.dao.CustomerDao;import ctgu.pojo.Customer;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.transaction.annotation.Transactional;import javax.persistence.Table;import java.util.List;/** * 声明sping提供的单元测试环境 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class CustomerDaoTest &#123; @Autowired private CustomerDao customerDao; /** * 根据id查询 * findOne(主键) */ @Test public void findCustomer()&#123; Customer customer = customerDao.findOne(2L); System.out.println(customer); &#125; Spring Data JPA实现CRUD完成上述入门案例后，我们对Customer类进行CRUD测试： save(Object) java/** * save()保存或者更新 * 如果传入的对象没有id属性，那么就是保存； * 如果存在id属性，就根据id查询后，再更新 */ @Test public void saveCustomer()&#123; Customer customer = new Customer(); customer.setCustAddress(\"湖北省宜昌市\"); customer.setCustName(\"coderxz\"); customerDao.save(customer); &#125; @Test public void updateCustomer()&#123; Customer customer = new Customer(); customer.setCustAddress(\"湖北省宜昌市\"); customer.setCustName(\"coderxz（修改）\"); customer.setCustId(5L); customerDao.save(customer); &#125; findOne(主键属性) java/** * 根据id查询 * findOne(主键) */ @Test public void findCustomer()&#123; Customer customer = customerDao.findOne(2L); System.out.println(customer); &#125; getOne(主键属性) java/** * getOne(Long id) * 测试时需要加入 @Transactional保证getOne（）正常运行 * getOne和findOne有什么区别呢？em是EntityManager对象 * findOne() * 底层调用 em.find（） 立即加载 * getOne() * 底层调用 em.getReference() 延迟加载 */ @Test @Transactional public void getOne()&#123; Customer customer = customerDao.getOne(4L); System.out.println(customer); &#125; delete(主键/对象) java/** * 根据id进行删除 * 先根据id进行查询，如果有再执行删除 执行了select后执行delete */ @Test public void deleteCustomer()&#123; customerDao.delete(2L); &#125; findAll()/count()/exists java@Test public void findAllCustomer()&#123; List&lt;Customer&gt; list = customerDao.findAll(); for(Customer customer:list)&#123; System.out.println(customer); &#125; &#125; @Test public void countCustomer()&#123; long count = customerDao.count(); System.out.println(\"统计客户总条数：\"+count); &#125; /** * 测试用户是否存在 * 底层执行的是select */ @Test public void ExistsCustomer()&#123; boolean exists = customerDao.exists(10L); System.out.println(\"id为10的用户存在吗？\"+exists); &#125;","categories":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://SlectRxz.github.io/categories/Spring-Data-JPA/"}],"tags":[{"name":"Java框架","slug":"Java框架","permalink":"http://SlectRxz.github.io/tags/Java框架/"}]},{"title":"JPA简介","slug":"Spring Data JPA/SpringDataJPA_简介","date":"2019-12-12T16:00:00.000Z","updated":"2019-12-20T11:51:36.258Z","comments":true,"path":"2019/12/13/Spring Data JPA/SpringDataJPA_简介/","link":"","permalink":"http://SlectRxz.github.io/2019/12/13/Spring Data JPA/SpringDataJPA_简介/","excerpt":"对SpringDataJPA的入门介绍，包括ORM的概述以及对JPA和hibernate的简介，搭建JPA的入门案例、增删查改、复杂查询等操作。","text":"对SpringDataJPA的入门介绍，包括ORM的概述以及对JPA和hibernate的简介，搭建JPA的入门案例、增删查改、复杂查询等操作。 ORM的概述 ORM（Object-Relational Mapping）表示对象关系映射。基于面向对象的思想，将对象与关系型数据库进行映射。简单而言，ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。 主要目的：操作实体类就相当于操作数据库表 建立两个映射关系： 实体类和表的映射关系 实体类中属性和表中字段的映射关系 不再重点关注：sql语句 JAP的概述常见的ORM框架有Mybatis(半自动)，Hibernate（全自动），JPA。 JAP（Java Persistence API），即Java持久化API，由SUN公司退出的一套基于ORM的规范，内部由一系列的接口和抽象类组成。 JPA的优势： 1. 标准化 JPA 是 JCP 组织发布的 Java EE 标准之一，因此任何声称符合 JPA 标准的框架都遵循同样的架构，提供相同的访问API，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的JPA框架下运行。 2. 容器级特性的支持 JPA框架中支持大数据集、事务、并发等容器级事务，这使得 JPA 超越了简单持久化框架的局限，在企业应用发挥更大的作用。 3. 简单方便 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易的掌握。JPA基于非侵入式原则设计，因此可以很容易的和其它框架或者容器集成 4. 查询能力 JPA的查询语言是面向对象而非面向数据库的，它以面向对象的自然语法构造查询语句，可以看成是Hibernate HQL的等价物。JPA定义了独特的JPQL（Java Persistence Query Language），JPQL是EJB QL的一种扩展，它是针对实体的一种查询语言，操作对象是实体，而不是关系数据库的表，而且能够支持批量更新和修改、JOIN、GROUP BY、HAVING 等通常只有 SQL 才能够提供的高级查询特性，甚至还能够支持子查询。 5. 高级特性 JPA 中能够支持面向对象的高级特性，如类之间的继承、多态和类之间的复杂关系，这样的支持能够让开发者最大限度的使用面向对象的模型设计企业应用，而不需要自行处理这些特性在关系数据库的持久化。 JAP与hibernate的关系 hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 总之，hibernate的目的在于程序员忽略SQL语句，以执行对象的形式达到操作数据库表。 JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。JPA怎么取代Hibernate呢？JDBC规范可以驱动底层数据库吗？答案是否定的，也就是说，如果使用JPA规范进行数据库操作，底层需要hibernate作为其实现类完成数据持久化工作。（可以类比JDBC规范和各个数据库厂商来具体实现这两者的关系） JPA入门案例的搭建基于工程：Maven工程 坐标：文章结尾处 数据库表： Code/*创建客户表*/ CREATE TABLE cst_customer ( cust_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT &apos;客户编号(主键)&apos;, cust_name varchar(32) NOT NULL COMMENT &apos;客户名称(公司名称)&apos;, cust_source varchar(32) DEFAULT NULL COMMENT &apos;客户信息来源&apos;, cust_industry varchar(32) DEFAULT NULL COMMENT &apos;客户所属行业&apos;, cust_level varchar(32) DEFAULT NULL COMMENT &apos;客户级别&apos;, cust_address varchar(128) DEFAULT NULL COMMENT &apos;客户联系地址&apos;, cust_phone varchar(64) DEFAULT NULL COMMENT &apos;客户联系电话&apos;, PRIMARY KEY (`cust_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 实体类POJO： javapublic class Customer implements Serializable &#123; private Long custId; private String custName; private String custSource; private String custIndustry; private String custLevel; private String custAddress; private String custPhone; ...get/set方法（略） 项目目录： 案例：对数据库中的客户表（增删查改） 创建maven工程，导入坐标 配置JPA的核心配置文件 位置：配置到类路径下的一个叫做META-INF的文件夹下 命名：persistent.xml xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"2.0\"&gt; &lt;!-- 持久化单元 name：持久化单元名称 可以自定义 transaction-type：事务管理的方式 JTA:分布式事务管理（针对：不同的表分布在不同的数据库中） RESOURCE_LOCAL：本地事务管理 --&gt; &lt;persistence-unit name=\"myJpa\" transaction-type=\"RESOURCE_LOCAL\"&gt; &lt;!--1.jpa的实现方式--&gt; &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt; &lt;properties&gt; &lt;!-- 2.配置数据库信息 用户名，javax.persistence.jdbc.user 密码， javax.persistence.jdbc.password 驱动， javax.persistence.jdbc.driver 数据库地址 javax.persistence.jdbc.url --&gt; &lt;property name=\"javax.persistence.jdbc.user\" value=\"root\"/&gt; &lt;property name=\"javax.persistence.jdbc.password\" value=\"root\"/&gt; &lt;property name=\"javax.persistence.jdbc.driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"javax.persistence.jdbc.url\" value=\"jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8\"/&gt; &lt;!--3.配置jpa实现（hibernate）的配置信息 显示sql：hibernate.show_sql false/true 自动创建数据库表：hibernate.hbm2ddl.auto create：程序运行时创建数据库表（如果表已存在，先删除再创建） update：程序运行时创建（如果有表，不会创建表） none：不会创建表 --&gt; &lt;property name=\"hibernate.show_sql\" value=\"true\"/&gt; &lt;property name=\"hibernate.hbm2ddl.auto\" value=\"update\"/&gt; &lt;/properties&gt; &lt;/persistence-unit&gt;&lt;/persistence&gt; 配置实体类与数据库表的映射关系 我们需要配置： 1).实体类与表的映射关系（此pojo与数据库中的那一张表关系映射） ​ @ Entity​ @ Table(name=”cst_customer”)name表示数据库中表的名称 2).实体类中属性与表中字段的映射关系 ​ @ Id声明主键的设置​ @ GeneratedValue配置主键是生成策略（自动增长）​ strategy=​ GenerationType.IDENTITY:自增 Mysql（底层数据库支持的自增长方式对id自增）​ GenerationType.SEQUENCE：序列 Oracle（底层数据库必须支持序列）​ GenerationType.TABLE：jpa提供的一种机制，通过一张数据库表的形式帮助我们完成自增​ GenerationType.AUTO:有程序自动的帮助我们选择主键生成策略​ @ Column(name = “cust_id”)数据库中表中字段的名字 javapackage ctgu.pojo;import javax.persistence.*;@Entity@Table(name=\"cst_customer\")public class Customer &#123; /** * @ Id声明主键的设置 * @ GeneratedValue配置主键是生成策略（自动增长） * GenerationType.IDENTITY * @ Column(name = \"cust_id\")数据库中表中字段的名字 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(name = \"cust_id\") private Long custId; @Column(name = \"cust_name\") private String custName; @Column(name = \"cust_source\") private String custSource; @Column(name = \"cust_industry\") private String custIndustry; @Column(name = \"cust_level\") private String custLevel; @Column(name = \"cust_address\") private String custAddress; @Column(name = \"cust_phone\") private String custPhone; ...set/get方法(略)&#125; 测试 操作：向数据库中添加一个用户。 Jpa的操作步骤： 1.加载配置文件创建工厂（实体管理器工厂）对象 2.通过实体管理类工厂获取实体管理器 3.获取事务对象，开启事务（重要！） 4.完成增删改查 5.提交事务（如果抛出异常，回滚事务） 6.释放资源 java@Test public void saveCustomer()&#123; // 1.加载配置文件创建工厂（实体管理器工厂）对象 输入参数：持久化单元名称，在下xml中 EntityManagerFactory factory = Persistence.createEntityManagerFactory(\"myJpa\"); //2.通过实体管理类工厂获取实体管理器 EntityManager manager = factory.createEntityManager(); //3.获取事务对象，开启事务（重要！） EntityTransaction transaction = manager.getTransaction(); //开启事务 transaction.begin(); //4.创建对象，完成保存操作 Customer customer = new Customer(); customer.setCustName(\"三峡大学\"); customer.setCustIndustry(\"大学\"); manager.persist(customer); // 5.提交事务 transaction.commit(); //6.释放资源 manager.close(); //factory.close(); &#125; 我们发现上述步骤中获取实体管理器是可以简化成工具类的。 JpaUtils： * 解决实体管理器工厂的浪费资源和耗时的问题 * 通过静态代码块的形式，当程序第一次访问此类时，创建一个公共管理器工厂对象 * 第一次访问getEntityManager（）方法时，首先会执行静态代码块创建一个factory对象，再创建一个EntityManager对象； * 第二次访问时，由于静态代码块只会在创建时执行一次，直接返回EntityManager对象 javapackage ctgu.utils;import javax.persistence.EntityManager;import javax.persistence.EntityManagerFactory;public class JpaUtils &#123; private static EntityManagerFactory factory; static &#123; factory = Persistence.createEntityManagerFactory(\"myJpa\"); &#125; /** * 获取EntityManager对象 */ public static EntityManager getEntityManager()&#123; return factory.createEntityManager(); &#125;&#125; ## JPA中的API介绍 上述已经实现了一个基本的保存用户的案例，下面对于JPA中的一些API进行简单的介绍： 1. Persistence javaEntityManagerFactory factory = Persistence.createEntityManagerFactory(\"myJpa\"); 主要是用于获取EntityManageFactory对象，通过调用该类的静态方法，形参为配置文件中持久化单元的名称。 2. EntityManageFactory javaEntityManager manager = factory.createEntityManager(); EntityManageFactory接口主要用于创建EntityManage实例。 3. EntityManage javamanager.persist(customer);//增manager.find(Customer.class, 1L);//查（立即加载）manager.getReference(Customer.class, 1L);//查（延迟加载）manager.remove(customer);//删manager.merge(customer);//改 EntityManager是完成持久化操作的核心对象。实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。 4. EntityTransaction EntityTransaction是完成事务操作的核心对象，对于EntityTransaction在我们的java代码中承接的功能比较简单 begin：开启事务 commit：提交事务 rollback：回滚事务 ## JPA中的增删查改 上述我们已经介绍了向数据库中添加数据，下面介绍JPA中的删除，修改，查询： 查询：根据id查修客户find()方法： 参数一：class，查询数据的结果需要包装的实体类型的字节码 参数二：查询的主键的取值 getRefrence() 参数同上 区别： 使用find查询：（立即加载） 1.查询的对象就是当前对象本身 2.在调用find方法的时候，就会发送sql语句查询数据库使用getReference查询：（延迟加载） 1.获取的对象是一个动态代理对象 2.调用getReference方法不会立即发送sql语句查询数据库当需要调用查询结果对象的时候，才会发送查询的sql语句。什么时候调用，什么时候发送 java@Test public void findCustomer()&#123; //1.获取实体器工厂，获取实体器管理对象 EntityManager manager = JpaUtils.getEntityManager(); //2.获取事务对象 EntityTransaction transaction = manager.getTransaction(); //开启事务 transaction.begin(); //3.执行查询 Customer customer = manager.find(Customer.class, 1L);//记住添加L，id是Long类型的 //Customer customer = manager.getReference(Customer.class, 1L); System.out.println(customer); //4.提交事务 transaction.commit(); manager.close(); &#125; ​ 删除： ​ 删除操作：注意：删除不是直接传入一个id去删除，而是传入一个对象去完成删除操作。remove(Object) ​ 先find该用户，再执行查询。 java@Test public void deleteCustomer()&#123; EntityManager manager = JpaUtils.getEntityManager(); EntityTransaction transaction = manager.getTransaction(); transaction.begin(); Customer customer = manager.find(Customer.class, 1L); manager.remove(customer); transaction.commit(); manager.close(); &#125; 更改： 先将对象查询出来，再调用merge(Object)方法。 java@Test public void updateCustomer()&#123; EntityManager manager = JpaUtils.getEntityManager(); EntityTransaction transaction = manager.getTransaction(); transaction.begin(); Customer customer = manager.find(Customer.class, 2L); customer.setCustPhone(\"123456789\"); manager.merge(customer); transaction.commit(); manager.close(); &#125; JPA中的复杂查询JPQL(Java Persistence Query Language). SQL:查询的是数据库中的表和表的字段。 JPQL：查询的是实体类和类中的属性。 基于首次在EJB2.0中引入的EJB查询语言(EJB QL),Java持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将SQL语法和简单查询语义绑定在一起·使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的SQL。其特征与原生SQL语句类似，并且完全面向对象，通过类名和属性访问，而不是表名和表的属性。 查询所有用户 查询所有对象：SQL:select * from cst_customer ​ JPQL:from ctgu.pojo.Customer from Customer省略包路径也行 注意：JPQL中不能写select * （可以写select count(id)） java@Test public void findAllCustomer()&#123; //1.获取EntityManager对象 EntityManager manager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction transaction = manager.getTransaction(); transaction.begin(); //3.查询全部 String jpql=\"from Customer\"; //创建Query查询对象，query对象才是执行jpql的对象 Query query = manager.createQuery(jpql); List list = query.getResultList(); for(Object customer:list)&#123; System.out.println(customer); &#125; //4.提交事务 transaction.commit(); //5.释放资源 manager.close(); &#125; 排序查询 SQL:SELECT * FROM cst_customer ORDER BY cust_id DESC JPQL:from Customer ORDER BY custId DESC java@Test public void OrderAllCustomer()&#123; //1.获取EntityManager对象 EntityManager manager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction transaction = manager.getTransaction(); transaction.begin(); //3.查询全部 String jpql=\"from Customer ORDER BY custId DESC\"; //创建Query查询对象，query对象才是执行jpql的对象 Query query = manager.createQuery(jpql); List list = query.getResultList(); for(Object customer:list)&#123; System.out.println(customer); &#125; //4.提交事务 transaction.commit(); //5.释放资源 manager.close(); &#125; 统计查询总数 SQL:SELECT COUNT(cust_id) FROM cst_customer JPQL:select count(custId) from Customer java@Test public void countCustomer()&#123; //1.获取EntityManager对象 EntityManager manager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction transaction = manager.getTransaction(); transaction.begin(); //3.查询全部 String jpql=\"select count(custId) from Customer \"; //创建Query查询对象，query对象才是执行jpql的对象 Query query = manager.createQuery(jpql); /** * 由于返回的是单个值 * getSingleResult()得到唯一的结果 * getResultList()直接将查询的结果封装在list集合中 */ Object result = query.getSingleResult(); System.out.println(\"返回的用户总数为：\"+result); //4.提交事务 transaction.commit(); //5.释放资源 manager.close(); &#125; 分页查询 SQL:SELECT * FROM cst_customer LIMIT ?,? JPQL:from Customer 再设置分页的参数 java@Test public void PageCustomer()&#123; //1.获取EntityManager对象 EntityManager manager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction transaction = manager.getTransaction(); transaction.begin(); //3.查询全部 String jpql=\"from Customer \"; //创建Query查询对象，query对象才是执行jpql的对象 Query query = manager.createQuery(jpql); /** * 设置分页参数 */ query.setFirstResult(1); query.setMaxResults(3); List list = query.getResultList(); for (Object customer:list) &#123; System.out.println(customer); &#125; //4.提交事务 transaction.commit(); //5.释放资源 manager.close(); &#125; 模糊查询 SQL:SELECT * FROM cst_customer where cust_name LIKE ‘%大学%’ JPQL:FORM Customer where custName like ? java@Test public void chooseCustomer()&#123; //1.获取EntityManager对象 EntityManager manager = JpaUtils.getEntityManager(); //2.开启事务 EntityTransaction transaction = manager.getTransaction(); transaction.begin(); //3.查询全部 String jpql=\" from Customer where custName like ? \"; //创建Query查询对象，query对象才是执行jpql的对象 Query query = manager.createQuery(jpql); /** * 设置查询条件 * 第一个参数：占位符的索引位置 * 第二个参数：取值 */ query.setParameter(1,\"%大学%\"); List list = query.getResultList(); for (Object customer:list) &#123; System.out.println(customer); &#125; //4.提交事务 transaction.commit(); //5.释放资源 manager.close(); &#125; maven坐标&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ctgu.rxz&lt;/groupId&gt; &lt;artifactId&gt;jpa-01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- hibernate对jpa的支持包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt; &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mysql and MariaDB --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;","categories":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://SlectRxz.github.io/categories/Spring-Data-JPA/"}],"tags":[{"name":"Java框架","slug":"Java框架","permalink":"http://SlectRxz.github.io/tags/Java框架/"}]},{"title":"java基础知识复习","slug":"java基础/基础知识的复习","date":"2019-11-03T16:00:00.000Z","updated":"2019-12-20T12:07:55.905Z","comments":true,"path":"2019/11/04/java基础/基础知识的复习/","link":"","permalink":"http://SlectRxz.github.io/2019/11/04/java基础/基础知识的复习/","excerpt":"在保研前参加了人人的面试，三面后了无音讯了，然后面试前也准备了一些知识储备，包括Java集合，线程以及面试经常会问的一些基础问题，整理一下。","text":"在保研前参加了人人的面试，三面后了无音讯了，然后面试前也准备了一些知识储备，包括Java集合，线程以及面试经常会问的一些基础问题，整理一下。 Java基础部分 1.重载和重写区别 重载：同一个类，相同名称方法，参数类型，个数，顺序，返回值，访问顺序不同，发生在编译时。 重写：发生在父子类中，方法名，参数相同（不同类），返回值的访问范围要小于父类，抛出异常的范围小于父类，访问修饰符范围大于父类，如果private则不能重写。 private：只有本类方法可以访问，不能重写，不可直接访问。friendly：包访问权限，子类不可访问。protect：同包，子类均可，其他包不可访问。 2.String、StringBuffer、StringBuild的区别 String:底层由final char[]value 适合操作少量数据StringBuffer：底层由char[]value 其操作方法有sychronized修饰，线程安全。StringBuild：底层由char[]value 线程不安全，可扩展，初始长度16。 3.自动装箱/自动拆箱 装箱：将基本类型用他们对应的引用类型包装。int-&gt;Integer拆箱：将引用类型转换成基本类型。 4.equals与== equals来自object类，对于其方法在开发手册这样描述：对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 也就是和==一样的。 但是Java中很多引用类型都将equals方法重写了，对于String类型来说，它的equals不再是==而实比较其内容是否相等。注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 5.final、finally、finalize区别 final: 修饰变量：表示该变量的值不可更改（就是常量） 修饰引用类型变量：表示该引用变量初始化后不能指向其他对象。 修饰类：表示该类不能被继承，且其成员都默认为final。（早期final修饰的方法会转换为内嵌调用，提高效率） finally：使用在try/catch中。finalize：Object类中的方法，在GC内存清理对象时被调用。 6.接口和抽象类 接口：只能定义，不能实现，都为public，抽象类可以有非抽象方法。注意：Java8新变化中接口允许添加默认实现方法。接口中的变量为static final修饰必须初始化，抽象类中不一定。抽象类：除了不能实现与普通Java类并无区别。一个类可以实现多个接口，但是只能实现一个抽象类。接口是行为的抽象，抽象类是对象的抽象，是一种模板设计。 7.Java对象的初始化顺序。 单个类：静态（成员、代码块）&gt;成员变量&gt;构造器调用构造函数，会先调用父类的构造函数，默认调用无参构造函数，所以一般都要写。 8.true、false、null是关键字吗？ 不是 true/false是布尔常量。null是引用类型字面变量。 9.Integer的缓存机制 在Integer类中封装了一个-128~127之间的整型对象，也就是说，当年创建值为-128~127之间的对象的时候，会返回同一个对象的引用。 10.String类型的创建方式 String str=new String(“helloworld”);至少创建了一个对象 ，可能创建了两个对象。原因：我们需要把这句话拆分成为两句。new String()和String str=。new肯定创建了一个对象的，String str=”helloworld”,这句话首先在字符串常量池中找，看是否存在该对象，如果存在则无需创建新 对象直接返回该对象的引用；不存在，则创建一个对象，加入到字符串常量池中，返回它的引用。 11.后续更新 Java集合篇","categories":[{"name":"找工作笔记","slug":"找工作笔记","permalink":"http://SlectRxz.github.io/categories/找工作笔记/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://SlectRxz.github.io/tags/Java基础/"}]},{"title":"保研的经过","slug":"瞎扯淡/保研经历","date":"2019-09-28T16:00:00.000Z","updated":"2019-12-20T12:06:22.208Z","comments":true,"path":"2019/09/29/瞎扯淡/保研经历/","link":"","permalink":"http://SlectRxz.github.io/2019/09/29/瞎扯淡/保研经历/","excerpt":"随着9.28号志愿的填报，，宣告着我保研的之路的结束，三年的努力吧，双非的本科学校需要飞升到985的学校有很大的难度，下面对我的保研的经历简单的总结一下，算是对自己的一个交代吧。","text":"随着9.28号志愿的填报，，宣告着我保研的之路的结束，三年的努力吧，双非的本科学校需要飞升到985的学校有很大的难度，下面对我的保研的经历简单的总结一下，算是对自己的一个交代吧。随着9.28号志愿的填报，，宣告着我保研的之路的结束，三年的努力吧，双非的本科学校需要飞升到985的学校有很大的难度，下面对我的保研的经历简单的总结一下，算是对自己的一个交代吧。强调： 以下内容只是随口说一说。本文的面向的对象： 多年后的自己。 正文开始也不知道从哪方面说起，保研设计到的东西很多，先说一下我自己的情况，出身双非（普通本科），专业也不是重点专业（物联网工程），下面就从保研准备的时间线来讲吧。 保研需要哪些东西保研需要：前六学期的专业成绩，学科竞赛，科研项目，论文，软著，各种证书（英语四六级，计算机证书，软考…）等等。 保研的流程所谓保研就是先拿到本校的船票（本校把你推出去），然后再拿到目标学校的上船资格（对面学校也愿意接收你）。第一点：不同的学校不同的专业能够报送的学生数量是不同的，我的学院保研率大概是4.5%左右，211，985可能多一些；第二点：不同的学院加分的政策不同，所以你得先在自己学院的前几年的政策研究一下，什么东西能加分，毕竟保研就是同专业的人竞争，有竞争就有一个标准，找到那个标准并为之努力。 这次保研我面了很多学校，包括武汉大学（单独见老师，现场），华科（老师面试12个人，现场），中南大学（预推免面试，现场），重庆大学（预推免面试，现场），电子科技大学（预推免面试，现场），湖南大学（预推免面试，视频），武汉理工（电话面试），西南交通大学（参加夏令营，后视频面试）。 夏令营，预推免，九推的区别：https://www.jianshu.com/p/62c54e11f646?tdsourcetag=s_pctim_aiomsg 面试的心酸历程： 一直面试一直了无音讯，唉，真的很难，我是物联网专业，投的都是计科，结果就是你会编程，别人也会编程，竞赛，项目，论文软著，证书你有，但是一般别人也会有，所以就导致了一个问题：那就是在水平差不多的情况下，老师往往会选择211以上的学生。 华科的面试，总共有12个人面试，由于老师要求上午9点面试，所以我不得不提前一天去武汉，第二天面试是在一个写字楼，应该是老师自己成立的公司，然后我看见墙上挂了十篇软著，，还用相框弄着，在几分钟的仔细观察后，我发现，这玩意和我写的证书的一样的，当时想着我两年内写了八篇（没想到这玩意有用，所有带了三个扫描件）。然后共有12个人面试，看了一下周围的，很多武汉理工的（用的武汉理工的草稿纸），大概一半的武汉理工的，还有个中山大学的，有个西南交通大学的，反正我估计只有我一个双非学校，但是 我觉得他们水平一般，因为他们有些人只带了一份简历，面试一定得带上能证明自己的材料。说一下华科的情况： 总结一下华科的老师大概就是华科计算机学院今年没有预推免（不知道以后有没有），没有预推免就意味着到时候只能去九推面试，然后根据面试的分数排序，最前面的一小部分人读学硕，剩下的就读专硕，学硕3年，专硕两年。学硕毕业得发表一篇一作的SCI，专硕就毕业答辩。我的面试情况： 老师先是问我，你们三峡大学从前有保研到华科吗，此时我知道有，但是不确定是不是计算机学院，但是还是说有，然后那个老师直接问，你能保证到时候九推能拿到面试机会吗？这里，我也知道，双非学校可能走正常流程会直接被刷，连面试机会都没有，这个就比较难搞了。然后那个老师就问了一下算法啥的，感觉没有技术含量。感觉除了双非的原因，还有一部分是因为那个老师是搞自然语言处理的，可能觉得和我的方向不对口。面试的形式的和老师一对一单独面试，我当时还面试不多，都是老师问一句答一句，其实我觉得可以主动把自己做过的东西去给老师将，如果老师和你的领域相同，可以说一说用了哪些技术之类的，但是如果老师不是这个方向的，不要细化到技术，而是突出你的学习能力，主动和老师说，不要等到他去问你，一对一不像群体面试，你可以和老师主动谈，让他感觉你的学习能力很强。 重庆大学的面试重庆大学计算机院好像没有夏令营，直接预推免。也是提前一天赶到重庆，然后要求第二天上午报道，但是需要收费150，头一次面试需要收费的，不明白还是交钱了。我们是下午面试，然后上午抽空见了一下老师，把自己的材料给那个老师看了，然后他也感觉还可以，和我说了一下面试需要啥啥啥的，就去准备了。面试： 这次面试是预推免，走的学院的流程，统一的，面试分了几个组，然后我那个组的老师，有五个老师，面试流程依然一成不变，先来一段英语自我介绍，然后就是老师轮流问问题，感觉我的失分项就是我英语六级没过，老师就针对比赛问，然后也问了一下项目，现在想想，当时有几个地方说的不好，一个是老师问我，你参加其他学校的预推免没有，我当时直接说参加了，但是应该没过。现在我觉得应该说我拿到了211的offer，但是如果我重庆大学通过了我会来重庆大学；还有一个就是那个老师问我映像中最深刻的一个比赛，当时我说的物联网设计竞赛，但是 我没有介绍好，这里建议把自己的比较准备1~2个，打个草稿，突出系统的功能性和你所完成的那部分功能,这部分是需要自己准备一下的（我没准备吃亏）；还有一个部分就是项目，这部分依个人而言吧，我自己说的是网站开发，不能这么说，因为现在网站前端很多都是套模板的，但是我自己是搞后台的，没模板，只有框架，唉，当时应该说负责后端开发，服务器维护，前端页面附带一点。（注：前端难度我感觉不比后台低，因为前端的东西非常多，而且不是简简单单的套个模板，我一个同学总认为搞web，移动端开发就是简单的套模板，其实那只是你没有深度去学习，可能还有一下分布式，微服务等等技术，这里吐槽一下这种人）。 中南大学的面试中南大学计算机学院，有夏令营，计科是A-，我夏令营被刷了，然后报名的预推免，这个学校比较友善，老师亲自跑到各个省去宣讲（就是预推免，通过了就拿offer），然后当时参加湖北省的宣讲，在武汉，也是上午八九点开始吧，也是提前一天去。我们院有四个人一起去的。面试： 由一个老师单独面试，一对一，也是先来一段自我介绍，然后老师提问，没有英文提问，面试下来感觉不错，但是还是比赛没有说好，那个老师是针对你简历上写的内容问的。最后了无音讯了。感觉失败的原因是我六级没过，因为和我一起面试的另外一个专业第一过了，她六级过了，但是我竞赛，论文，项目，软著都比她多，很多面试感觉都嗝屁在英语六级上，所有说英语六级真的很重要啊！！！ 湖南大学面试这个学校我是真的想吐槽一下,首先我通过了他的夏令营，但是我因为要参加西门子的比赛，所有就把它拒了，然后他发放了200个优秀营员，但是到了后面，把双非的优秀营员给鸽了，我后面也参加了预推免，然后是老师单独视频面试，然后第一批补录，我真服了，然后填志愿很多人就把这个学校鸽了，感觉这个学校就是 发放的offer&gt;他的招生人数，也就是说谁报名的快就录谁，总共发了800多offer，有第一批补录，第二批补录啥的，反正学校的环境不错，水平吧，985里面一般。面试： 面试是视频面试，和一个老师面试的，那个老师根有毒似的，就一直疯狂吐槽我，先是说我你发四篇论文干什么，发那么多同水平的干什么（当时我很惊讶，一般老师都是吐槽你发的论文水平很低，然后他就吐槽你发的太多了），然后再说你这么多比赛，有硬件的软件的，你这全栈编程？（原话），然后就一直吐槽我说我本科没有专攻一个地方去学，学的太杂了，然后我一直解释我是物联网专业，本科学的很多是打基础。然后就问我的研究方向，我说大数据，他说你这大数据和你写的论文一点联系都没有，你应该在你论文基础上说研究方向，，，，，反正很无语，感觉他喷的地方有问题，最后那个老师还贼没有礼貌，我还想问一下什么时候出结果，他直接挂了。。。。。。 电子科技大学这是我跑的最后一个学校了，28号填志愿，27号下午面试的，首先我面试的是信软学院，成电的老师和其他学校不同，按照前几年，都是老师单独面试，如果老师对这个同学觉得满足，可以直接要这个学生作为研究生。但是到了我们这一年，非常倒霉，得学院统一组织面试，这样的不好的地方就是，你只有一次机会，而且预推免需要填一位导师，需要导师去给招生办的说一下你的预推免才能过。老师今年一般都是有几个名额就推几个上去。这点我觉得这个学校不错。因为此时我基本没找到什么好的学校，我把软件学院的老师大部分投了一遍（除了嵌入式没投），然后就有几个老师想收留我，有个教授和副教授，我选了个副教授，结果这个人，先是让我等等，他说他有两个名额，等另外一个同学回信再个招生办那边说，结果当天晚上跟我说，我名额已满，把你推荐给另外一个老师。。。。当时真想吐槽，，，，想要不算了不去了，但是由于已经买了火车票，还是加了他推荐的那个老教授的微信，结果11点居然同意了，就参加面试。面试： 成电的面试是我觉得最严谨的一个面试，因为其他学校最多面个十分钟，几分钟的面试根本面不出水平，然后成电的面试是20分钟，每个人时间一样。他是分150英语面试分+350综合能力面试分，先是来一段英语自我介绍，然后就是老师的英语提问，，，这个真的难到我了，之前也咨询了一下成电电子通信那边的英语面试老师提问的啥东西，然后根据他们的所述，我准备了一下：介绍一下你的家乡，你的爱好，你为什么来我们学校之类的简单问题。结果那个老师直接问栈和数组有什么区别？用英语问的用英语答，当时就有点懵，然后问链表是什么，用英语介绍一下你的项目，，，反正英语这部分完全搞不来，还是水平不够，然后就是老师面，，，，那个老师全程怼你，我就说我做后台的，然后我说我用了redis，mysql数据库，然后他说你看过redis的源码吗？你看过mysql的配置文件吗？搞过数据库的优化吗？。。。。。。。。。。。。省略一万字的吐槽。感觉刚好碰到一个搞优化的老师，也被怼的一无是处，不过也发现了自己的一些问题所在，希望在本科和研究生阶段能搞定吧。 最轻松的面试：武汉理工这个学校啊，也不错，因为隔我家比较进，那个老师真的非常热情，晚上十一点发的邮件，有的都回复了，当时在重庆大学面试，但是感觉不稳，这里强烈建议保研的同学可以先拿几个211保底，武汉理工，南航，南理工都不错，先拿到个211再去整985，我因为有一段时间一直在刚武大华科，最后得到的结果就是没有预推免，只有九推，但是九推的你双非可能没有面试机会（可能直接被拒）。当时武汉理工的老师第二天直接给我打电话，没有回复邮件，先花了20分钟给我介绍了一下他的实验室有多么好，然后我问那个老师您不需要面试我吗，然后花了五分钟面试我，大抵就是让我介绍了一下我的项目，不过这个学校好在他是老师单独面试，假如老师A面试你没有通过，你还可以面试老师B,后面也有其他的武汉理工的老师面试，有的还是问了些专业问题，反正总结就是武汉理工难度较小，老师比较友好。 以上就是面试经历了，就不说了，然后除了参加夏令营，预推免，你还需要找老师，找老师需要投递你的简历给老师。先说一下，部分学校老师有权力直接要你，这种老师的权力就比较大，目前我所知道的有电子科技大学和西电。你只需要在找到一个愿意收留你的老师。然后可以在6月开始陆陆续续投简历。 下面我的一些网站，公众号分享： 微信公众号： 保研 （里面有与夏令营和预推免各个学校的报名入口，如果没有链接，直接把他上面的一段话copy到百度就能找到报名的原网页） 网站：2019年保研夏令营一键搜索系统 全国第四轮学科评估结果公布2019年全国大学生保研预报名汇总贴（实时更新中） - 预报名汇总 - 保研通-中国领先的一站式保研在线服务平台工具：PDF转JPG——免费在线将PDF转成图像合并PDF - 在线上免费合并PDF文件Online Video Cutter - 剪辑视频，比如MP4、AVI、MPG和3GP&lt;!–最后感谢吧，感谢理学院的刘老师，计算机学院的张老师、万老师，刘老师，杨老师，帮我发表论文软著已经给我些很重要的建议。最后感谢小屁孩的长期的陪伴吧。&gt;","categories":[{"name":"随笔录","slug":"随笔录","permalink":"http://SlectRxz.github.io/categories/随笔录/"}],"tags":[{"name":"瞎扯","slug":"瞎扯","permalink":"http://SlectRxz.github.io/tags/瞎扯/"}]},{"title":"cookie与session说不清的纠缠","slug":"java基础/session与cookie","date":"2019-08-14T16:00:00.000Z","updated":"2019-12-20T12:04:22.374Z","comments":true,"path":"2019/08/15/java基础/session与cookie/","link":"","permalink":"http://SlectRxz.github.io/2019/08/15/java基础/session与cookie/","excerpt":"关于session与cookie的区别与联系。","text":"关于session与cookie的区别与联系。 最近看到了一篇什么是单点登录（SSO）的文章，主要是讲述多个系统之间如何共享用户的登录状态，使之不需要重复登录。其中看见了自动登录，用到了session和cookie，查阅资料后，顺便把以前所学习的内容进行一次总结。 首先从代码使用上对cookie和session进行介绍： cookie:什么是cookie：cookie是保存在浏览器的一小块数据（一般浏览器保存cookie的个数的有上限的），它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 下面首先说cookie的原理及使用：核心API- 1.构造Cookie对象new Cookie(java.lang.String name, java.lang.String value)- 2.设置cookievoid setPath(java.lang.String uri) ：设置cookie的有效访问路径void setMaxAge(int expiry) ： 设置cookie的有效时间void setValue(java.lang.String newValue) ：设置cookie的值- 3.发送cookie到浏览器端保存void response.addCookie(Cookie cookie) : 发送cookie- 4.服务器接收cookieCookie[] request.getCookies() : 接收cookieCookie原理- 1.服务器创建cookie对象，把会话数据存储到cookie对象中。 new Cookie(“name”,”value”);- 2.服务器发送cookie信息到浏览器 response.addCookie(cookie); 举例： set-cookie: name=eric (隐藏发送了一个set-cookie名称的响应头) 3.浏览器得到服务器发送的cookie，然后保存在浏览器端。 4.浏览器在下次访问服务器时，会带着cookie信息 举例： cookie: name=eric (隐藏带着一个叫cookie名称的请求头) 5.服务器接收到浏览器带来的cookie信息 request.getCookies(); Cookie细节 1）void setPath(java.lang.String uri) ：设置cookie的有效访问路径。有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问服务器时就会带着cookie信息，否则不带cookie信息。 2）void setMaxAge(int expiry) ： 设置cookie的有效时间。 正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的时间。 负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失了！！ 零：表示删除同名的cookie数据 （在同一个路径下面） 3）Cookie数据类型只能保存非中文字符串类型的。可以保存多个cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 session: session：session代表服务器与客户端的一次会话的过程。session对象存储用户指定的配置信息（存储在服务器端），这样在程序未结束前将会一直存在。当用户关闭会话或session超时而销毁。 核心API 1）创建或得到session对象 HttpSession getSession() HttpSession getSession(boolean create) 2）设置session对象 void setMaxInactiveInterval(int interval) ： 设置session的有效时间 void invalidate() ： 销毁session对象 java.lang.String getId() ： 得到session编号 3）保存会话数据到session对象 void setAttribute(java.lang.String name, java.lang.Object value) ： 保存数据 java.lang.Object getAttribute(java.lang.String name) ： 获取数据 void removeAttribute(java.lang.String name) ： 清除数据 session细节 1）java.lang.String getId() ： 得到session编号 2）两个getSession方法： getSession(true) / getSession() : 创建或得到session对象。没有匹配的session编号，自动创建新的session对象。getSession(false): 得到session对象。没有匹配的session编号，返回null 3）void setMaxInactiveInterval(int interval) ： 设置session的有效时间 session对象销毁时间： 3.1 默认情况30分服务器自动回收 3.2 修改session回收时间 3.3 全局修改session有效时间 以上API方便快速开发时查询，下面对session和cookie的原理进行深度了解。（在查阅资料和查询dalao的博客总结） 问题一：cookie与session的异同 作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。 存取方式的不同，Cookie 只能保存 字符串（以key-value形式），Session 可以存任意数据类型，一般情况下我们可以在 Session 中存储对象。 有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。 隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。 存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。 问题二：下面引入为什么需要Cookie： 为什么需要引入cookie呢？由于浏览器与服务器交互是无状态的（HTTP协议无状态），这就意味着浏览器并不知道我是在和张三还是李四打交道，这时候需要一套标准来表示此次会话的谁和谁而这套标准就将cookie和session(下面介绍)的配合。 那么我们进一步思考，session与cookie是如何配合的呢？ 图片来自网络，侵删 用户第一次请求服务器时，服务器创建session，响应客户端，将SessionID（session的唯一标识）返回浏览器。浏览器接收SessionID后，将此信息存储与cookie中。同时cookie记录sessionID属于哪个域名。用户第二次请求服务器时，客户端请求是带着cookie去的，而服务器端从cookie中获取sessionID，查找对应的session信息，这样就可以达到效果—服务器端是在和谁打交道。 下面咱们从代码的角度去解读session HttpSession session=request.getSession() 1 第一次访问创建session对象，给session对象分配一个唯一的ID，叫做JSESSIONID。 new HttpSession() 2 把JSESSIONID作为cookie的值发送给浏览器。 Cookie cookie=new Cookie(“JSESSIONID”,sessionID)； response.addCookie(cookie); 3 当客户端第二次访问服务端时，浏览器带着名字为JSESSIONID的cookie访问浏览器。 4 服务器根据key为JSESSIONID找到对应的sessionID的值，在服务器内搜索是否存在放对应编号的session对象。 if(找到){return map.get(sessionID); }猜想：底层可能是一个Map&lt;String,HttpSession&gt;存储的。 5 如果找到对应的session对象，直接返回该对象。 6 如果找不到对应编号的session对象，则重新创建一个新的session对象（从流程1开始） 注: JSESSIONID与sessionID的关系是，JSESSIONID是sessionID存放在cookie中的名字（cookie中的key值）结论：通过Cookie的值在服务器中找session对象。问题三：如何解决session共享呢？在单系统下session可以在各个业务层获取到，但是在分布式系统下，往往将业务进行水平分割，也许登录功能单独作为一个系统，前端页面显示作为一个系统，广告页又单独作为一个系统等等。那么多系统下就需要解决session共享的问题。下面总结一下dalao的解决办法： Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。 共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。 把session数据放在redis中（使用redis模仿session）","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://SlectRxz.github.io/tags/Java基础/"}]},{"title":"链表反转","slug":"代码总结/用户自动登录","date":"2019-08-10T16:00:00.000Z","updated":"2019-08-16T15:35:05.360Z","comments":true,"path":"2019/08/11/代码总结/用户自动登录/","link":"","permalink":"http://SlectRxz.github.io/2019/08/11/代码总结/用户自动登录/","excerpt":"在spring、springmvc、mybatis框架下使用session和cookie实现用户自动登录。","text":"在spring、springmvc、mybatis框架下使用session和cookie实现用户自动登录。","categories":[{"name":"代码总结","slug":"代码总结","permalink":"http://SlectRxz.github.io/categories/代码总结/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"链表反转","slug":"代码总结/链表反转","date":"2019-08-10T16:00:00.000Z","updated":"2019-08-11T08:55:34.194Z","comments":true,"path":"2019/08/11/代码总结/链表反转/","link":"","permalink":"http://SlectRxz.github.io/2019/08/11/代码总结/链表反转/","excerpt":"关于链表的创建、遍历、反转的实现（递归和非递归）、对k~n之间的节点进行反转。","text":"关于链表的创建、遍历、反转的实现（递归和非递归）、对k~n之间的节点进行反转。 最近回顾了一下数据结构，起因是看见了一提字节跳动的面试题，关于链表反转的，然后将思路总结了一下。(dalao勿喷) 题目：这其实是一道变形的链表反转题，大致描述如下 给定一个单链表的头节点 head,实现一个调整单链表的函数，使得每K个节点之间为一组进行逆序，并且从链表的尾部开始组起，头部剩余节点数量不够一组的不需要逆序。（不能使用队列或者栈作为辅助） 例如：链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。那么 6-&gt;7-&gt;8，3-&gt;4-&gt;5，1-&gt;2各位一组。调整后：1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6-&gt;null。其中 1，2不调整，因为不够一组。 思路：如果是从链表头开始，隔k个进行逆序，尾部多余的不管，还是比较容易。但是其是从后往前逆序，咋算？？ dalao是这样处理的，将原先链表A先整体进行一次逆序，再隔k个进行一次逆序，尾部剩下的节点不管得到链表B,再将链表B整体逆序得到结果C,由于进行了两次逆序，相当于没有逆序。 链表创建Codeclass ListNode&#123; int node; ListNode next;&#125;/** * 单向链表的基本操作： * 创建：头插法、尾插法 * 反转：递归/非递归实现 * @author rong * */public class 链表反转 &#123; /** * 头插法创建链表 * @return */ public ListNode H_createListNode()&#123; ListNode head = new ListNode(); head.node=0; head.next=null; Scanner scanner = new Scanner(System.in); int n=scanner.nextInt(); while(n&gt;0)&#123; ListNode s = new ListNode(); s.node=n; s.next=head.next; head.next=s; n--; &#125; return head; &#125; /** * 尾插法创建链表 * @return */ public ListNode S_createLinkNode()&#123; ListNode head = new ListNode(); head.node=0; head.next=null; ListNode r=head; Scanner scanner = new Scanner(System.in); int n=scanner.nextInt(); while(n&gt;0)&#123; ListNode node = new ListNode(); node.node=n; r.next=node; r=node; n--; &#125; return head; &#125; /** * 链表输出 * @param head */ public static void printlistNode(ListNode head)&#123; head=head.next; while(head!=null)&#123; System.out.print(head.node+&quot;-&gt;&quot;); head=head.next; &#125; &#125; 链表反转-非递归实现Code/** * 单序链表反转（非递归实现） * @param head * @return */ public ListNode reverseList2(ListNode head)&#123; ListNode result = new ListNode(); result.next=null; ListNode temp =null; while(head!=null)&#123; //将原链表中的第一个节点分离，头节点指向下一个节点，将分离的节点使用头插法加入到新节点中 temp=head; head=head.next; /* 这里新建一个头节点，再用头插法将原链表上的节点一个个加进来 这里将head节点作为第一个分离的节点 */ temp.next=result.next; result.next=temp; &#125; return result; &#125; 链表反转-递归实现这里递归，我这样理解的：递归首先是自己调用自己，其次递归的本质就是多个函数进栈的过程，首先找到出口，其次当栈顶函数弹出时，返回的是第n-1个函数。较好解释：https://blog.csdn.net/fx677588/article/details/72357389Code/** * 单链表反转（递归实现） * 递归实现：自己调用自己，想象为多个相同函数进栈，再逐层出栈 * @param head * @return */ private static ListNode reverseList1(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode result = reverseList1(head.next); head.next.next = head; head.next = null; return result; &#125; 链表反转-第k-n个节点Codepublic ListNode reverseListKN(ListNode head,Integer k,Integer n)&#123; /** * 思路：反转前：链表是pre~k~n~s,反转后pre~n~k~s */ //找到第k-1、k、n、n+1的节点 ListNode result = new ListNode(); result=head; ListNode pre=null,nn=null,s; ListNode kk = new ListNode(); int cont=0; while(head!=null)&#123; if(cont==(k-1))&#123; pre=head; &#125; if(cont==n)&#123; nn=head; &#125; head=head.next; cont++; &#125; kk=pre.next; s=nn.next; //将k-n之间的链表反转，其中k节点是头节点，n节点是尾节点 System.out.println(&quot;此时nn节点的值&quot;+nn.node); System.out.println(&quot;此时nn节点下一个节点的值&quot;+nn.next.node); /** * 这是至关重要的一句 * 因为我在接下来的循环语句中要根据下一个节点是否为null来判断是否遍历结束 * 如果没有则会将k~链表最后一个节点全部遍历 * 我仅仅需要遍历第k~n个节点 */ nn.next=null; /**************我的BUG************************************************* * 难点：调了半天bug，发现反转之后，temp成为了第一个（位于）newHead之后 * 而此时我失去了尾部节点的引用对象（以为是kk,但是kk已经.next滑为null了） * 所以在遍历前需要把反转后的尾部节点存一下 */ ListNode tail=kk;//最后需要合并链表需要知道尾部节点，将反转之后的尾部节点存一下 /** * 参数解释： * temp：每次需要将一个节点进行头插法，临时保存 * newHead：反转后需要一个新的头节点 */ ListNode temp=null; ListNode newHead = new ListNode(); newHead.next=null; while(kk!=null)&#123; temp=kk; kk=kk.next; //头插法将temp插入到newHead链表中 temp.next=newHead.next; newHead.next=temp; &#125; // printlistNode(newHead);//打印反转结果：反转成功 /** * 当我们反转结束后，如何将三段链表接起来为关键， * 需要找到反转后节点的头节点和尾节点 * 将节点k-1指向节点n，节点k指向节点n+1 */ pre.next=newHead.next; tail.next=s; return result;&#125;","categories":[{"name":"代码总结","slug":"代码总结","permalink":"http://SlectRxz.github.io/categories/代码总结/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://SlectRxz.github.io/tags/数据结构/"}]},{"title":"Lucene就是这么简单-认识篇","slug":"taotao/Lucene-认识篇","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-04T09:16:33.052Z","comments":true,"path":"2019/08/04/taotao/Lucene-认识篇/","link":"","permalink":"http://SlectRxz.github.io/2019/08/04/taotao/Lucene-认识篇/","excerpt":"Lucene的介绍和索引库的组成结构。","text":"Lucene的介绍和索引库的组成结构。 1.什么是Lucene？？？ Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个全文检索引擎的架构，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。 简单来说，Lucene是一个全文搜索引擎。 全文检索是什么？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) 从大量的信息中快速、准确地查找出要的信息&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) 搜索的内容是文本信息(不是多媒体)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) 搜索的方式：不是根据语句的意思进行处理。如果要搜索的文本为” 2012年的春晚有赵本山吗”，那么含有这些词(2012年、春晚、赵本山)就能搜索出来。每一个词都是关键词。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4) 全面、快速、准确是衡量全文检索系统的关键指标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5) 概括：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a) 只处理文本&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b) 不处理语义&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c) 搜索时英文不区分大小写&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d) 结果列表有相关度排序 2.为什么需要使用Lucene？（数据库不好吗） 全文检索与数据库搜索的区别： 1. 数据库的搜索类似：select from 表名 where 字段名 like ‘%关键字%’例如：select from article where content like’%here%’结果: where here shere缺点：（没有将搜索结果相关度排序）1)搜索效果比较差2)在搜索的结果中，有大量的数据被搜索出来，有很多数据是没有用的。3)查询速度在大量数据的情况下是很难做到快速的。 2. 全文检索：1) 搜索结果按相关度排序：意味着只有前几个页面对于用户来说是比较有用的，其他的结果与用户想要的答案很可能相差甚远。数据库搜索是做不到相关度排序的。2) 因为全文检索是采用引索的方式，所以在速度上肯定比数据库方式like要快。 3.索引库的组成（重要！！）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在讲解如何具体的使用Lucene进行检索之前，我们首先得弄明白Lucene存放的究竟是啥？在数据库中，我们是将数据作为表为基本单位进行存储，那么Lucene又是如何进行存储的呢？ Lucene中存的就是一系列的二进制压缩文件和一些控制文件，它们位于计算机的硬盘上，这些内容统称为索引库，索引库有二部份组成：（1）目录 按照一定的拆分策略（即分词器）将原始记录中的每个字符拆开后，存入一个供将来搜索的表（2）内容 存入到索引库中的原始文本，例如：Java是世界上最好的语言 也就是说：Lucene存放数据的地方我们通常称之为索引库，索引库又分为两部分组成：目录和内容。 理解：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把索引库当作一本书，那么当我们要去查询某一节内容时，需要根据关键句找到对应的页数，再根据页数找到对应的内容。只需记住Lucene是向索引库中进行操作，索引库由目录和内容组成。下面将具体介绍目录和内容的组成： 1）互联网搜索结构框图 说明：1) 当用户打开&nbsp;www.baidu.com&nbsp;网页搜索某些数据的时候，不是直接找的网页，而是找的百度的索引库。索引库里包含的内容有索引号和摘要。当我们打开&nbsp;www.baidu.com&nbsp;时，看到的就是摘要的内容。2) 百度的索引库的索引和互联网的某一个网站对应。3) 当用户数据要查询的关键字，返回的页面首先是从索引库中得到的。4) 点击每一个搜索出来的内容进行相关网页查找，这个时候才找的是互联网中的网页。 Lucene的索引库的结构之后，在数据库中数据是以表为基本单位进行存储的，在索引库中需要存放各种不同类型的数据，是以什么方式存储呢？ Lucene的结构框图 1) 在数据库中，数据库中的数据文件存储在磁盘上。索引库也是同样，索引库中的索引数据也在磁盘上存在，我们用Directory这个类来描述。2) 我们可以通过API来实现对索引库的增、删、改、查的操作。3) 在数据库中，各种数据形式都可以概括为一种：表。在索引库中，各种数据形式也可以抽象出一种数据格式为Document。（类比数据库中的表结构）4) Document的结构为：Document(List&#60;Field&#62;)5) Field里存放一个键值对。键值对都为字符串的形式。6) 对索引库中索引的操作实际上也就是对Document的操作。 4.第一个Lucene程序4.1准备jar包搭建lucene的开发环境，要准备lucene的jar包，要加入的jar包至少有：1) lucene-core-3.1.0.jar (核心包)2) lucene-analyzers-3.1.0.jar (分词器)3) lucene-highlighter-3.1.0.jar (高亮器)4) lucene-memory-3.1.0.jar (高亮器) 4.2准备一个pojoCodepackage com.pojo;public class article &#123; private Long id; private String name; private String content; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 4.3建立索引库并向索引库写内容 向索引库中添加索引 分析：写入索引库使用的类：indexWriter创建IndexWriter构造函数需要三个参数：索引库，分词器，存储的最大长度 //索引库 需要指定索引库的位置Directory directory = FSDirectory.open(new File(“./indexDir”));//存在当前路径下的indexDir文件下//分词器 需要指定一个分词器版本Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30); 得到了indexWriter对象——-&gt;indexWriter需要向索引库写的是什么呢？——–&gt;写的是document对象——–&gt;ducument对象里面存储的是什么？———-&gt;filed对象filed对象有四个参数：1）放在索引库中的name名称2）放在索引库中的value3）是否存储在索引库中（针对内容库）4）是否添加在目录中（针对目录库） 代码：Code/** * 1、创建一个article对象 * 2、把article对象转化成document对象 * 3、创建一个IndexWriter对象 * 4、把document对象加入到索引库中 */ @Test public void createIndex() throws Exception&#123; //1.创建IndexWriter对象,参数需要：索引库，分分词器，存储的最大长度 //索引库 Directory directory = FSDirectory.open(new File(&quot;./indexDir&quot;)); //分词器 Analyzer analyzer=new StandardAnalyzer(Version.LUCENE_30); /** * directory指向了索引库的路径 &quot;./indexDir&quot; * analyzer 分词器 把title,content的内容分词后的内容放入到目录中 * MaxFieldLength 限制每一个字段往索引库中存放的大小 */ IndexWriter indexWriter = new IndexWriter(directory, analyzer, MaxFieldLength.LIMITED); //2.准备需要存储的内容 article article = new article(); article.setId(1L); article.setName(&quot;lucene可以做搜索引擎&quot;); article.setContent(&quot;baidu,google可以快速查询用户所需的内容&quot;); //3.准备document对象 Document document = new Document(); //4.添加内容 /** * 第一个参数 * 放入到索引库中的name的名称&quot;id&quot; * 第二个参数 * 放入到索引库中的value：id的值 * 第三个参数 * Store * YES 该字段向内容库中存储 * no 该字段不向内容库中存储 * 第四个字段 * Index * no 不向目录库中存储 * NOT_ANALYZED 存储，但是不分词 * ANALYZED 存储，分词 */ document.add(new Field(&quot;id&quot;, article.getId().toString(), Store.YES, Index.ANALYZED)); document.add(new Field(&quot;title&quot;, article.getName(), Store.YES, Index.ANALYZED)); document.add(new Field(&quot;content&quot;, article.getContent().toString(), Store.YES, Index.ANALYZED)); //indexwriter调用写方法写 indexWriter.optimize(); indexWriter.addDocument(document); indexWriter.close(); &#125; 向索引库中添加内容 4.4向索引库中查找内容分析： 查找数据需要IndexSearch类1）类的初始化IndexSearcher indexSearcher = new IndexSearcher(directory);创建参数需要传入一个索引库（你得告诉别人从哪个库找）2）查找的方法TopDocs topDocs = indexSearch.search(Query,N),返回一个TopDocs形参的代表的意思：Query对象：QueryParser queryParser = new QueryParser(Version.LUCENE_30, “title”, analyzer);Query query = queryParser.parse(“lucene”); 参数一：需要一个版本号 参数二：表示在那个字段进行检索，字段就是上述filed对象的key值 参数三：分词器，因为还需要对输入的查询信息进行分词queryParser.parse(“lucene”); 表示对那些内容进行查找N:表示查找n条记录返回值TopDocs: 可以把TopDocs这样理解，它就是根据关键词检索出来的 目录记录，后面根据这个目录记录去找对应的内容库中的document（关于目录库和内容库看图）int count = topDocs.totalHits; // 根据关键词计算出来的总的记录数 现在如何从TopDocs获取到我们想要的内容呢？搜索的过程为：先根据内容在目录库内找到索引值，再根据索引值到内容库里面找，找到对应的document如何获取document呢？ScoreDoc[] scoreDocs = topDocs.scoreDocs;Document document = indexSearcher.doc(scoreDoc.doc);scoreDoc.doc 根据关键词找到的索引得到的就是索引库目录中的索引值，根据这个值去内容库中找内容 向索引库中搜索内容代码：Code@Test public void searchIndex() throws Exception&#123; //1.创建一个IndexSearch对象 需要一个索引库 //索引库 Directory directory = FSDirectory.open(new File(&quot;./indexDir&quot;)); IndexSearcher indexSearcher = new IndexSearcher(directory); //2.创建一个Query对象 首先需要创建一个QueryParse对象 //分词器 Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30); QueryParser queryParser = new QueryParser(Version.LUCENE_30, &quot;title&quot;, analyzer); /* * 第一个参数 * 版本号 * 第二个参数 * 在哪个字段中进行检索 字段对应前面filed的key有几个 * 第三个参数 * 为分词器，在调用queryParser的parse方法的时候，需要对查询参数再次进行分词 */ Query query = queryParser.parse(&quot;lucene&quot;); //3.执行搜索 TopDocs topDocs = indexSearcher.search(query, 2); /* *可以把TopDocs这样理解，它就是根据关键词检索出来的 目录记录，后面根据这个目录记录去找对应的内容库中的document */ int count = topDocs.totalHits; // 根据关键词计算出来的总的记录数 /** * query参数 * 包含了一个分词器 * 包含了一个关键词 * n 查找前n条记录 * TopDocs==Top Documents 前一些Documents */ //4.得到document对象 ScoreDoc[] scoreDocs = topDocs.scoreDocs; ArrayList&lt;article&gt; articles = new ArrayList&lt;article&gt;(); for (ScoreDoc scoreDoc : scoreDocs) &#123; //Document document = new Document(); int doc = scoreDoc.doc; //scoreDoc.doc 根据关键词找到的索引 得到的就是索引库目录中的索引值，根据这个值去内容库中找内容 Document document = indexSearcher.doc(doc); article article = new article(); //Document转化成article的过程 article.setId(Long.parseLong(document.get(&quot;id&quot;))); article.setName(document.get(&quot;title&quot;)); article.setContent(document.get(&quot;content&quot;)); articles.add(article); &#125; for (article aa : articles) &#123; System.out.println(aa.getId()); System.out.println(aa.getName()); System.out.println(aa.getContent()); &#125; &#125; 总结步骤：1) 创建IndexSearchIndexSearcher indexSearcher = new IndexSearcher(directory);//索引库Directory directory = FSDirectory.open(new File(“./indexDir”));//分词器Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_30);2) 创建Query对象QueryParser queryParser = new QueryParser(Version.LUCENE_30, “title”, analyzer); 第一个参数 版本号 第二个参数 在哪个字段中进行检索 字段对应前面filed的key有几个 第三个参数 为分词器，在调用queryParser的parse方法的时候，需要对查询参数再次进行分词 Query query = queryParser.parse(&quot;lucene&quot;); 3) 进行搜索TopDocs topDocs = indexSearcher.search(query, 2);2表示返回的记录条数4) 获得总结果数和前N行记录ID列表int count = topDocs.totalHits; // 根据关键词计算出来的总的记录数5) 根据目录ID列表把Document转为为pojo并放入集合中。ScoreDoc[] scoreDocs = topDocs.scoreDocs;int doc = scoreDocs[i].doc;Document document = indexSearcher.doc(doc);说明：这个时候 indexSearcher.doc(doc)根据关键词找到的索引 得到的就是索引库目录中的索引值，根据这个值去内容库中找内容6) 循环出要检索的内容document.get(“id”)document.get(“title”)document.get(“content”) 5.封装重复代码 上述操作其实有许多重复代码，如索引库的创建，分析器的创建，pojo与Document对象之间的转换等都可以提取出公共的代码块，提取工具类。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"后台添加商品","slug":"taotao/taotao商城之添加商品","date":"2019-06-19T16:00:00.000Z","updated":"2019-06-18T06:30:34.076Z","comments":true,"path":"2019/06/20/taotao/taotao商城之添加商品/","link":"","permalink":"http://SlectRxz.github.io/2019/06/20/taotao/taotao商城之添加商品/","excerpt":"taotao商城后台管理中的添加商品，设计到回显商品种类、实现图片上传FastDFS服务器，以及商品修改、删除、上架和下架的实现。","text":"taotao商城后台管理中的添加商品，设计到回显商品种类、实现图片上传FastDFS服务器，以及商品修改、删除、上架和下架的实现。 商品的种类选择在实际应用中，当我们添加商品的时候，需要选择你添加商品的种类，如下图：但是商品的种类是我们从数据库中查询后返回给客户端显示，那么后台的逻辑如何实现呢？1.分析前端页面，找出url，请求参数，返回值类型等","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"后台商品列表查询","slug":"taotao/taotao商城之后台商品列表查询","date":"2019-06-17T16:00:00.000Z","updated":"2019-06-18T01:27:05.527Z","comments":true,"path":"2019/06/18/taotao/taotao商城之后台商品列表查询/","link":"","permalink":"http://SlectRxz.github.io/2019/06/18/taotao/taotao商城之后台商品列表查询/","excerpt":"taotao商城后台管理中的商品列表查询，主要涉及到dubbo、分页插件PageHelper的使用。","text":"taotao商城后台管理中的商品列表查询，主要涉及到dubbo、分页插件PageHelper的使用。需求：点击查询商品后将数据库中的商品查询后显示在前端页面上，如图所示：分析：由于我们无需开发前端页面，有需求可得出该功能的实现应该就是将数据库中的商品列表查询后返回给前台页面，但是前端请求的URL、请求的数据以及需要返回的数据格式，这个是我们需要由前端静态代码所分析出来的。（这个后台管理的前端页面是用EasyUI开发的，有点看不懂） 思路：先分析页面，看其URL以及需要传递什么数据，这样才方便去构造POJO去传递其中，我们需要考虑的是： 表现层需要接收什么数据（接收从前端页面传递过来的） 表现层需要返回什么类型的数据（前端页面需要什么类型的数据才能够正常显示） 前端页面所提交的URL，以get/post提交 当POJO构造完毕后，走持久层（dao）-&gt;服务层（service）-&gt;表现层(controller)","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"FastDFS介绍","slug":"taotao/FastDFS的配置","date":"2019-06-16T16:00:00.000Z","updated":"2019-08-04T06:44:20.190Z","comments":true,"path":"2019/06/17/taotao/FastDFS的配置/","link":"","permalink":"http://SlectRxz.github.io/2019/06/17/taotao/FastDFS的配置/","excerpt":"FastDFS服务器的介绍与使用（配置过于蛮烦）。","text":"FastDFS服务器的介绍与使用（配置过于蛮烦）。 什么是FastDFS？FastDFS是用c语言编写的一款开源的分布式文件系统。FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。 为什么要使用FastDFS？ 我们把静态资源文件存储在本地服务器也能正常访问啊，如放在Tomcat项目文件夹下，也能实现正常的访问。 但是当我们的系统超过1000并发后，需要使用nginx进行服务器的负载均衡（即使用多个服务器），用户访问就访问的nginx，nginx将求情转发给用于服务器Tomcat，但是有一种情况，张上用户上传图片，nginx分配给服务器A，然后服务器tomcat将图片存在其工程文件夹下，而李四访问这张图片的时候，nginx可能将请求转发给服务器B，但是由于图片存放在服务器A中，故将发生404错误。 上述问题出现在我们没有把图片放在同一的一个位置。 那么当我们专门使用一台服务器作为图片服务器呢？所有的图片访问都找这个专门的服务器picture。但是我们也可以使用tomcat作为静态资源服务器啊？为什么使用FastDFS服务器呢？原因：这台服务器的存储有上限，其扩容性不强。当这个服务器满容量后，若再加一个服务器其访问的URL将会相应的发生变化，而且如果这个服务器挂了，则相应的数据丢失。使用FastDFS的优点：使用FastDFS可以实现横向扩容，如果你的存储空间不够了，可以加服务器，它会对group进行集中管理。其运行在Linux下。其架构图如下： 服务端两个角色：Tracker：- 管理集群， tracker也可以实现集群。每个tracker节点地位平等。- 作用：引导客户端去哪台服务器存储数据，实际上是客户端与存储服务器直接进行通信的，并不需要通过Tracker进行中转。Storage：- 需要连接tracker端，定期报告自己的情况（是否活着，剩余容量，负载情况）- 分为多个组，每个组之间保存的文件是不同的。每个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有主从的概念。卷1、卷2、卷n是可以实现横向扩容的，向里面添加组服务器，且同一个组里面的文件是一样的，一台服务器挂了，还有别的服务器可以提供访问。（实现高可用）一台服务器很忙，可以将访问分配给其他服务器，实现负载均衡。文件上传其时序图： 客户端上传文件后存储服务器将文件ID返回给客户端，此文件ID用于以后访问该文件的索引信息。文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名。 group1/M00/02/44/shaudhuasduasd.jpg 组名：文件上传后所在的storage组名称，在文件上传成功后有storage服务器返回，需要客户端自行保存。 虚拟磁盘路径：storage配置的虚拟路径，与磁盘选项store_path*对应。如果配置了store_path0则是M00，如果配置了store_path1则是M01，以此类推。 数据两级目录：storage服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件。 文件名：与文件上传时不同。是由存储服务器根据特定信息生成，文件名包含：源存储服务器IP地址、文件创建时间戳、文件大小、随机数和文件拓展名等信息。（已经加密了） 文件上传实现步骤好了，上面的都是概念介绍，下面实现其文件的上传； 1向工程中加入jar包fastdfs_client-1.25.jar（此处是maven工程，直接导入fastdfs_client工程后maven insatll导入本地仓库 ） 2创建一个配置文件 配置文件内容tarcker_server=192.168.25.133:22122配置文件内容是FastDFS的IP地址 3加载配置文件ClientGlobal.init(path) 4创建一个TrackerClient对象TrackerClient trackerClient = new TrackerClient(); 5使用TrackerClient对象获得trackerserver对象TrackerServer trackerServer = trackerClient.getConnection(); 6创建一个storageServer为nullStorageServer storageServer=null; 7创建一个storageClient对象，参数为trackerserver、storageServerStorageClient storageClient=new StorageClient(trackerServer, storageServer); 8使用storageClient对象上传文件String[] upload_file=storageClient.upload_file(“D:/111/1.jpg”, “jpg”, null)参数三是原数据，文件的相关信息（修改日期、创建者等等）。Code@Test public void test() throws Exception&#123; //1.向工程中加入jar包 //2创建一个配置文件 配置文件内容tarcker_server=192.168.25.133:22122 //3加载配置文件 ClientGlobal.init(&quot;E:/javaWeb-kaoshi/workspaces_taotao/taotao-manager-web/src/main/resources/client.conf&quot;); //4创建一个TrackerClient对象 TrackerClient trackerClient = new TrackerClient(); //5使用TrackerClient对象获得trackerserver对象 TrackerServer trackerServer = trackerClient.getConnection(); //6创建一个storageServer为null StorageServer storageServer=null; //7创建一个storageClient对象，参数为trackerserver、storageServer StorageClient storageClient=new StorageClient(trackerServer, storageServer); //8使用storageClient对象上传文件 String[] upload_file = storageClient.upload_file(&quot;D:/111/1.jpg&quot;, &quot;jpg&quot;, null); for (String string : upload_file) &#123; System.out.println(string); &#125; &#125; 输出： group1 M00/00/00/wKgZhV0Hg-yAQPmPAACtd9REEP8664.jpg 工具类使用1.图片上传工具类在我们上传图片的时候，由于上述步骤很多步骤都是重复的，我们可以将其封装后变的简单一点。 Codepackage com.taotao.utils;import org.csource.common.NameValuePair;import org.csource.fastdfs.ClientGlobal;import org.csource.fastdfs.StorageClient1;import org.csource.fastdfs.StorageServer;import org.csource.fastdfs.TrackerClient;import org.csource.fastdfs.TrackerServer;public class FastDFSClient &#123; private TrackerClient trackerClient = null; private TrackerServer trackerServer = null; private StorageServer storageServer = null; private StorageClient1 storageClient = null; public FastDFSClient(String conf) throws Exception &#123; if (conf.contains(&quot;classpath:&quot;)) &#123; conf = conf.replace(&quot;classpath:&quot;, this.getClass().getResource(&quot;/&quot;).getPath()); &#125; ClientGlobal.init(conf); trackerClient = new TrackerClient(); trackerServer = trackerClient.getConnection(); storageServer = null; storageClient = new StorageClient1(trackerServer, storageServer); &#125; /** * 上传文件方法 * &lt;p&gt;Title: uploadFile&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param fileName 文件全路径 * @param extName 文件扩展名，不包含（.） * @param metas 文件扩展信息 * @return * @throws Exception */ public String uploadFile(String fileName, String extName, NameValuePair[] metas) throws Exception &#123; String result = storageClient.upload_file1(fileName, extName, metas); return result; &#125; public String uploadFile(String fileName) throws Exception &#123; return uploadFile(fileName, null, null); &#125; public String uploadFile(String fileName, String extName) throws Exception &#123; return uploadFile(fileName, extName, null); &#125; /** * 上传文件方法 * &lt;p&gt;Title: uploadFile&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * @param fileContent 文件的内容，字节数组 * @param extName 文件扩展名 * @param metas 文件扩展信息 * @return * @throws Exception */ public String uploadFile(byte[] fileContent, String extName, NameValuePair[] metas) throws Exception &#123; String result = storageClient.upload_file1(fileContent, extName, metas); return result; &#125; public String uploadFile(byte[] fileContent) throws Exception &#123; return uploadFile(fileContent, null, null); &#125; public String uploadFile(byte[] fileContent, String extName) throws Exception &#123; return uploadFile(fileContent, extName, null); &#125;&#125; 测试类：Code@Test public void testUtils() throws Exception&#123; FastDFSClient fastDFSClient = new FastDFSClient(&quot;E:/javaWeb-kaoshi/workspaces_taotao/taotao-manager-web/src/main/resources/client.conf&quot;); String uploadFile = fastDFSClient.uploadFile(&quot;D:/111/2.jpg&quot;, &quot;jpg&quot;, null); System.out.println(uploadFile); &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"SPring整合Dubbo+zookeeper","slug":"taotao/Dubbo架构的使用","date":"2019-06-02T16:00:00.000Z","updated":"2019-06-03T13:33:53.594Z","comments":true,"path":"2019/06/03/taotao/Dubbo架构的使用/","link":"","permalink":"http://SlectRxz.github.io/2019/06/03/taotao/Dubbo架构的使用/","excerpt":"在SSM框架中整合dubbo，zookeeper的使用以及分页插件pageHelper的使用。","text":"在SSM框架中整合dubbo，zookeeper的使用以及分页插件pageHelper的使用。 介绍dubbo DUBBO是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，是阿里巴巴SOA服务化治理方案的核心框架，每天为2,000+个服务提供3,000,000,000+次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的 数据访问框架(ORM) 是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的 Web框架(MVC) 是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 Dubbo就是资源调度和治理中心的管理工具。 Dubbo 就是类似于webservice的关于系统之间通信的框架，并可以统计和管理服务之间的调用情况（包括服务被谁调用了，调用的次数是如何，以及服务的使用状况）。 架构解释(重要！):上述架构我们可以这样去理解：类比我们去买房子，有供应商，需求用户和中间介绍人，而provider就是供应商(对应的是服务层提供服务)，而consumer就是需求用户(对应表现层的controller)；而中间商就是Registry，用户他们之间的牵线搭桥。Provider先去Registry注册，说我可以提供一个需求；Costomer像中间发出请求说我需要一个请求XXX;Registry再将Provider的信息给Consumer,Consumer再直接调用Provider。其中中间有监管部门监管(Monitor)。 节点角色说明：• Provider: 暴露服务的服务提供方。 就是服务提供者service• Consumer: 调用远程服务的服务消费方。服务的调用者（Controller）先到注册中心订阅• Registry: 服务注册与发现的注册中心。 相当于中介了• Monitor: 统计服务的调用次调和调用时间的监控中心。（非必须）• Container: 服务运行容器。 服务发布需要一个容器，这里使用的是Spring dubbo环境搭建(已经搭建完毕的小伙伴可以忽略)在服务层和表现层中添加dubbo依赖Code&lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;!-- 排除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.jboss.netty&lt;/groupId&gt; &lt;artifactId&gt;netty&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; 关于服务层的发布和表现层的请求配置在后面给出。 zookeeper 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。使用dubbo-2.3.3以上版本，官方建议使用zookeeper作为注册中心。Zookeeper是Apacahe Hadoop的子项目，是一个树型的目录服务，支持变更推送，适合作为Dubbo服务的注册中心，工业强度较高(稳定性好)，可用于生产环境，并推荐使用。 zookeeper环境搭建（本例运行在Linux环境下）(已经搭建完毕的小伙伴可以忽略) 第一步：安装jdk第二步：解压缩zookeeper压缩包第三步：将conf文件夹下zoo_sample.cfg复制一份，改名为zoo.cfg第四步：修改配置dataDir属性，指定一个真实目录，存放zook运行时存放的数据文件第五步：启动zookeeper：bin/zkServer.sh start关闭zookeeper：bin/zkServer.sh stop查看zookeeper状态：bin/zkServer.sh status 分页插件pageHelper Mybatis分页插件,如果你也在用Mybatis，建议尝试该分页插件，这个一定是最方便使用的分页插件。该插件目前支持Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库分页。 使用方式：第一步：把PageHelper依赖的jar包添加到工程中。第二步：在Mybatis的全局文件中配置SqlMapConfig.xml中配置拦截器插件:Code&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 第三步：在代码中使用1、设置分页信息：Code//获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); //紧跟着的第一个select方法会被分页,对后面的List&lt;Country&gt; list = countryMapper.selectIf(1);//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); 每次前端页面只需要传递第几页查询多少条数据即可。PageInfo page = new PageInfo(list);page.getTotal()常用 解决mapper映射文件不发布的问题 由于配置文件一般放在src/main/resource文件夹下，但是mapper.xml的映射文件放在src/main/java的文件夹下，会默认把该路径下的java文件生成的class文件拷贝到 项目名称/target/classes/文件夹下。但是不会去拷贝.xml文件，故需要我们自己去配置。 在dao工程下的pom文件中加入：Code&lt;build&gt; &lt;!-- 如果不配置mybatis的配置文件会漏掉 --&gt; &lt;!-- 注意：配置了此方式，原来的默认的资源拷贝行为将无效 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 解决静态文件无法加载的问题 为什么静态资源无法加载？因为我们在表现层的web.xml中定义的url拦截形式为“/”表示拦截所有的url请求，包括静态资源例如css、js等（由DispatcherServlet拦截）。所以需要在springmvc.xml中添加资源映射标签： Code&lt;mvc:resources location=&quot;/WEB-INF/js/&quot; mapping=&quot;/js/**&quot;/&gt;&lt;mvc:resources location=&quot;/WEB-INF/css/&quot; mapping=&quot;/css/**&quot;/&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"聚合工程项目建立","slug":"taotao/项目的建立","date":"2019-05-31T16:00:00.000Z","updated":"2019-06-03T13:34:27.097Z","comments":true,"path":"2019/06/01/taotao/项目的建立/","link":"","permalink":"http://SlectRxz.github.io/2019/06/01/taotao/项目的建立/","excerpt":"淘淘商城的架构搭建，设计多个工程之间的依赖。","text":"淘淘商城的架构搭建，设计多个工程之间的依赖。 此文在于总结所学，可能较为繁琐，但都是心得体会。 分布式服务框架引入首先，有一个问题，那就是为什么要引入分布式架构？其次，分布式架构相比传统架构有什么区别？先说传统架构：存在的问题： 1、功能耦合度高 2、系统维护成本高 3、如果并发量大，无法解决高并发的问题分布式架构：将系统按照功能拆分成为独立的工程，比如说以前我们将持久层、服务层、表现层写在一个工程中，但是当我们将其拆分成为单个独立的工程，其使用接口进行通信，降低模块之间的耦合度。当然，这个例子并不能代表分布式架构。 分布式架构：把系统按照模块拆分成多个子系统；多个子系统相互协作才能完成业务流程系统之间需要进行通信。 优点：1、把模块拆分，使用接口通信，降低模块之间的耦合度。2、把项目拆分成若干个子项目，不同的团队负责不同的子项目。3、增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。4、可以灵活的进行分布式部署。缺点：1、系统之间交互需要使用远程通信，需要开发接口，增加工作量。2、各个模块有一些通用的业务逻辑无法公用。 SOA的架构引入 SOA：Service Oriented Architecture面向服务的架构。也就是把工程都拆分成服务层工程、表现层工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。工程都可以独立部署。 工程的建立项目的搭建使用Maven优点：Jar包的管理工程之间的依赖管理自动打包统一的版本的控制。 注：maven的install可以将项目本身编译并打包到本地仓库，这样其他项目引用本项目的jar包时不用去私服上下载jar包，直接从本地就可以拿到刚刚编译打包好的项目的jar包，很灵活，避免每次都需要重新往私服发布jar包的痛苦 Maven的常见打包方式：jar、war、pomPom工程一般都是父工程，管理jar包的版本、maven插件的版本、统一的依赖管理。聚合工程。Codetaotao-parent：父工程，打包方式pom，管理jar包的版本号。 | 项目中所有工程都应该继承父工程。 |--taotao-common：通用的工具类通用的pojo,util。打包方式jar |--taotao-manager：服务层工程。聚合工程。Pom工程 |--taotao-manager-dao：打包方式jar |--taotao-manager-pojo：打包方式jar |--taotao-manager-interface：打包方式jar |--taotao-manager-service：打包方式：war (为了发布服务的方便) |--taotao-manager-web：表现层工程(只是跟页面打交道)。打包方式war 具体步骤不一一列出，下面几个是我觉得注意的地方：1.maven项目的对应的文件夹结构：Code|----src | |----main | | |----java ——存放项目的.java文件 | | |----resources ——存放项目资源文件，如spring, hibernate配置文件 | |----test | | |----java ——存放所有测试.java文件，如JUnit测试类 | | |----resources ——存放项目资源文件，如spring, hibernate配置文件 |----target ——项目输出位置 |----pom.xml ----用于标识该项目是一个Maven项目 其中pom.xmlCode&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!--所有的Maven项目都必须配置这四个配置项--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--groupId指的是项目名的项目组，默认就是包名--&gt; &lt;groupId&gt;cn.zang.maven.hello&lt;/groupId&gt; &lt;!--artifactId指的是项目中的某一个模块，默认命名方式是&quot;项目名-模块名&quot;--&gt; &lt;artifactId&gt;hello-first&lt;/artifactId&gt; &lt;!--version指的是版本，这里使用的是Maven的快照版本--&gt; &lt;version&gt;SNAPSHOT-0.0.1&lt;/version&gt;&lt;/project&gt;pom.xml文件的节点元素说明： &lt;project&gt; pom文件的顶级节点 &lt;modelVersion&gt; object model版本，对Maven2和Maven3来说，只能是4.0.0 &lt;groupId&gt; 项目创建组织的标识符，一般是域名的倒写 &lt;artifactId&gt; 定义了项目在所属组织的标识符下的唯一标识，一个组织下可以有多个项目 &lt;version&gt; 当前项目的版本，SNAPSHOT，表示是快照版本，在开发中 &lt;packaging&gt; 打包的方式，有jar、war、ear等 &lt;name&gt; 项目的名称 &lt;url&gt; 项目的地址 &lt;properties&gt; 属性配置，比如：&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;dependencies&gt; 构建项目依赖的jar 2.不同工程之间的依赖关系在taotao-manager是一个聚合工程，创建了四个子模块，这样做的好见博客https://blog.csdn.net/yuanxiaojun1990/article/details/50359059,其中dao需要依赖pojo，interface需要依赖pojo，而service需要依赖interface，dao;(可以结合SSM框架开发经验想想为什么这么依赖)。 common依赖pojo manage-web依赖interface；（直接调用接口） 3.tomcat的插件的配置 目的：设置访问路径和端口号。注：如果是聚合工程，则放在父工程的pom下。Code&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb实战","slug":"javaWeb实战","permalink":"http://SlectRxz.github.io/tags/javaWeb实战/"}]},{"title":"Jquery","slug":"java基础/JQuery","date":"2019-05-21T16:00:00.000Z","updated":"2019-08-05T12:02:51.670Z","comments":true,"path":"2019/05/22/java基础/JQuery/","link":"","permalink":"http://SlectRxz.github.io/2019/05/22/java基础/JQuery/","excerpt":"JQuery介绍，包括load(),get(),post()以及赋值等方法。","text":"JQuery介绍，包括load(),get(),post()以及赋值等方法。 1.JQuery是什么 JQuery 是 javascript 的一个框架集合 ， 并不是什么新的技术。 2.Jquery有什么用Code- 写少代码,做多事情【write less do more】- 免费，开源且轻量级的js库，容量很小 注意：项目中，提倡引用min版的js库- 兼容市面上主流浏览器，例如 IE，Firefox，Chrome 注意：jQuery不是将所有JS全部封装，只是有选择的封装- 能够处理HTML/JSP/XML、CSS、DOM、事件、实现动画效果，也能提供异步AJAX功能- 文档手册很全，很详细- 成熟的插件可供选择- 提倡对主要的html标签提供一个id属性，但不是必须的- 出错后，有一定的提示信息- 不用再在html里面通过&lt;script&gt;标签插入一大堆js来调用命令了 3.Ajax与JQuery 1、JS是一门前端语言。2、Ajax是一门技术，它提供了异步更新的机制，使用客户端与服务器间交换数据而非整个页面文档，实现页面的局部更新。3、jQuery是一个框架，它对JS进行了封装，使其更方便使用。jQuery使得JS与Ajax的使用更方便 4.使用：1.引用JQuery.js文件 Code&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; 2.常用方法.load() $(“#div01”).load(“userservlet”);解释：找到页面id为div01的标签，再加载路径为userservlet的文件，这里指servlet路径。 $(“#div01”) 相当于JavaScript中的document.getElementById(“div01”) $.get(url，function(data){}); 一get请求的方式向服务器传输数据，可以不加function()无需参数返回。若需添加请求的参数，直接添加在URL上，例如”usernameServlet?name=”eric”;若需要返回值，则添加一个数据回调函数 $.post(url,data,callback); 已post方式向服务器提交数据，并返回url:所处理的控制类的路径data：像服务器传递的数据，其格式为：{name:”zhangsan”,age=”18”}callback:获取服务器返回的回调函数，格式为function(data,status){},status表示状态，200表示成功。 eg:Code$.post(&quot;&lt;%=basePath%&gt;customer/update.action&quot;,$(&quot;#edit_customer_form&quot;).serialize(),function(data)&#123; if(data==&quot;1&quot;)&#123; alert(&quot;客户信息更新成功！&quot;); &#125;else&#123; alert(&quot;客户信息更新失败！&quot;); &#125; window.location.reload(); &#125;);函数二：if(confirm(&apos;确实要删除该客户吗?&apos;)) &#123; $.post(&quot;&lt;%=basePath%&gt;customer/delete.action&quot;,&#123;&quot;id&quot;:id&#125;,function(data)&#123; if(data==&quot;1&quot;)&#123; alert(&quot;客户删除删除成功！&quot;); &#125;else&#123; alert(&quot;客户信息删除失败！&quot;); &#125; window.location.reload(); &#125;); &#125; 注意：上述有两个点：$(“form”).serialize() jQuery ajax()使用serialize()提交form数据,如果打印 $(“form”).serialize()的值，格式是：id=12&amp;name=”eric”&amp;age=18&amp;city=”aa”…….那么，问题来了，我们在服务器的COntroller中应当如何去接收呢？用@ResponseBody接收confirm(‘’) 在JavaScript中共有三种弹出框（alert，confirm，prompt） 1.alert就是一个警告消息框。 2.confirm（“你想让用户确认的信息”）确认消息框首先：confirm 方法的返回值为 true 或 false 3.prompt() 提示消息框用户可以在段输入一个答案来响应您的提示，返回一个用户的输入值 .val(),.html(),.text() JQuery获取标签的值和赋值的方法下面说一下三者之间的区别： $(“#div01”).val() val(),表示获取id为div01标签中的value值； val(“aaa”)针对带有value属性的元素进行赋值， 其实就是给该元素的 value赋值aaa $(“#div01”).html() .html()获取获取id为div01标签体中的值 .html(“”《option value=’’&gt;””)针对某一个元素，可以使用元素左右包括起来一段值的元素赋值 。如：.html(“《font》 《/font》”) $(“#dov01”).text() .text()作用同html，只是一个支持html代码 .text(“aaaaaa”)该方法针对那些可以在两个标签中写值的赋值工作 。如 ：《div》aaaaaaaa《/div》 $.ajax() 提层实现基于Ajax的使用，关键在于内部的参数如何写，这里直接上代码 Codefunction editCustomer(id) &#123;$.ajax(&#123; type:&quot;get&quot;, url:&quot;&lt;%=basePath%&gt;customer/edit.action&quot;, data:&#123;&quot;id&quot;:id&#125;, success:function(data) &#123; $(&quot;#edit_cust_id&quot;).val(data.cust_id); $(&quot;#edit_customerName&quot;).val(data.cust_name); $(&quot;#edit_customerFrom&quot;).val(data.cust_source) $(&quot;#edit_custIndustry&quot;).val(data.cust_industry) $(&quot;#edit_custLevel&quot;).val(data.cust_level) $(&quot;#edit_linkMan&quot;).val(data.cust_linkman); $(&quot;#edit_phone&quot;).val(data.cust_phone); $(&quot;#edit_mobile&quot;).val(data.cust_mobile); $(&quot;#edit_zipcode&quot;).val(data.cust_zipcode); $(&quot;#edit_address&quot;).val(data.cust_address); &#125; &#125;);&#125; 以上有一个点，那就是返回的数据data，data是有Controller层使用@ResponseBody直接将一个对象以Json的形式返回的。 #案例1.仿百度提示 需求：在我们使用百度的时候，往往在输入几个字符后，它就会给我们一个提示了，那么前端页面是如何实现响应的呢？ 思路：：使用.keyup获取键盘弹起的事件，然后获取输入框的值，即每当键盘弹起后，就获取此时输入框的值，得到输入框的值后将数据发送（Post）到Controller层，Controller调用service层-&gt;持久层-&gt;获取数据库的信息，再将其返回前端页面。 Code&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;src=&quot;../js/baidu.js&quot;&gt;&lt;/script&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body background=&quot;../105.jpg&quot;&gt;&lt;center&gt; &lt;h2&gt;百度一下&lt;/h2&gt; &lt;input type=&quot;text&quot; id=&quot;word&quot; style=&quot;width:500px;height:50px&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;搜搜&quot; style=&quot;width:80px;height:56px&quot;/&gt; &lt;div id=&quot;div01&quot; style=&quot;position:relative;left:-43px; width:500px;height:300px;border: 1px solid blue;display: none&quot;&gt;&lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; js:Code//入口函数 以前是 $(document).ready(fuction()&#123;&#125;)//获取键盘弹起的事件$(function()&#123; $(&quot;#word&quot;).keyup(function() &#123; //获取输入框的信息，再上传 // alert(&quot;asd&quot;); var word=$(this).val(); //alert(word); $.post(&quot;/AjaxAndJQuery/findServlet&quot;,&#123;words:word&#125;,function(data,status)&#123; //alert(data); //返回的data是一个jsp页面，现在我们把它放在指定的div中 if(word==&quot;&quot;)&#123; $(&quot;#div01&quot;).hide(); &#125;else&#123; $(&quot;#div01&quot;).show(); $(&quot;#div01&quot;).html(data); &#125; &#125;); &#125;)&#125;); Controller(这里使用servlet)：Codeprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //获取数据，查询数据库，返回数据值 request.setCharacterEncoding(&quot;utf-8&quot;); String word = request.getParameter(&quot;words&quot;); // findDao findDaoImpl = new findDaoImpl(); List&lt;String&gt; list = findDaoImpl.findInformation(word); //打印从数据库获取的内容 for (String news : list) &#123; System.out.println(news); &#125; request.setAttribute(&quot;words&quot;, list); response.setContentType(&quot;text/html;charset=utf-8&quot;); /** * 谁请求，它就把页面返回给谁，一般我们都是用浏览器去访问，它就把页面返回给浏览器 * 当我用JQuery去访问，它就把数据返回给JQuery，放在data数据里面 */ request.getRequestDispatcher(&quot;/JQueryFind/list.jsp&quot;).forward(request, response); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 注意：此处返回的是一个jsp页面，也就是说，在JQuery中的data是一个jsp页面list.jspCode&lt;body&gt; &lt;table style=&quot;width:500px&quot;&gt; &lt;c:forEach items=&quot;$&#123;words&#125;&quot; var=&quot;word&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;word&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt; #案例2.省市联动 需求：当我们在注册时，可能会出现选城市的情况，比如当你province选择湖北后，对应的city就自动刷新为湖北下面的城市，那么其前端页面的逻辑是如何实现的呢？ 思路： 首先找到省份元素的标签，然后根据.change事件，当其发生改变时，将其value值通过$.post()发送至Controller层，控制层返回结果（以XML或Json）的方式。 下面介绍第一种：Controller层通过XML与前端页面 Controller(servlet实现)Codeprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //1.获取参数 int pic = Integer.parseInt(request.getParameter(&quot;pic&quot;)); //2.获取城市列表 cityDao cityImpl = new cityDaoImpl(); List&lt;city&gt; findCity = cityImpl.findCity(pic); //3.将其返回 //已XML的形式返回 XStream xstream=new XStream(); //设置类别名 xstream.alias(&quot;city&quot;, city.class); //将类成员作为属性 xstream.useAttributeFor(city.class, &quot;pic&quot;); String xml = xstream.toXML(findCity); //设置返回格式 response.setContentType(&quot;text/xml;charset=utf-8&quot;); response.getWriter().write(xml); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 注意： XStream xstream=new XStream();将对象转换为XML的形式或者XML转为对象的格式。具体使用找了一篇写的比较详细的博客： https://www.cnblogs.com/mengfanrong/p/5023770.html JS:Code$(function()&#123; //1.找到省份元素，一旦发生改变，就去请求该省份的元素 $(&quot;#province&quot;).change(function()&#123; //获得province的value var pic=$(this).val(); //post请求 $.post(&quot;/AjaxAndJQuery/findCity&quot;,&#123;pic:pic&#125;,function(data,status)&#123; //有一个数据回调 status表示返回的状态值，200表示ok //返回的是一个XML文档，需要的是其中的&lt;name&gt;标签中的值 /* * &lt;city pic=&quot;2&quot;&gt; &lt;name&gt;惠州&lt;/name&gt; &lt;/city&gt; &lt;city pic=&quot;2&quot;&gt; &lt;name&gt;梅州&lt;/name&gt; &lt;/city&gt; */ //清空以前查询过的值 $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos;&gt;-请选择 -&quot;); $(data).find(&quot;city&quot;).each(function()&#123; //表示遍历出来的每一个元素都走这一个方法，遍历一次city，就执行一次fuction方法 //.find(&quot;city&quot;)得到所有的city，然后遍历 //var pic=$(this).children(&quot;&quot;) var name=$(this).children(&quot;name&quot;).text(); //alert(name); //在手册添加栏可以查到 $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&apos;&gt;&quot;+name); &#125;); &#125;); &#125;);&#125;) jsp:Code&lt;body&gt; 省份: &lt;select name=&quot;province&quot; id=&quot;province&quot;&gt; &lt;option value=&quot;&quot;&gt;-请选择 - &lt;option value=&quot;1&quot;&gt;湖北 &lt;option value=&quot;2&quot;&gt;广东 &lt;option value=&quot;3&quot;&gt;山东 &lt;option value=&quot;4&quot;&gt;河南 &lt;/select&gt; 城市: &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt; &lt;option value=&quot;&quot;&gt;-请选择 - &lt;/select&gt;&lt;/body&gt; 方式二：COntroller通过Json与前端页面交互说明：可以直接采用以下方式（@ResponseBody）Code@RequestMapping(&quot;edit&quot;) @ResponseBody /** * jsp页面中直接接收一个json串，所以直接将对象转换成json数据格式 * @param id * @return */ public Customer edit(Integer id)&#123; Customer customer = customerService.getCustomerById(id); return customer; &#125; 但是由于我的案例是使用servlet写的，即需拼装Json串（可以手动拼装或者通过工具类）这里采用的是 JSONArray jsonArray = JSONArray.fromObject(findCity); servlet:Codeprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; try &#123; //1.获取参数 int pic = Integer.parseInt(request.getParameter(&quot;pic&quot;)); //2.获取城市列表 cityDao cityImpl = new cityDaoImpl(); List&lt;city&gt; findCity = cityImpl.findCity(pic); //3.将其返回 //已Json的形式返回 JSONArray jsonArray = JSONArray.fromObject(findCity); String json = jsonArray.toString(); System.out.println(json); //设置返回格式 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(json); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; js:Code$(function()&#123; //1.找到省份元素，一旦发生改变，就去请求该省份的元素 $(&quot;#province&quot;).change(function()&#123; //获得province的value var pic=$(this).val(); //post请求 $.post(&quot;/AjaxAndJQuery/findCityJson&quot;,&#123;pic:pic&#125;,function(data,status)&#123; //有一个数据回调 status表示返回的状态值，200表示ok /** * 返回的data是json形式的字符串 * [&#123;&quot;name&quot;:&quot;广州&quot;,&quot;pic&quot;:2&#125;,&#123;&quot;name&quot;:&quot;深圳&quot;,&quot;pic&quot;:2&#125;,&#123;&quot;name&quot;:&quot;惠州&quot;,&quot;pic&quot;:2&#125;,&#123;&quot;name&quot;:&quot;梅州&quot;,&quot;pic&quot;:2&#125;] */ //清空以前查询过的值 $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos;&gt;-请选择 -&quot;); //遍历data，获取到【】中的&#123;&#125;内容，在通过 city.属性 的方式访问其值，其中city自定义，相当于给&#123;&#125;整体封装成一个对象了 $(data).each(function(index,city)&#123; $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&apos;&gt;&quot;+city.name); &#125;); &#125;,&quot;json&quot;); &#125;);&#125;) jsp:同上","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Ajax","slug":"java基础/Ajax","date":"2019-05-18T16:00:00.000Z","updated":"2019-12-20T12:03:47.122Z","comments":true,"path":"2019/05/19/java基础/Ajax/","link":"","permalink":"http://SlectRxz.github.io/2019/05/19/java基础/Ajax/","excerpt":"Ajax的使用，内部原理的介绍，get/Post提交数据","text":"Ajax的使用，内部原理的介绍，get/Post提交数据 1.Ajax是什么 全称：Asynchronous Javascript And XML（异步JavaScript和xml） 并非新的技术，而实把原有的技术整合到一起： 1.使用CSS和XHTML来表示。 2.使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。2.Ajax有什么用 网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好(例如：当我们提交form表单的时候)。就是为了解决局部刷新的问题。保持其他部分不动，只刷新某些地方。 3.内部原理诚如我们前面所说的， Ajax 并不是一项新技术。而是包装了现有的技术，然后使用他们来完成工作而已。 那么现在给大家举个例子， 还是以咱们的判断用户名是否已被注册为例。 传统方式： 1. 输入用户名， 2. 点击一个按钮，校验。 3. 把数据提交给服务器 4. 服务器在后台帮助我们完成校验，并且反馈信息。 5. 我们在浏览器上提示用户，给出结果 Ajax方式： ajax方式与前面的方式其实从要做的事情来说，是一样的。 ajax也没有牛到，不用去访问服务器就知道你的用户名是否已被占用。那么它是如何工作的呢? 通过JS 获取咱们的输入框文本内容 document.getElementById(“username”).value 通过XmlHttpRequest 去执行请求。 XmlHttpRequest 其实就是 XML + http + Request 的组合。 请求结束后，收到结果， 再使用 js 去完成提示。 可以在顺便配合 css 样式来增加提示效果。 4.使用前面介绍的都是概念性的，只需要知道Ajax是干啥的就欧克了（后面直接用Jquery）且提交数据有两种方式： 4.1 get方式 总结一下下面的代码内容（注释解释的已经很详细了）：总共分为三步: 1.创建XmlHttpRequest对象这部分创建的对象，由于需要针对不同的浏览器，需要做出判断，所以不用直接写，以后直接拷贝即可。 2.发送请求注： request对象通过第一步的XmlHttpRequest得到。request.open(“GET”,”/AjaxAndJQuery/demoServlet01?name=’eric’&amp;password=’123’”,true);request.send(); 3.响应服务器发送过来的数据 Code&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; //创建XmlHttpRequest对象 function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; //在发送请求的同时，获取服务器响应的内容 function get() &#123; //1.创建xmlhttprequest 对象 var request=ajaxFunction(); //2.发送请求 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ // request.open(&quot;GET&quot;,&quot;/AjaxAndJQuery/demoServlet01&quot;,true); //带数据的去请求服务器 request.open(&quot;GET&quot;,&quot;/AjaxAndJQuery/demoServlet01?name=&apos;eric&apos;&amp;password=&apos;123&apos;&quot;,true); request.send(); //3.响应服务器发送过来的数据 /* 注册监听的意思，有点像注册一个监听器，一会准备的状态发生了改变 那就执行=右边的方法 */ request.onreadystatechange=function() &#123; //前半段表示readyState==4求已完成，且响应已就绪 //status==200 if (request.readyState==4 &amp;&amp; request.status==200) &#123; //显示响应的信息 alert(request.responseText); &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot; onclick=&quot;get()&quot;&gt;Ajax通过Get发送数据&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.1 post方式 Post请求 和 Get请求基本相似，区别就在于 数据传输方式不同。 Get方式是直接在地址的后面拼接的。 但是Post的方式是通过send 方法传输过去的。 并且还要设置一个请求头。 同上总结一下以下代码： 1.创建XmlHttpRequest对象 2.发送请求不携带数据：request.open(“POST”,”/AjaxAndJQuery/demoServlet01”,true);request.send();携带数据：request.open(“POST”,”/AjaxAndJQuery/demoServlet01”,true);request.setRequestHeader(“Content-type”,”application/x-www-form-urlencoded”);request.send(“name=eric&amp;password=123456”); 3.接收数据 Code&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//创建XmlHttpRequest对象function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; function Post() &#123; //1.注册XmlHttpRequest对象 var request=ajaxFunction(); //2.发送数据 request.open(&quot;POST&quot;,&quot;/AjaxAndJQuery/demoServlet01&quot;,true); //request.send(); //注意：如果我需要带参数请求呢？如果需要带参访问，则需要加上这两行 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //解释：如果使用的是POST方式带数据，那么这里要添加请求头，并说明提交的数据类型是一个经过URL编码的form表单数据 request.send(&quot;name=eric&amp;password=123456&quot;); //3.接收数据 /* 注册监听的意思，有点像注册一个监听器，一会准备的状态发生了改变 那就执行=右边的方法 */ request.onreadystatechange=function() &#123; //前半段表示readyState==4求已完成，且响应已就绪 //status==200 if (request.readyState==4 &amp;&amp; request.status==200) &#123; //显示响应的信息 alert(request.responseText); &#125; &#125; &#125;&lt;/script&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;&quot; onclick=&quot;Post()&quot;&gt;Ajax通过Post发送数据&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.2获取服务器端的响应 数据提交到的两种请求Get 和 Post基本上都会使用后， 就应该想想获取数据的问题了。 前面我们都一直很无私的往服务器提交数据， 那么服务器返回的那些数据，我们又该怎么通过Ajax去拿呢?这里就要靠xmlhttprequest的事件 onreadystatechange ， 这是用来监听我们请求的一些状态， 比如： 成功了还是失败了。 如果成功，想获取数据，得靠xmlhttprequest的responseText 或 responseXML 属性 Code/* 注册监听的意思，有点像注册一个监听器，一会准备的状态发生了改变 那就执行=右边的方法 */ request.onreadystatechange=function() &#123; //前半段表示readyState==4求已完成，且响应已就绪 //status==200 if (request.readyState==4 &amp;&amp; request.status==200) &#123; //显示响应的信息 alert(request.responseText); &#125; &#125; 案例：校验用户名 需求：在登录页面，当我输入用户名的时候，能够去数据库判断该用户名是否存在。 直接上代码了…Controller类 Codeprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取从页面传输过来的name，调用持久层的方法，将返回结果传输到表现层 request.setCharacterEncoding(&quot;UTF-8&quot;); //作用是设置对客户端请求进行重新编码的编码。 String username = request.getParameter(&quot;username&quot;); userDao dao = new userDaoImpl(); System.out.println(username); try &#123; Long result = dao.getUserName(username); response.getWriter().println(result); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 前端页面Code&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//创建XmlHttpRequest对象 function ajaxFunction()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; function checkUserName() &#123; //1.获取XMLHttpRequest对象 var request=new ajaxFunction(); //获取文本框的name值 var name=document.getElementById(&quot;name&quot;).value; //2.发送消息 /*想尝试一下已get方式，但是失败了 String str=&quot;/AjaxAndJQuery/userServlet?username=&quot;+&quot;&apos;&quot;+name+&quot;&apos;&quot;; alert(str); request.open(&quot;GET&quot;,str,true); request.send(); */ request.open(&quot;POST&quot;,&quot;/AjaxAndJQuery/userServlet&quot;,true); //注意：如果我需要带参数请求呢？如果需要带参访问，则需要加上这两行 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //解释：如果使用的是POST方式带数据，那么这里要添加请求头，并说明提交的数据类型是一个经过URL编码的form表单数据 request.send(&quot;username=&quot;+name); //3.接收数据 /* 注册监听的意思，有点像注册一个监听器，一会准备的状态发生了改变 那就执行=右边的方法 */ request.onreadystatechange=function() &#123; //前半段表示readyState==4求已完成，且响应已就绪 //status==200 if (request.readyState==4 &amp;&amp; request.status==200) &#123; //显示响应的信息 //alert(request.responseText); var result=request.responseText; if(result==1)&#123; document.getElementById(&quot;span01&quot;).innerHTML=&quot;&lt;font color=&apos;red&apos;&gt;该用户名已存在&lt;/font&gt;&quot;; &#125;else&#123; document.getElementById(&quot;span01&quot;).innerHTML=&quot;&lt;font color=&apos;green&apos;&gt;合法!&lt;/font&gt;&quot;; &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; onblur=&quot;checkUserName()&quot;&gt;&lt;span id=&quot;span01&quot;&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;简介&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"SpringMVC学习日志（4）","slug":"java/SpringMvc(4)","date":"2019-05-07T16:00:00.000Z","updated":"2019-12-20T12:05:03.860Z","comments":true,"path":"2019/05/08/java/SpringMvc(4)/","link":"","permalink":"http://SlectRxz.github.io/2019/05/08/java/SpringMvc(4)/","excerpt":"SpringMVC的异常处理器，拦截器，图片上传的实现(Tomcat的虚拟目录的设置)","text":"SpringMVC的异常处理器，拦截器，图片上传的实现(Tomcat的虚拟目录的设置) 在三次学习已经简单介绍了springmvc工程的搭建，springmvc的三大组件，参数绑定，@Controller返回值，下面介绍springmvc的功能配置，后续添加… 1.异常处理器 使用场景：在程序运行的时候，可能会出现异常，此时直接返回用户异常页面是及其不友好的，做一个全局异常处理器，处理所有没有处理过的运行时异常用于更友好地提示用户。 处理思路：系统中的异常包括两类：预期异常和运行时异常 RuntimeException，前者通过捕获异从而获取异常信息，或者通过测试减少运行时异常的发生。其中dao，service，Controller都用throws Exception向上抛出，最后有sringmvc前端控制器交由异常处理器去处理。HandlerExceptionResolver(异常处理器) 具体实现： 创建全局异常处理器 Codepublic class CustomerExceptionResolve implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handle, Exception e) &#123; // TODO Auto-generated method stub //响应用户错误提示 ModelAndView modelAndView = new ModelAndView(); String message=&quot;页面错误&quot;; //自定义异常，显示自定义信息 if(e instanceof MyException)&#123; message = ((MyException)e).getMessage(); &#125; //返回错误消息 modelAndView.addObject(&quot;msg&quot;, message); //响应错误提示页面 modelAndView.setViewName(&quot;error&quot;); return modelAndView; &#125;&#125; 配置异常处理器（springmvc.xml） Code&lt;!-- 配置全局异常处理器 --&gt;&lt;bean class=&quot;ctgu.utils.CustomerExceptionResolve&quot;/&gt; 测试 Code/** * 全局异常处理 * 包括自定义异常信息 * @throws MyException */ @RequestMapping(&quot;/error&quot;) public void MyError() throws MyException&#123;// int a=1/0; /** * 模拟商品查询不到的场景 * 这样的话，错误页面无需定义多个，而直接抛出exception,然后全局异常处理器接收后处理 */ if(true)&#123; throw new MyException(&quot;你查找的商品不存在&quot;); &#125; &#125; 2.拦截器 应用：springmvc的处理器拦截器类似于servlet中的过滤器Filter，用于处理器进行预处理和后处理 就是一个普通的类去继承HandlerInterceptor接口； afterCompletion():只要放行了都会执行 用于：处理异常，记录日志 postHandle():在控制器COntroller执行之后，返回ModelAndView视图，之前被执行 作用：设置或清理页面共用参数，比如标题栏共用 preHandle():在执行Controller方法之前时执行 作用：登录拦截，用户认证 Codepublic class UserIntercepter implements HandlerInterceptor &#123; /** * 只要放行了都会执行 * 用于：处理异常，记录日志 */ @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; // TODO Auto-generated method stub //System.out.println(&quot;afterCompletion执行...&quot;); &#125; /** * 在控制器COntroller执行之后，返回ModelAndView视图，之前被执行 * 作用：设置或清理页面共用参数，比如标题栏共用 */ @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; // TODO Auto-generated method stub //System.out.println(&quot;postHandle执行...&quot;); &#125; /** * 在执行Controller方法之前时执行 * 作用：登录拦截，用户认证 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception &#123; // TODO Auto-generated method stub //System.out.println(&quot;preHandle执行...&quot;); String name = (String) request.getSession().getAttribute(&quot;username&quot;); if(name!=null)&#123; //放行 //当我们输入其他URL的时候，必须判断用户是否完成登录，如果没有，必须返回登录页面 return true; &#125;else&#123; response.sendRedirect(request.getContextPath()+&quot;/user/toLogin.action&quot;); return false; &#125; &#125;&#125; springmvc.xml的配置：Code&lt;!-- 配置拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 配置拦截地址 --&gt; &lt;mvc:mapping path=&quot;/**/&quot;/&gt; &lt;!-- 配置不拦截地址 --&gt; &lt;mvc:exclude-mapping path=&quot;/user/*&quot;/&gt; &lt;bean class=&quot;ctgu.intercepter.UserIntercepter&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 说明：拦截器可以配置多个，即配置多个 mvc:interceptor，但是如果第一个拦截器preHandler没有放行（返回的是false），那其他的两个方法也不会执行，第二个拦截器的所有方法都不会执行，Controller也不执行了。问：当有两个即两个以上的拦截器存在时，afterCompletion()、postHandle()、preHandle()的执行顺序是如何的？ preHandle()按照拦截器定义的顺序调用 postHandle()按照拦截器定义逆序调用 afterCompletion()按照拦截器定义逆序调用 postHandle()在拦截器链内所有拦截器返回成功调用 afterCompletion()只有在preHandle返回true才调用 3.图片上传 配置虚拟目录 相当于配置了一个tomcat与本地磁盘的路径映射。 相当于在tomcat的server.xml中添加了一行 &lt;Context docBase=”springmvc03-mybatis” path=”/“reloadable=”true” source=”org.eclipse.jst.jee.server:springmvc03-mybatis”/&gt; 导jar包commons-fileupload-1.2.2.jarcommons-io-2.4.jar jsp页面 注意method一定要为”post”enctype=”multipart/form-data” Code&lt;form id=&quot;itemForm&quot; action=&quot;$&#123;pageContext.request.contextPath &#125;/updateItem.action&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;tr&gt; &lt;td&gt;商品图片&lt;/td&gt; &lt;td&gt; &lt;c:if test=&quot;$&#123;item.pic !=null&#125;&quot;&gt; &lt;img src=&quot;/pic/$&#123;item.pic&#125;&quot; width=100 height=100/&gt;&lt;br/&gt; &lt;/c:if&gt; &lt;input type=&quot;file&quot; name=&quot;pictureFile&quot;/&gt; &lt;/td&gt;&lt;/tr&gt; 图片上传处理代码Controller 思路： 拿到图片的名字，根据托图片名拿到其后缀名，再拼接一个图片的新的名字 将其写入磁盘，把图片的路径+名字（虚拟目录）写入数据库 在tomcat建立一个虚拟目录，因为前端页面标签显示 我们上传上去的图片，需要controller层对其做出处理： 1.将其保存在虚拟目录对应的目录，否则前端页面找不到； 2.给其一个新的名字（设计到获取其后缀，给一个唯一标识）并赋值给item.pic 说明：相当于将上传的图片保存在tomcat能找的到的目录 (前面映射的虚拟目录）,但是我们将其保存的时候给其一个新名字（防止重复），保存在数据库里面的是图片的名字。 Code@RequestMapping(value=&quot;/updateItem.action&quot;) public String updateItem(Model model,MultipartFile pictureFile,Item item) throws Exception&#123; //生成唯一标识作为图片id,uuid String name=UUID.randomUUID().toString(); //获取上传图片的名字 String originalFilename = pictureFile.getOriginalFilename(); //得到图片名后缀 String newname = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;)); //保存在磁盘 File file = new File(&quot;C:\\\\Users\\\\DELL\\\\Pictures\\\\java\\\\&quot;+name+newname); pictureFile.transferTo(file); //把图片名保存到数据库 item.setPic(name+newname); itemService.update(item); model.addAttribute(&quot;item&quot;, item); model.addAttribute(&quot;msg&quot;, &quot;修改商品成功&quot;); return &quot;itemEdit&quot;; &#125; 4.json交互5.Restful","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"SpringMVC学习日志（3）","slug":"java/SpringMVC(3)","date":"2019-04-28T16:00:00.000Z","updated":"2019-12-20T12:04:53.317Z","comments":true,"path":"2019/04/29/java/SpringMVC(3)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/29/java/SpringMVC(3)/","excerpt":"SpringMVC的参数绑定（get/post请求方式），@RequestMapping,Controller返回值。","text":"SpringMVC的参数绑定（get/post请求方式），@RequestMapping,Controller返回值。 引入：在实际开发中，控制层需要接收从浏览器提交的数据，通过该数据调用服务层去处理。那么，其是如何实现的呢？ 1.SrpingMvc的参数绑定 理解：当浏览器选择提交（GET/POST等）方式，究竟提交的是哪些东西？ 1）GET方式提交 CodeGET /day09/testMethod.html?name=eric&amp;password=123456 HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost:8080/day09/testMethod.htmlConnection: keep-alive a）地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。 b）GET提交参数数据有限制，不超过1KB。 c）GET方式不适合提交敏感密码。 d）注意： 浏览器直接访问的请求，默认提交方式是GET方式 2）POST方式提交CodePOST /day09/testMethod.html HTTP/1.1Host: localhost:8080User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://localhost:8080/day09/testMethod.htmlConnection: keep-alive name=eric&amp;password=123456 a）参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。 b）POST提交的参数数据没有限制。 c）POST方式提交敏感数据。 1.1基本参数类型(int,double,Integer,String…)1.可以使用request获取参数 View对象可以使用String返回值代替 【ModelMap：使用效果与Model相同，是Model接口的实现类，如果使用的是Model，springmvc会将其实例化】 【不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据】 Code @RequestMapping(&quot;itemEdit&quot;) public String queryItemById(HttpServletRequest request,Model model)&#123; Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;)); Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 但是我们一直使用request获取麻烦了，当请求参数名称与处理器形参参数名称一致时，将会请求参数进行绑定 (参数绑定)接收简单的参数传递（每次都从Request获取比较麻烦） 其他基本类型 String Integer Double Float。。 说明：对于布尔类型的参数，请求的参数值为true或false。或者1/0 请求url：Code* 处理器方法：```public String editItem(Model model,Integer id,Boolean status) 【注：必须要求处理器形参与表单中的提交name字段名称相同】后面介绍不同如何处理 Code@RequestMapping(&quot;itemEdit&quot;) public String queryItemById(int id,Model model)&#123; Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 那么问题来了，当我们处理器形参参数与请求参数不一致时咋办呢？ @RequestParam value:参数名字，需要与表单提交的名字相同 Code&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id123=$&#123;item.id&#125;&quot;&gt; required:默认true，Request请求中一定要有相应的参数，找不到将报错400 defaultValue:默认值，如果找不到给其一个默认值 Code@RequestMapping(&quot;itemEdit&quot;)public String queryItemById(@RequestParam(value=&quot;id123&quot;,required=true,defaultValue=&quot;1&quot;)int ids,Model model)&#123; Item item = itemService.queryItemById(ids); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;; &#125; 1.2 POJO类型(对象类型) 如果我们一次性提交的参数很多，我们可以使用一个对象来接收 要求：pojo对象的属性名与表单中的input的name一致 需求：将页面修改后的商品保存在数据库中 请求url：/updateItem.action 响应内容：给一个更新成功的提示 Code@RequestMapping(&quot;/updateItem.action&quot;)public String queryItemById(Model model,Item item)&#123; itemService.update(item); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //返回一个成功的信息 model.addAttribute(&quot;msg&quot;, &quot;商品信息更新成功&quot;); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; 1.3封装的POJO(自定义实体类)封装类： Codepublic class QueryVo &#123; private Item item; private String message; private List&lt;Item&gt; items; . . .get/set方法... 通过成员.属性来访问 需要更改表单的传递形式 Code@RequestMapping(&quot;/queryItem&quot;) public String queryItem(Model model,QueryVo item)&#123; //直接输出返回的封装对象的值 System.out.println(item.getItem().getName()); System.out.println(item.getItem().getPrice()); System.out.println(item.getMessage()); List&lt;Item&gt; list = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, list); return &quot;itemList&quot;;&#125; 对应的表单： Code&lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;item.name &#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price &#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot;pattern=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 1.4数组 情景：列表中每个商品前有一个checkbook，选中多个商品后点击删除按钮，把商品id传递给Controller，得到一个ids[] 可以直接接收或使用pojo属性接收，前者相当于是用一个数组接收了多个ids(JSP里的name属性)，后者是直接对应pojo的属性 Code@RequestMapping(&quot;/queryItem&quot;) public String queryItem(Model model,int[]ids,QueryVo vo)&#123; if(vo.getItem()!=null)&#123; System.out.println(vo); &#125; //问题：checkbox如果不选，则返回空指针异常，不知道咋整 //直接输出返回的封装对象的值 if(ids.length&gt;0 &amp;&amp; ids!=null)&#123; for (Integer integer : ids) &#123; System.out.println(integer); &#125; &#125; List&lt;Item&gt; list = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, list); return &quot;itemList&quot;;&#125; 1.5List、Map类型 场景需求：在类表中实现批量修改提交后的商品数据 定义pojo Codepublic class QueryVo &#123; private Item item; private String message; private List&lt;Item&gt; items; ... 修改jspname属性必须是list属性名+下表+元素属性注：此处日期类型无妨自动绑定，需要自定义参数绑定日期类型Code&lt;c:forEach items=&quot;$&#123;itemList &#125;&quot; var=&quot;item&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;$&#123;item.id &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].name&quot;value=&quot;$&#123;item.name &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].price&quot; value=&quot;$&#123;item.price &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].createtime&quot;value=&apos;&lt;fmt:formatDate value=&quot;$&#123;item.createtime&#125;&quot; pattern=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;&apos; /&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;items[$&#123;s.index&#125;].detail&quot; value=&quot;$&#123;item.detail &#125;&quot; /&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;&quot;&gt;修改&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; 返回的是一个List的集合，在jsp显示中，需要先将单个对象取出，故需要加下标访问。Code@RequestMapping(value=&quot;/queryItem&quot;,method=&#123;RequestMethod.POST&#125;) public String queryItem(Model model,QueryVo vo)&#123; List&lt;Item&gt; items = vo.getItems(); //注意：如果进行更新操作，那么需要更改jsp，把id传给vo中的item，不然没有主键无法更新 for (Item item : items) &#123; itemService.update(item); System.out.println(item); &#125; List&lt;Item&gt; itemList = itemService.queryItemList(); model.addAttribute(&quot;itemList&quot;, itemList); //这个return是跳转到/WEB-INF/下面的jsp页面，而不是跳转到控制器的URL因是个很 return &quot;itemList&quot;; &#125; 2.@RequestMapping 作用：通过@RequestMapping注解可以定义不同的处理器映射规则 URL路径映射value的值是数组，将多个url映射到同一个方法上 Code@RequestMapping(value=&#123;&quot;/itemList&quot;,&quot;/itemList2&quot;&#125;) 添加在类上 作用：指定通用请求前缀，可对url进行分类管理 此时访问地址为：http://localhost:8080/item/itemList.actionCode@RequestMapping(&quot;/item&quot;)public class ItemController &#123; //绑定请求地址 @RequestMapping(value=&#123;&quot;/itemList&quot;,&quot;/itemList2&quot;&#125;) public ModelAndView queryItemList()&#123; 限定请求方法Code@RequestMapping(value=&quot;/queryItem&quot;,method=&#123;RequestMethod.POST&#125;) 3.Controller的返回值3.1返回ModelAndViewCode@RequestMapping(&quot;/itemList&quot;) public ModelAndView queryItemList()&#123; List&lt;Item&gt; list = itemService.queryItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemList&quot;,list); //设置逻辑视图，告诉要返回到哪一个jsp modelAndView.setViewName(&quot;itemList&quot;); return modelAndView; &#125; 3.2返回void request 不经过视图解析器的，返回路径必须是全路径 Code@RequestMapping(&quot;/itemReturn1&quot;) public void MyReturn1(HttpServletRequest request,HttpServletResponse response) throws Exception&#123; //通过request请求转发,不会改变URL的地址栏 request.getRequestDispatcher(&quot;/WEB-INF/jsp/itemList.jsp&quot;).forward(request, response);&#125; response 通过response请求重定向 【注：】response.sendRedirect(“”); 参数是URL，即浏览器中的地址 response是响应，而Model返回，经过视图解析器，springmvc已经帮我们解码了,区别：一个是直接找到jsp，另外一个是找到一个控制类/ Code@RequestMapping(&quot;/itemReturn1&quot;) public void MyReturn1(HttpServletRequest request,HttpServletResponse response) throws Exception&#123; response.sendRedirect(&quot;/itemList.action&quot;); &#125; 3.3返回String 返回视图名字（逻辑视图名） 返回的通过视图解析器解析为物理视图地址/WEB-INF/jsp/itemList.jspreturn “itemList”- Model传递数据（向jsp） View对象可以使用String返回值代替 ModelMap：使用效果与Model相同，是Model接口的实现类，如果使用的是Model，springmvc会将其实例化 不管是Model还是ModelAndView，其本质都是使用Request对象向jsp传递数据】 Code@RequestMapping(&quot;itemEdit&quot;) public String queryItemById(HttpServletRequest request,Model model)&#123; Integer id = Integer.parseInt(request.getParameter(&quot;id&quot;)); Item item = itemService.queryItemById(id); //将商品数据放在模型中 model.addAttribute(&quot;item&quot;, item); //要返回的视图对象（返回到哪一个jsp页面） return &quot;itemEdit&quot;;&#125; redirect与forward 实现从一个控制器跳转到另外一个控制器 Code@RequestMapping(&quot;/itemReturn2&quot;) public String MyReturn2()&#123; //相当于走的视图解析器，直接访问jsp页面 //return &quot;itemList&quot;; //相当于走的视图解析器，直接访问jsp页面 //return &quot;forward:/WEB-INF/jsp/itemList.jsp&quot;; /** * 这种形式是直接跳转到另外控制器Controller */ return &quot;forward:/itemList2.action&quot;;//请求地址不会变 //return &quot;redirect:/itemList2.action&quot;; &#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"SpringMVC学习日志（2）","slug":"java/SpringMVC(2)","date":"2019-04-19T16:00:00.000Z","updated":"2019-12-20T12:04:45.077Z","comments":true,"path":"2019/04/20/java/SpringMVC(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/20/java/SpringMVC(2)/","excerpt":"SpringMVC整合Mybatis框架。","text":"SpringMVC整合Mybatis框架。 SpringMVC整合Mybatis思路：Dao层 SqlConfig.xml applicationContext-dao.xml 数据库连接池 SqlSessionFactroy对象 配置mapper包扫描 Service层 applicationContext-service.xml包扫描其，扫描@Service的注解 applicationContext-trans.xml配置事务 Controller层 springmvc.xml 包扫描器，扫描@Controller注解 配置注解驱动 配置视图解析器 配置全局异常处理器 配置多媒体处理器 配置拦截器 Web.xml 配置Spring容量监听器（找到spring文件） 配置前端控制器（springmvc） 配置文件1.SqlConfig.xml 空客文件（都在applicationContext中可以完成配置），但是必须要有。Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; 2.applicationContext-dao.xml 1.数据库连接池的配置；2.SqlSessionFactroy配置3.mapper包扫描Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis/SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.pojo&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置包扫描mapper --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;ctgu.mapper&quot; /&gt; &lt;!-- optional unless there are multiple session factories defined --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 3.applicationContext-service.xml 配置Service注解扫描Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 配置service扫描 --&gt; &lt;context:component-scan base-package=&quot;ctgu.service&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 4.applicationContext-trans.xml Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!-- 通知 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;tx:method name=&quot;query*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 切面 --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.itcast.ssm.service.*.*(..))&quot; /&gt; &lt;/aop:config&gt;&lt;/beans&gt; 5.springmvc.xml 1.包扫描器，扫描@Controller注解2.配置注解驱动3.配置视图解析器Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 配置@Controller处理器，包扫描器 --&gt; &lt;context:component-scan base-package=&quot;ctgu.controller&quot; /&gt; &lt;!-- =================配置处理器映射器=========================== --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; &lt;!-- =================配置处理器适配器============================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; &lt;!-- =================配置注解驱动，可以一次性代替上述过程============ --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- =================配置视图解析器================================ --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 配置视图响应后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!-- 比如逻辑视图名为itemList，最终返回的jsp地址为/WEB-INF/jsp/itemList.jsp --&gt; &lt;/bean&gt;&lt;/beans&gt; 6.Web.xml 1.spring容量监听器2.解决乱码3.前端控制器Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;springmvc-web&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 自动装配ApplicationContext.xml的配置信息。 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring提供的过滤器 解决乱码问题 --&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!-- 设置编码参是UTF8 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc-web&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; controller类 注意：Autowired是把ItemService注入（参考mybatis学习（2）中是必须要从spring获取接口，而在spring已经扫描了mapper包）Codepackage ctgu.controller;import ctgu.pojo.*;import ctgu.service.ItemService;//标识这是一个控制类@Controllerpublic class ItemController &#123; @Autowired private ItemService itemService; //绑定请求地址 @RequestMapping(&quot;/itemList&quot;) public ModelAndView queryItemList()&#123; List&lt;Item&gt; list = itemService.queryItemList(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;itemList&quot;,list); //设置逻辑视图，告诉要返回到哪一个jsp modelAndView.setViewName(&quot;itemList&quot;); return modelAndView; &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"SpringMVC学习日志（1）","slug":"java/SpringMVC(1)","date":"2019-04-18T16:00:00.000Z","updated":"2019-12-20T12:04:37.876Z","comments":true,"path":"2019/04/19/java/SpringMVC(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/19/java/SpringMVC(1)/","excerpt":"SpringMVC的入门程序的搭建，框架默认加载的三大组件","text":"SpringMVC的入门程序的搭建，框架默认加载的三大组件 SpringMVC与structs2的区别 springmvc入门程序的搭建 导入jar包 编写Controller类 控制类用于接收jsp页面（浏览器）传递过来的数据并加以处理，用于处理各个视图之间的跳转 Code @Controllerpublic class HelloController &#123; @RequestMapping(&quot;hello&quot;)//请求地址 public ModelAndView hello()&#123; System.out.println(&quot;hello springmvc....&quot;); //创建ModelAndView对象 响应用户的视图 ModelAndView mav = new ModelAndView(); //设置模型数据 mav.addObject(&quot;msg&quot;, &quot;hello springmvc...&quot;); //设置视图名字 jsp的目录 mav.setViewName(&quot;/WEB-INF/jsp/hello.jsp&quot;); return mav; &#125;&#125; 创建jsp页面 Code &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;我的输出：&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 配置springmvc核心配置文件 需要配置：1.配置@Controller包扫描器，用于扫描@Controller注解2.配置视图解析器，用于访问时设置默认的前缀和后缀3.配置处理器映射器HandlerMapping，用于处理用户的URL请求，返回一个处理器执行链，表示将由哪一个处理器处理。4.配置处理器适配器HandleAdapter(还不太清楚)5.配置注解驱动，可替代3、4两步，并支持json响应 Code &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&gt; &lt;!-- 配置@Controller处理器，包扫描器 --&gt; &lt;context:component-scan base-package=&quot;ctgu.controller&quot; /&gt; &lt;!-- =================配置处理器映射器=========================== --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; &lt;!-- =================配置处理器适配器============================--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; &lt;!-- =================配置注解驱动，可以一次性代替上述过程============ --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- =================配置视图解析器================================ --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!-- 配置视图响应后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;!-- 比如逻辑视图名为itemList，最终返回的jsp地址为/WEB-INF/jsp/itemList.jsp --&gt; &lt;/bean&gt;&lt;/beans&gt; 在web.xml配置前端控制器 1.配置加载Springmvc的核心文件 Code &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 加载springmvc核心配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 配置拦截路径 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; springmvc代码执行流程（重要！！！） 客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户 Springmvc的三大组件 处理器映射器Code&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt; 处理器适配器Code&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&gt; 【注】:注解驱动可以代替映射器和适配器的单独设置，同时也支持json的响应（推荐使用下面这种配置）Code&lt;mvc:annotation-driven /&gt; 视图解析器 配置视图解析器后我们不需要返回视图的完整路径 Code&lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 配置视图响应的前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 配置视图响应的后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis整合Spring","slug":"java/Mybatis与Spring整合","date":"2019-04-14T16:00:00.000Z","updated":"2019-04-12T09:38:11.351Z","comments":true,"path":"2019/04/15/java/Mybatis与Spring整合/","link":"","permalink":"http://SlectRxz.github.io/2019/04/15/java/Mybatis与Spring整合/","excerpt":"MyBatis与Spring框架的整合。","text":"MyBatis与Spring框架的整合。 mybatis与spring如何整合？ 整合思路：1.SqlsessionFactory对象应该放到Spring容器中作为单利存在；2、传统dao的开发方式中，应该从spring容器中获得sqlsession对象。3、Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象。4、数据库的连接以及数据库连接池事务管理都交给spring容器来完成。 整合步骤： 1.创建一个java工程。 2.导入jar包。 3.mybatis的配置文件sqlmapConfig.xml mapper包扫描可以直接交给Spring管理此处是应用于传统dao开发Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 4.编写Spring的配置文件 主要以下配置：1.数据库连接池的配置；2.sqlSessionFactory的配置(其中配置数据库源，SqlMapConfig路径，别名配置)；3.动态包扫描 Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;!-- 连接池的最大数据库连接数 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; /&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;5&quot; /&gt; &lt;/bean&gt; &lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.mybatis.pojo&quot; /&gt; &lt;/bean&gt; &lt;!-- ============传统dao开发 接口-类继承模式===================== --&gt; &lt;bean id=&quot;UserDao&quot; class=&quot;ctgu.mybatis.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ============动态dao开发 接口-配置文件模式==================== --&gt; &lt;!-- =============单个接口配置 =============================================================== 相当于mybatis中sqlMapConfig中的.class扫描（dao动态代理 接口+关系映射文件） &lt;mapper class=&quot;Mapper.mapper&quot;/&gt;============================================================ --&gt; &lt;!-- &lt;bean id=&quot;baseMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot; abstract=&quot;true&quot; lazy-init=&quot;true&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt; &lt;bean parent=&quot;baseMapper&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;ctgu.mybatis.Mapper.mapper&quot; /&gt; &lt;/bean&gt; --&gt; &lt;!-- =============包扫描=============好像只能用一种，两个同时配置将会报错==================================================== 相当于mybatis中sqlMapConfig中的&lt;package name=&quot;Mapper&quot;/&gt; basePackage：配置映射包扫描，多个包时用&quot;,&quot;或者&quot;;&quot;分隔(Value配置) --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;ctgu.mybatis.Mappe;ctgu.ssm.mapper&quot; /&gt; &lt;!-- optional unless there are multiple session factories defined --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1数据库连接及连接池 db.properties配置Codejdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root 4.2 sqlsessionFactory对象，配置到spring容器中 在applicationContext.xml中配置Code&lt;!-- sqlSessionFactory配置 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--配置mybatis的核心文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:SqlMapConfig.xml&quot; /&gt; &lt;!-- 配置数据库的数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 配置别名包扫描 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;ctgu.mybatis.pojo&quot; /&gt; &lt;/bean&gt; 测试：Codepackage ctgu.ssm.Test;import static org.junit.Assert.fail;import java.util.Date;import java.util.List;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import ctgu.ssm.mapper.UserMapper;import ctgu.ssm.pojo.User;import ctgu.ssm.pojo.UserExample;import ctgu.ssm.pojo.UserExample.Criteria;/** * 这个是逆向工程的生成测试类 * testSelectByExample是用来拼装查询条件 的 * * @author rong * */public class UserMapperTest &#123; private ApplicationContext applicationContext; @Before public void init()&#123; this.applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); &#125; @Test public void testDeleteByPrimaryKey() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); mapper.deleteByPrimaryKey(40); &#125; @Test public void testInsertSelective() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); User user = new User(); user.setUsername(&quot;大虎32&quot;); user.setAddress(&quot;宜昌&quot;); user.setSex(&quot;1&quot;);// mapper.insert(user) 与insertSelective的区别在于，insertSelective会判断其是否为空，只会将非空数据插入 mapper.insertSelective(user); &#125; @Test public void testSelectByExample() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); /* * 用来拼装查询条件 的 */ UserExample example = new UserExample(); //需求：查询姓大的男性 Criteria criteria = example.createCriteria(); criteria.andUsernameLike(&quot;%大%&quot;);//注意：此时必须手动添加%% criteria.andSexEqualTo(&quot;1&quot;); List&lt;User&gt; users = mapper.selectByExample(example); for (User user : users) &#123; System.out.println(user); &#125; &#125; @Test public void testSelectByPrimaryKey() &#123; UserMapper mapper = applicationContext.getBean(UserMapper.class); ctgu.ssm.pojo.User user = mapper.selectByPrimaryKey(31); System.out.println(user); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis逆向工程","slug":"java/MyBatis逆向工程","date":"2019-04-11T16:00:00.000Z","updated":"2019-04-12T09:38:02.849Z","comments":true,"path":"2019/04/12/java/MyBatis逆向工程/","link":"","permalink":"http://SlectRxz.github.io/2019/04/12/java/MyBatis逆向工程/","excerpt":"MyBatis逆向工程的实现。","text":"MyBatis逆向工程的实现。 逆向工程是干嘛的？我的理解是：逆向工程是根据数据库的表帮助我们直接生成pojo以及mapper中的接口以及关系映射文件。 那么我们应该如何修改配置文件？在generatorConfig.xml中配置mapper生成的详细信息，注意改下几点：1.添加要生成的数据库表2、po文件所在包路径3、mapper文件所在包路径 generatorConfig.xml Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;testTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/springmvc&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass=&quot;oracle.jdbc.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:yycg&quot; userId=&quot;yycg&quot; password=&quot;yycg&quot;&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;ctgu.pojo&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;ctgu.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;ctgu.mapper&quot; targetProject=&quot;.\\src&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table schema=&quot;&quot; tableName=&quot;item&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;user&quot;&gt;&lt;/table&gt; &lt;!-- &lt;table schema=&quot;&quot; tableName=&quot;items&quot;&gt;&lt;/table&gt; &lt;table schema=&quot;&quot; tableName=&quot;orderdetail&quot;&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema=&quot;&quot; tableName=&quot;&quot;&gt; &lt;columnOverride column=&quot;&quot; javaType=&quot;&quot; /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis学习（2）","slug":"java/Mybatis学习(2)","date":"2019-04-09T16:00:00.000Z","updated":"2019-12-20T12:06:02.880Z","comments":true,"path":"2019/04/10/java/Mybatis学习(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/10/java/Mybatis学习(2)/","excerpt":"MyBatis输入输出映射、动态sql、关联查询的使用。","text":"MyBatis输入输出映射、动态sql、关联查询的使用。 由mybatis学习（1）中我们了解到如何搭建mybatis工程，传统dao开发以及动态dao开发，本节主要讨论关系映射配置文件的具体配置。 1.输入映射与输出映射1.1输入映射1.1.1简单参数传递 包括String，Integer，Double，Float… Code&lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！ 如果你要传入的是基本类型【注：此时传入类型指的是parameterType】，括号里面一定要写value！！！ 【注：&apos;&apos;不能省，否则报错】--&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE&apos;%$&#123;value&#125;%&apos;;&lt;/select&gt; 1.1.2传递pojo对象Code&lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125;&lt;/update&gt; 1.1.3传递封装pojo对象Code&lt;!-- 输入参数为pojo的包装对象，即有一个成员是pojo类 --&gt; &lt;select id=&quot;getByQueryUser&quot; parameterType=&quot;QueryUser&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;user.username&#125;%&apos;;&lt;/select&gt; 1.2输出映射1.2.1输出简单类型 查询用户总记录数，演示返回简单类型 Code&lt;select id=&quot;getUserCount&quot; resultType=&quot;int&quot;&gt; SELECT COUNT(1) FROM USER&lt;/select&gt; 1.2.2输出pojo对象 根据id查询用户信息 Code&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.User&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125;&lt;/select&gt; 1.2.3输出pojo列表 根据名字的姓进行查询，返回一个Code &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #{name111} --&gt; &lt;!-- 注意： ${}是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%${value}%&apos;; &lt;/select&gt; Code## 2.动态sql### 2.1 if&gt;多查询条件拼装引出if标签&gt;if标签的使用： 注意：```&lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt;中间不是&amp;&amp; Code&lt;select id=&quot;getUserByNameSex&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like&apos;%$&#123;username&#125;%&apos; &lt;/if&gt; &lt;if test=&quot;sex!=null and sex!=&apos;&apos;&quot;&gt; and sex=#&#123;sex&#125; &lt;/if&gt;&lt;/select&gt; 2.1 where where标签的使用： 作用：添加where关键字，去掉多余的and Code&lt;select id=&quot;getUserByNameSex&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from user &lt;where&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; and username like&apos;%$&#123;username&#125;%&apos; &lt;!-- 此处的可能多余的and会由where标签去掉 --&gt; &lt;/if&gt; &lt;if test=&quot;sex!=null and sex!=&apos;&apos;&quot;&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 2.1 foreach foreach标签的使用： collection：要遍历的集合，来源入参，下面的例子的list—是QueryUser.list items:设置循环变量 open:循环开始前输出的sql内容，其实不写直接放在foreach外面也是可行的 separator:分隔符 close:循环结束拼接的sql需求：查询用户id在某一个范围内的用户信息数据使用：由于mybatis不支持直接传递集合，所以需要在pojo中创建一个集合的属性，我们需要做的就是把(1,10,25,30,34)装入集合里面，再想办法把sql语句拼装出来 Code&lt;select id=&quot;getUserByIds&quot; parameterType=&quot;QueryUser&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;user_list&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;!-- id IN (1,3,7,8,9) --&gt; &lt;foreach collection=&quot;list&quot; item=&quot;ids&quot; open=&quot;id IN(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;ids&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 2.1 SQL片段 作用：将公共的SQl片段抽取出来，有点相当于jsp中把公共页面包含起来。 抽取： Code&lt;sql id=&quot;user_list&quot;&gt; select * from user&lt;/sql&gt; 使用：Code&lt;include refid=&quot;user_list&quot;&gt;&lt;/include&gt; 3.关联查询 在实际开发当中，我们往往需要对多张表进行关联查询，表与表之间有一对一与一对多的关系（多对多属于两个一对多） 3.1 一对一查询 从A表出发在B表当中只有唯一的数据行与之对应，结果最多返回一个数据集。 3.1.1 使用resultType 使用resultType接收，那么必须要有一个与之对应的pojo（因为查询结果有两张表的属性）。需要：重新定义一个pojo，继承其中的一张表对应的pojo。 新建pojo Codepackage pojo;/** * 为了实现多表连接查询 * 通过resultType返回 * @author rong * */public class UserOrder extends Order &#123; //这两个属性是来自于Order表，即B表中的属性 private String username; private Integer id; . . .(实现其get/set方法) 修改order的映射文件 Code&lt;!-- ===================多表关联查询-1-1使用resultMap===================== --&gt;&lt;select id=&quot;getOrderUser&quot; resultType=&quot;pojo.UserOrder&quot;&gt; SELECT o.`id`, o.`user_id` userId, o.`number`, o.`createtime`, o.`note`, u.`username`, u.`address` FROM `order` o LEFT JOIN `user` u ON u.id = o.`user_id`&lt;/select&gt; 测试 Code@Test public void testGetOrderUser() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); OrderMaper orderMaper = openSession.getMapper(OrderMaper.class); List &lt;UserOrder&gt;orderList = orderMaper.getOrderUser(); for (UserOrder order: orderList) &#123; System.out.println(order); &#125; openSession.close(); &#125; 3.1.2 使用resultMap 基于面向对象的思想，我们直接对原有的pojo对象进行改造，使之能够接收到返回的属性（添加属性）。添加一个User类型的属性（面向对象的思想） Codepublic class Order &#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; private User user1; . . .（set/get方法） 修改关系映射文件type：指定映射到哪一个pojo，就是返回的定义普通属性property:在pojo中的属性名column：在数据库中的列名association–配置一对一查询property：绑定Order中的用户属性 即Order.user1【注：为了区别pojo中的user对象，在Order中定义的是user1成员】 property对应的是需要你告知来自哪个pojo中的哪个属性【注：一定要与javaType（pojo类）中对应的属性名称相同，参考前面定义的user1】 javaType是property的数据类型，支持别名 Code&lt;resultMap type=&quot;Order&quot; id=&quot;order_user_map&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;userId&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;result property=&quot;note&quot; column=&quot;note&quot;/&gt; &lt;!-- association配置一对一查询 property：绑定Order中的用户属性 即Order.user1【注：为了区别pojo中的user对象，在Order中定义的是user1成员】 javaType：属性的数据类型 property的数据类型，支持别名 我感觉： property对应的是需要你告知来自哪个pojo中的哪个属性 javaType是property的数据类型，支持别名 --&gt; &lt;association property=&quot;user1&quot; javaType=&quot;pojo.User&quot;&gt; &lt;!-- 感觉：每一个块块都要有一个主键，而user表中的主键就对应Order表中的user_id --&gt; &lt;id property=&quot;id&quot; column=&quot;user_id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; sql语句使用resultMap的名字使用前面定义的resultMap的名字。 Code&lt;select id=&quot;getOrderUserByMap&quot; resultMap=&quot;order_user_map&quot;&gt; SELECT o.`id`, o.`user_id`, o.`number`, o.`createtime`, o.`note`, u.`username`, u.`address` FROM `order` o LEFT JOIN `user` u ON u.id = o.`user_id` &lt;/select&gt; 3.2 一对多查询 当我们查询用户张三下了多少订单时，此时返回的是多个数据，基于一对多查询。改造pojo Codepublic class User &#123; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private String uuid2;//uuid private List&lt;Order&gt; order123; . . . (Get/Set方法) 改造关系映射文件property:在pojo中的属性名column：在数据库中的列名collection:配置一对多的关系 property:用户的Order属性【注：在pojo.user中的属性，为了以示区别，这里我定义的是一个order123的属性】 ofType:property的数据类型，支持别名 其余配置与一对一相同 Code&lt;resultMap type=&quot;user&quot; id=&quot;user_order_map&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;birthday&quot; column=&quot;birthday&quot;/&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;/&gt; &lt;result property=&quot;address&quot; column=&quot;address&quot;/&gt; &lt;!-- collection:配置一对多的关系 property:用户的Order属性【注：在pojo.user中的属性，为了以示区别，这里我定义的是一个order123的属性】 ofType:property的数据类型，支持别名 --&gt; &lt;collection property=&quot;order123&quot; ofType=&quot;pojo.Order&quot;&gt; &lt;id property=&quot;userId&quot; column=&quot;oid&quot;/&gt; &lt;result property=&quot;number&quot; column=&quot;number&quot;/&gt; &lt;result property=&quot;createtime&quot; column=&quot;createtime&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; SQL语句 Code&lt;select id=&quot;getUserOrderByMap&quot; resultMap=&quot;user_order_map&quot;&gt; SELECT u.`id`, u.`username`, u.`birthday`, u.`sex`, u.`address`, u.`uuid2`, o.`id` oid, o.`number`, o.`createtime` FROM `user` u LEFT JOIN `order` o ON o.`user_id` = u.`id` &lt;/select&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MyBatis学习（1）","slug":"java/MyBatis学习(1)","date":"2019-04-03T16:00:00.000Z","updated":"2019-12-20T12:05:56.209Z","comments":true,"path":"2019/04/04/java/MyBatis学习(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/04/04/java/MyBatis学习(1)/","excerpt":"MyBatis环境的搭建以及基本操作","text":"MyBatis环境的搭建以及基本操作 介绍MyBatis 目前最主流的持久层框架为hibernate与mybatis，而且国内目前情况使用Mybatis的公司比hibernate要多。 Hibernate学习门槛不低，要精通门槛更高。门槛高在怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate缓存与数据加载策略方面需要你的经验和能力都很强才行。国内目前前的情况精通hibernate技术大牛非常少。 sql优化方面，Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。当然了，Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。说得更深入一些，如果有个查询要关联多张表，比如5张表，10张表时，而且，我们要取的字段只是其中几张表的部分字段。这时用hibernate时就会显得非常力不从心。就算用hibernate的sqlquery，后续的维护工作也会让人发狂。1.工程搭建 我感觉框架的工作就是把许多事情都帮你去完成了，越是简洁的代码，背后实现的原理也就越复杂，每一个框架学习最难适应的就是工程的搭建，即入门。 1.1导jar包1.2准备pojo类（实体类相当于JavaBean） mybatis的查询返回，查询参数的输入都是以对象为实参进行 Code package pojo; import java.util.Date; public class User &#123; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private String uuid2;//uuid public String getUuid2() &#123; return uuid2; &#125; public void setUuid2(String uuid2) &#123; this.uuid2 = uuid2; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, sex=&quot; + sex + &quot;, birthday=&quot; + birthday + &quot;, address=&quot; + address + &quot;, uuid2=&quot; + uuid2 + &quot;]&quot;; &#125;&#125; 1.3配置SqlMapConfig.xml(核心配置文件一个)Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 先加载内部标签，再加载外部文件，属性名称一致时，替换内容 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root1&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt;&lt;!-- 别名配置： 为什么要使用别名： 我们的关系映射文件的parameterType往往是一个类名.包名， 此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;package name=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;!-- 加载mapper映射文件有四种方式 1.加载resource &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; 2.class扫描（dao动态代理 接口+关系映射文件）&lt;mapper class=&quot;Mapper.mapper&quot;/&gt; 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.&lt;mapper url=&quot;&quot;/&gt;绝对路径（从磁盘上找，一般不使用该方法） --&gt; &lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;!--&lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper class=&quot;Mapper.mapper&quot;/&gt; --&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;package name=&quot;Mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 1.4配置关系映射文件（多个） 关系映射配置文件一般是对某一个实体的增删查改操作封装在一个映射文件中，在SqlMapConfig.xml中注入，实际开发中有多个。 user.xmlCode&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- nameSpace：命名空间，用于分离sql语句 --&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;!-- id:statementId 语句的唯一标识符 1. resultType:返回结果集的数据类型 ========&gt;包名.类名(如果是查询所有集) 2. parameterType:查询的入参的数据类型 规定死了等一下要传入参数的类型 3. #&#123;&#125;:点位符，相当于JDBC中的 ？ 4.$&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125; &lt;/select&gt;&lt;!-- ======================================================================== --&gt; &lt;!-- 如果你返回值是为集合（例如一个list），那么你只需要返回 值类型填返回list中的类型就行 --&gt; &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一 次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;value&#125;%&apos;; &lt;/select&gt;&lt;!-- =============================================================================== --&gt; &lt;!--插入用户 mysql内部函数：select LAST_INSERT_ID()返回最后一次插入值的ID #&#123;&#125;占位符里面填User类中的属性 尝试过，必须使用User类中的属性，否则报错 useGeneratedKeys:使用自增 keyProperty，这里是user的主键 这两个配置会自动调用 select LAST_INSERT_ID() mysql自带函数，返回最后一次插入值的ID --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 需求：当我们插入一条语句时， 我们往往可能将对另外一张表产生影响， 需要得到该插入数据的主键ID selectKey:主键返回 keyProperty:user表中的主键的属性 考虑的是UUID要交给user类的哪一个属性 resultType：主键的数据类型 order：指selectKey在何时执行，AFTER表示在之后，BEFORE表示在之前 将返回的主键返回到user类中的id属性 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; --&gt; INSERT INTO mybatis.user ( username, birthday, sex, address) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;); &lt;/insert&gt;&lt;!-- =================================================================================== --&gt; &lt;!-- 一般我们数据表中有时候没有ID，此时需要我们定义一个标识来标致主键 mysql内部函数 select UUID 返回其查询数据表中的唯一标识 --&gt; &lt;insert id=&quot;insertUserUUID&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 将会将会生成每条数据对应的唯一标识UUID并返回 但是，当使用selectKey的时候，就相当于我们自己定义每条数据的返回标识（主键）， useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;不会生效 而generateKey默认使用id为表示并返回，二者取其一 --&gt; &lt;selectKey keyProperty=&quot;uuid2&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&gt; select UUID() &lt;/selectKey&gt; INSERT INTO mybatis.user ( username, birthday, sex, address,uuid2) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;,#&#123;uuid2&#125;); &lt;/insert&gt;&lt;!-- ========================================================================= --&gt; &lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;!-- ========================================================================= --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 1.5测试类（增删查改）Codepackage Test;import java.io.InputStream;import java.util.Date;import java.util.List;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import Utils.SqlSessionFactoryUtils;import pojo.User;public class testDemo1 &#123; //根据用户ID查询用户信息，查询结果是一个 @Test public void test1() throws Exception&#123; //1.创建sqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //2.查找配置文件创建输入流 InputStream inputStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //3.加载配置文件，创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(inputStream); //4.创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //注意：SQL中的增删改查方法都在SqlSession对象中 User user = sqlSession.selectOne(&quot;user.getUserById&quot;,1); System.out.println(user); //5.释放资源 sqlSession.close(); &#125; //根据用户的姓进行模糊查询，返回值是一个集合 @Test public void test2()&#123; //通过工具类得到SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); //创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); //查询，返回一个list List&lt;User&gt; user = sqlSession.selectList(&quot;user.getUserByName&quot;,&quot;张&quot;); for(User u:user)&#123; System.out.println(u); &#125; //关闭资源 sqlSession.close(); &#125; //插入用户 @Test public void test3()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); //设置为true，sqlSession会默认提交 就不用手动提交 openSession.commit();// SqlSession openSession = sqlSessionFactory.openSession(true); User user = new User(); user.setUsername(&quot;大虎22&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); //通过selectKey将插入后生成的主键返回 openSession.insert(&quot;user.insertUser&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //插入用户，返回UUID @Test public void test4()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); //设置为true，sqlSession会默认提交 就不用手动提交 openSession.commit();// SqlSession openSession = sqlSessionFactory.openSession(true); User user = new User(); user.setUsername(&quot;大虎24&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); //通过selectKey将插入后生成的主键返回 openSession.insert(&quot;user.insertUserUUID&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //更新 //--------------------------------注意：更新与删除后一定要提交事务 @Test public void test5()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(10); user.setUsername(&quot;大虎25&quot;); //通过selectKey将插入后生成的主键返回// openSession.insert(&quot;user.updateUserName&quot;, user); //注意：此处用insert、select都可以达到相同的效果，但是为了规范 openSession.update(&quot;user.updateUserName&quot;, user); System.out.println(user); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125; //删除 @Test public void test6()&#123; SqlSessionFactory sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); SqlSession openSession = sqlSessionFactory.openSession(); openSession.delete(&quot;user.deleteUser&quot;,30); //提交事务（默认不提交） openSession.commit(); openSession.close(); &#125;&#125; mybatis的核心类：SqlSessionFactoryBuilder、SqlSessionFactory、SqlSession 1.6入门小结 连接池的配置是在SqlMapConfig.xml映射文件中配置完毕的。其中就包括了数据库的连接。 sql查询语句的配置是在关系映射文件中实现的，在此工程下是user.xml 框架图（记）框架图的解释：MyBatis有两种配置文件 核心配置文件SqlMapConfig.xml(一个) 关系映射配置文件（多个）一般对应表的数量通过SqlSeessionFactoryBulder类连加载SqlSession只是一个接口，真正干活的是底层的执行器（Executor）2.MyBatis的dao开发(两种实现方式，推荐第二种)2.1原始dao开发注：使用原有的user.xml关系配置文件 定义一个UserDao接口 Codepackage dao;import java.util.List;import pojo.User;/*当我们@param id* @return* 这些的时候，在我们从别的类里面去调用的时候，也会看到其中的注释* 养成好习惯，便于调用接口的时候，知道该接口是干嘛用的*//** * 用户信息持久化接口 * @author rong * */public interface UserDao &#123; /** * 根据用户ID查询用户信息 * @param id * @return */ public User getUserById(Integer id); /** * 根据用户名查找用户列表 * @param name * @return */ public List&lt;User&gt;getUserByName(String name); /** * 添加用户 * @param user */ public void insertUser(User user);&#125; 定义接口的实现类 Codepackage dao.impl;import java.util.List;import org.apache.ibatis.session.SqlSession;import Utils.SqlSessionFactoryUtils;import dao.UserDao;import pojo.User;/** * 用户信息接口实现类 * @author rong * */public class UserDaoImpl implements UserDao &#123; @Override public User getUserById(Integer id) &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); User user = openSession.selectOne(&quot;user.getUserById&quot;,10); openSession.close(); return user; &#125; @Override public List&lt;User&gt; getUserByName(String name) &#123; // TODO Auto-generated method stub SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); List&lt;User&gt; users = openSession.selectList(&quot;user.getUserByName&quot;, name); openSession.close(); return users; &#125; @Override public void insertUser(User user) &#123; // TODO Auto-generated method stub SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); openSession.insert(&quot;user.insertUser&quot;, user); openSession.commit(); openSession.close(); &#125;&#125; 测试类小技巧：使用dao测试 一键生成 Codepackage Test;import static org.junit.Assert.fail;import java.util.Date;import java.util.List;import org.junit.Test;import dao.UserDao;import dao.impl.UserDaoImpl;import pojo.User;/** * 直接针对接口生成测试类 * @author rong * */public class UserDaoTest &#123; @Test public void testGetUserById() &#123; UserDao userDao=new UserDaoImpl(); User user = userDao.getUserById(10); System.out.println(user); &#125; @Test public void testGetUserByName() &#123; UserDao userDao=new UserDaoImpl(); List&lt;User&gt; users = userDao.getUserByName(&quot;张&quot;); for(User u:users)&#123; System.out.println(u); &#125; &#125; @Test public void testInsertUser() &#123; UserDao userDao=new UserDaoImpl(); User user = new User(); user.setUsername(&quot;大虎25&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); userDao.insertUser(user); &#125;&#125; 2.2接口动态代理(只有接口，没有实现类)1 定义dao接口Codepackage Mapper;import java.util.List;import pojo.User;/*当我们@param id* @return* 这些的时候，在我们从别的类里面去调用的时候，也会看到其中的注释* 养成好习惯，便于调用接口的时候，知道该接口是干嘛用的*//** * 用户信息持久化接口（dao动态代理）核心方法openSession.getMapper(mapper.class)得到代理对象 * @author rong * */public interface mapper&#123; /** * 根据用户ID查询用户信息 * @param id * @return */ public User getUserById(Integer id); /** * 根据用户名查找用户列表 * @param name * @return */ public List&lt;User&gt;getUserByName(String name); /** * 添加用户 * @param user */ public void insertUser(User user);&#125; 关系配置文件的规则 1.namespace必需是接口的全路径名2.接口的方法名必需与映射文件的sql id一致3.接口的输入参数必需与映射文件的parameterType类型一致4.接口的返回类型必须与映射文件的resultType类型一致 Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- dao的动态代理规则： 1.namespace必须是dao接口类的全路径 2.映射文件的sql ID必须与接口的方法名一致 3.映射文件parameterType的类型必须与接口输入参数一致 4.映射文件的resultType的类型必须与接口的输出参数一致 --&gt;&lt;mapper namespace=&quot;Mapper.mapper&quot;&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;pojo.User&quot;&gt; SELECT * FROM USER WHERE id = #&#123;id1&#125; &lt;/select&gt;&lt;!-- =================================================================================================== --&gt; &lt;!-- 如果你返回值是为集合（例如一个list），那么你只需要返回值类型填返回list中的类型就行 --&gt; &lt;select id=&quot;getUserByName&quot; parameterType=&quot;String&quot; resultType=&quot;pojo.User&quot;&gt; &lt;!-- SELECT * FROM USER WHERE username LIKE #&#123;name111&#125; --&gt; &lt;!-- 注意： $&#123;&#125;是字符串拼接符 目的是使我们传入的字符串不用每一次都带一个%String%，如何去掉百分号 ！！！如果你要传入的是基本类型，括号里面一定要写value！！！ --&gt; SELECT id,username,birthday,sex,address FROM USER WHERE username LIKE &apos;%$&#123;value&#125;%&apos;; &lt;/select&gt;&lt;!-- =================================================================================================== --&gt; &lt;!--插入用户 mysql内部函数：select LAST_INSERT_ID()返回最后一次插入值的ID #&#123;&#125;占位符里面填User类中的属性 尝试过，必须使用User类中的属性，否则报错 useGeneratedKeys:使用自增 keyProperty，这里是user的主键 这两个配置会自动调用 select LAST_INSERT_ID() mysql自带函数，返回最后一次插入值的ID --&gt; &lt;insert id=&quot;insertUser&quot; parameterType=&quot;pojo.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!-- 需求：当我们插入一条语句时，我们往往可能将对另外一张表产生影响，需要得到该插入数据的主键ID selectKey:主键返回 keyProperty:user表中的主键的属性 考虑的是UUID要交给user类的哪一个属性 resultType：主键的数据类型 order：指selectKey在何时执行，AFTER表示在之后，BEFORE表示在之前 将返回的主键返回到user类中的id属性 --&gt; &lt;!-- &lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; --&gt; INSERT INTO mybatis.user ( username, birthday, sex, address) VALUES(#&#123;username&#125;, #&#123;birthday&#125;, #&#123;sex&#125;, #&#123;address&#125;); &lt;/insert&gt;&lt;!-- ================================================================================================ --&gt; &lt;update id=&quot;updateUserName&quot; parameterType=&quot;pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;!-- ================================================================================================== --&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 在SqlMapConfig中加载映射文件 Code&lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;/mappers&gt; 测试类那么，动态代理将会自动帮我们 核心方法 openSession.getMapper(mapper.class)返回该类口的一个匿名实现类，你只需要用接口去接 Codepackage Test;import java.util.Date;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import Mapper.mapper;import Utils.SqlSessionFactoryUtils;import pojo.User;/** * dao动态代理的测试类 * @author rong * */public class mapperTest &#123; @Test public void testGetUserById() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象，传入的参数是接口的class文件 mapper mapp = openSession.getMapper(mapper.class); User user = mapp.getUserById(10); System.out.println(user); openSession.close(); &#125; @Test public void testGetUserByName() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象 mapper mapp = openSession.getMapper(mapper.class); List&lt;User&gt; users = mapp.getUserByName(&quot;大&quot;); for(User user:users)&#123; System.out.println(user); &#125; openSession.close(); &#125; @Test public void testInsertUser() &#123; SqlSession openSession = SqlSessionFactoryUtils.getSqlSessionFactory().openSession(); //获得代理对象 mapper mapp = openSession.getMapper(mapper.class); User user = new User(); user.setUsername(&quot;大虎26&quot;); user.setAddress(&quot;宜昌&quot;); user.setBirthday(new Date()); user.setSex(&quot;1&quot;); mapp.insertUser(user); openSession.commit(); openSession.close(); &#125;&#125; 3.SqlMapConfig.xml配置 SqlMapConfig.xml作为mybatis的核心配置文件，其约束采用DTD，其各个标签的含义如下： 3.1 properties配置配置原因：在我们配置数据库连接词时往往有许多参数，我们需要把这些参数抽取出来方便统一化管理。db.propertiesCodejdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=root 3.2 typeAliases(别名配置) 别名配置： 为什么要使用别名：我们的关系映射文件的parameterType往往是一个类名.包名，此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 3.3mappers(映射器配置) 加载mapper映射文件有四种方式 1.加载resource 2.class扫描（dao动态代理 接口+关系映射文件） 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.绝对路径（从磁盘上找，一般不使用该方法） 最后将上述操作放在一起SqlMapConfig.xml如下：Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 先加载内部标签，再加载外部文件，属性名称一致时，替换内容 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;jdbc.username&quot; value=&quot;root1&quot;/&gt; &lt;property name=&quot;jdbc.password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt;&lt;!-- 别名配置： 为什么要使用别名：我们的关系映射文件的parameterType往往是一个类名.包名，此时我们需要简写 有两种配置方式 1.单个别名定义：包名.类名 2.别名包扫描器（推荐使用）直接包名，在关系映射中可直接类名， 相当于在使用的时候不用写包名，更加方便 --&gt; &lt;typeAliases&gt; &lt;!-- &lt;typeAlias type=&quot;pojo.User&quot; alias=&quot;user&quot;/&gt; --&gt; &lt;package name=&quot;pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载映射文件 --&gt; &lt;!-- 加载mapper映射文件有四种方式 1.加载resource &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; 2.class扫描（dao动态代理 接口+关系映射文件）&lt;mapper class=&quot;Mapper.mapper&quot;/&gt; 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 3.包扫描 使用场景：当我们有几百个pojo的接口时，需要对某一个包下面的配置文件进行同一扫描 要求 :1.映射文件必须和接口位于同一目录 2.映射文件一定要与接口同名（否则映射文件找不到接口） 4.&lt;mapper url=&quot;&quot;/&gt;绝对路径（从磁盘上找，一般不使用该方法） --&gt; &lt;mappers&gt; &lt;!-- resource基于calsspath的路径去查找 --&gt; &lt;!--&lt;mapper resource=&quot;mybatis/userMapper.xml&quot;/&gt; --&gt; &lt;!-- &lt;mapper class=&quot;Mapper.mapper&quot;/&gt; --&gt; &lt;mapper resource=&quot;mybatis/user.xml&quot;/&gt; &lt;package name=&quot;Mapper&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"MySql连接异常解决","slug":"java基础/MySql","date":"2019-03-23T16:00:00.000Z","updated":"2019-03-24T13:04:40.330Z","comments":true,"path":"2019/03/24/java基础/MySql/","link":"","permalink":"http://SlectRxz.github.io/2019/03/24/java基础/MySql/","excerpt":"关于服务器启动MySql服务失败，以及密码错误如何修改","text":"关于服务器启动MySql服务失败，以及密码错误如何修改 MYSQL修复日志 最近很手残的把MYSQL中的mysql数据库中的user表给删掉了，然后在服务中MYSQL就无法启动，windows无法启动MySQL服务报错1067 的解决办法。 在网上找了许多资料，其中大概都是卸载重装，作为程序员永不放弃的精神，终于让我找到了一篇大佬的博客，不用重新安装。 链接如下：错误1067解决博客大致意思就是把安装MySQL路径下的文件copy到C盘下的ProgramData下的MySQL因为windows无法启动MySQL服务报错1067的原因是由于C:\\ProgramData\\MySQL\\MySQL Server 5.5\\data\\mysql下面缺少文件（反正我是由于删掉了user），正是如此，我们把MySQL安装目录下mysql文件夹下的文件，看缺什么就copy什么。 1.找文件 2.缺啥补啥，两个对应的 然后此时此刻，发现服务中MYSQL服务可以正常启动了，但是！！！数据库链接错误1045Access denied for user ‘root‘@’localhost’ (using password:YES) 这就是密码错误嘛。我估计是由于我换了那三个user文件导致的，此时此刻，只想说一句MMP MySQL修改登录密码解决方法经过不懈努力，终于找到了修改密码的方法。1.找到MYSQL安装路径下的my.ini文件，用记事本打开2.添加语句skip-grant-tables在如下位置添加：（图片来自网络）大佬的解释skip-grant-tables的作用是： skip-grant-tables作为启动参数的作用：MYSQL服务器不加载权限判断，任何用户都能访问数据库。也就是说，添加后数据库的安全性将会降低。 3.在cmd下mysql -u root -p,遇到Enter password直接回车 注意：如果你显示无效命令，就先进入到MYSQL目录下的bin目录在连接 4.进入mysql数据库，修改密码 use mysql//使用这个数据库update user set password=password(“123456”) where user=”root”//修改数据库密码flush privileges//刷新数据库 此时修改密码已经完成，再将my.ini中添加的语句删掉，再重启MySQL服务即可。","categories":[{"name":"MySql","slug":"MySql","permalink":"http://SlectRxz.github.io/categories/MySql/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Spring学习日志（2）","slug":"java/Spring学习(2)","date":"2019-03-19T16:00:00.000Z","updated":"2019-12-20T12:05:32.415Z","comments":true,"path":"2019/03/20/java/Spring学习(2)/","link":"","permalink":"http://SlectRxz.github.io/2019/03/20/java/Spring学习(2)/","excerpt":"Spring框架的AOP的注解开发，SpringJDBC模板的使用","text":"Spring框架的AOP的注解开发，SpringJDBC模板的使用 Spring（1）回顾 Spring的IOC的注解开发 注解的入门 引入aop的包 引入context约束 开启扫描类上的注解&lt;context:component-scan /&gt; 开启扫描方法、成员上的注解&lt;context:annotation-config/&gt; 使用注解开发 @Component ：定义Bean @Controller ：WEB层 @Service ：Service层 @Repository ：DAO层 属性注入： 普通属性 ：@Value 对象属性 ：@Resource 不是Spring中的 @Autowired ：按类型注入属性，按名称@Qulifier XML方式和注解方式比较 XML方式 ：适用性更广，结构更加清晰。 注解方式 ：适用类是自己定义，开发更方便。 XML和注解的整合开发（重点） XML定义类 注解属性注入 Spring的AOP的基于AspectJ的XML的开发 AOP的概述 AOP：面向切面编程，是OOP的扩展和延伸，是用来解决OOP遇到问题。 Spring的AOP 底层的实现 JDK的动态代理 Cglib的动态代理 AOP的相关术语 连接点：可以被拦截的点。 切入点：真正被拦截的点。 通知：增强方法 引介：类的增强 目标：被增强的对象 织入：将增强应用到目标的过程。 代理：织入增强后产生的对象 切面：切入点和通知的组合 AOP的入门开发 引入jar包 编写目标类并配置 编写切面类并配置 进行aop的配置Code&lt;aop:config&gt; &lt;aop:pointcut expression=”execution(表达式)” id=”pc1”/&gt; &lt;aop:aspect &gt; &lt;aop:before method=”” pointcut-ref=”pc1”/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知类型 前置通知 后置通知 环绕通知 异常抛出通知 最终通知 切入点表达式写法Spring的基于ApspectJ的注解的AOP开发###1. 实现步骤1.1创建项目，导入jar包1.2引入配置文件Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;事务管理&lt;/beans&gt; 1.3编写目标类并配置Code&lt;bean id=&quot;orderDao&quot; class=&quot;Spring.demo2.OrderDao&quot;&gt;&lt;/bean&gt; 也可以直接使用类上注解的方式，此时开启类上注解扫描 &lt;context:component-scan base-package=”Spring.demo2”&gt;&lt;/context:component-scan&gt; 1.4编写切面类并配置 说明：1.需要在类上配置@Aspect，说明这是一个切面类2.在方法上配置如何增强，中的属性会告诉你Spring在哪个方法上的哪个类上应用增强。Codepackage Spring.demo2;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Component(value=&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(value=&quot;execution(* Spring.demo2.OrderDao.add(..))&quot;) public void befor()&#123; System.out.println(&quot;----------前置增强-----&quot;); &#125; //可以获取被增强方法的返回值，注意两个result必须相同 @AfterReturning(value=&quot;execution(* Spring.demo2.OrderDao.delete(..))&quot;,returning=&quot;result&quot;) public void after(Object result)&#123; System.out.println(&quot;-------后置增强-----&quot;+result); &#125; @Around(value=&quot;execution(* Spring.demo2.OrderDao.update(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;-------环绕前增强------&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;----环绕后增强-------&quot;); return proceed; &#125;&#125; 1.5编写测试类Codepackage Spring.demo2;import javax.annotation.Resource;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * Spring的AOP的基于AspectJ注解开发 * 注意事项： * 1.导包 * 2.导入XML中的配置文件 * 3.在XML中开启AOP注解开发&lt;aop:aspectj-autoproxy/&gt; * 4.扫描类上的注解&lt;context:component-scan base-package=&quot;Spring.demo2&quot;&gt;&lt;/context:component-scan&gt; * 或者 &lt;context:annotation-config/&gt; 在没有扫描的情况下，使用注解 @Resource @value、@Autowired、@Qulifier * @author rong * */@RunWith(SpringJUnit4ClassRunner.class)//固定写法@ContextConfiguration(&quot;classpath:applicationContextAop.xml&quot;)public class Test &#123; @Resource(name=&quot;OrderDao&quot;) private OrderDao orderDao; @org.junit.Test public void test1()&#123; orderDao.find(); orderDao.add(); orderDao.delete(); orderDao.update(); &#125;&#125; 2.Spring的注解的AOP通知类型2.1@Befor前置通知Code@Before(value=&quot;execution(* Spring.demo2.OrderDao.add(..))&quot;) public void befor()&#123; System.out.println(&quot;----------前置增强-----&quot;); &#125; 2.2@AfterReturning后置通知Code//可以获取被增强方法的返回值，注意两个result必须相同 @AfterReturning(value=&quot;execution(* Spring.demo2.OrderDao.delete(..))&quot;,returning=&quot;result&quot;) public void after(Object result)&#123; System.out.println(&quot;-------后置增强-----&quot;+result); &#125; 2.3@Around环绕通知Code//注意：写方法的时候需要返回一个Object,返回的是被增强的方法@Around(value=&quot;execution(* Spring.demo2.OrderDao.update(..))&quot;) public Object around(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(&quot;-------环绕前增强------&quot;); Object proceed = joinPoint.proceed(); System.out.println(&quot;----环绕后增强-------&quot;); return proceed; &#125; 2.4@AfterThrowing：异常抛出通知 2.5@After最终通知 3.Spring的注解AOP切入点的配置 使用情景：假设在同一个方法上我需要进行多个通知，那么比较麻烦的是我需要在每个方法上都配置，但是如果有一天我增强的方法改了，导致我 需要在每个方法上都进行修改配置 3.1Spring的AOP的注解切入点的配置 4.Spring的JDBC模板的使用 Spring是EE开发的一站式的框架，有EE开发的每层的解决方案。Spring对持久层也提供了解决方案：ORM模块和JDBC的模板。Spring提供了很多的模板用于简化开发 4.1如何使用 以下使用分为以下几步：1.导入jar包2.准备数据库。3.使用JDBC模板保存数据4.将连接池和模板类交给Spring管理5.编写测试类 4.1.1 导入jar包 4.1.2 使用Spring提供的JDBC模板 核心类：JdbcTemplate jdbc=new JdbcTemplate(dataSource);注意： 需要传入的是一个连接池对象，也支持无参的构造方法，可以使用jdbc.setDataSource(dataSource)配置。Code//1.不使用Spring管理 @Test public void test1()&#123; //获取连接池（Spring自带的一个） DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //创建JDBC模板 JdbcTemplate jdbc=new JdbcTemplate(dataSource); jdbc.update(&quot;insert into stu values (?,?,?,?)&quot;,101,&quot;张大胖1&quot;,&quot;男&quot;,25); &#125; 4.1.3 把连接池和模板交给Spring管理 说明： 一直我都在想，所谓的交给Spring管理，意思就是把那些需要我们new的对象用注解去代替new的过程。Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/student&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.1.4编写测试类Codepackage SpringJDBC.demo3;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.datasource.DriverManagerDataSource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * 使用Spring提供的JDBC模板 * Spring提供的JDBC模板核心类： * JdbcTemplate jdbc=new JdbcTemplate(dataSource); * 其中连接池的核心类： * 1.Spring提供的连接池 * DriverManagerDataSource dataSource = new DriverManagerDataSource(); * 2.c3p0连接池 * ComboPooledDataSource dataSource2 = new ComboPooledDataSource(); * 3.DBCP连接池 * new BasicDataSource(); * @author rong * */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContextJDBC.xml&quot;)public class JDBCTest &#123; //1.不使用Spring管理 @Test public void test1()&#123; //获取连接池（Spring自带的一个） DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/student&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //创建JDBC模板 JdbcTemplate jdbc=new JdbcTemplate(dataSource); jdbc.update(&quot;insert into stu values (?,?,?,?)&quot;,101,&quot;张大胖1&quot;,&quot;男&quot;,25); &#125; //2.将其交给Spring管理 //说明：那个类需要new的时候，就可以把这个类交给Spring管理，不需要自己去new @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void test2()&#123; jdbcTemplate.update(&quot;insert into stu values (?,?,?,?)&quot;,103,&quot;张大胖3&quot;,&quot;男&quot;,25); &#125; //3.使用c3p0连接池 /** * 导包 * 有使用配置文件和不使用配置文件两种方式 */ @Test public void test3()&#123; jdbcTemplate.update(&quot;insert into stu values (?,?,?,?)&quot;,105,&quot;张大胖5&quot;,&quot;男&quot;,25); &#125;&#125; 4.2抽取配置信息到属性文件 使用场景： 在实际开发中，将配置文件的参数单独放在一个配置文件，在XML文件中再将其引入进来 ，username，password 4.2.1 定义一个属性文件 创建一个properties的文件Codejdbc.driverClass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/studentjdbc.username=rootjdbc.password=root 4.2.2 如何在Spring的配追文件（XML）中引入属性文件 有两种方式1.(用的少)Code&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:properties&quot;/&gt;&lt;/bean&gt; 2.(常用)Code&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; 就会去加载类路径下的属性文件了，我猜测是放在域对象中，后面直接${key}取出。 4.2.3 对应在配置文件中的写法 注意property中的value的写法Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"数据库连接池以及JDBUtils使用","slug":"java基础/JDBC","date":"2019-03-05T16:00:00.000Z","updated":"2019-03-06T08:05:44.028Z","comments":true,"path":"2019/03/06/java基础/JDBC/","link":"","permalink":"http://SlectRxz.github.io/2019/03/06/java基础/JDBC/","excerpt":"数据库连接池，包括DBCP以及C3P0，DBUtils工具的使用","text":"数据库连接池，包括DBCP以及C3P0，DBUtils工具的使用 数据库连接池 数据库的连接对象创建工作，比较消耗性能。 2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。 后面需要连接的话，直接从池子里面去。不要去自己创建连接了。 使用完毕， 要记得归还连接。确保连接对象能循环利用。 下面内容是我搬运别人写的比较好的内容 没有池的情况 认识池说明：Code1、 池就是一种容纳对象的容器2、 连接池就是保存数据库连接对象的容器3、 在连接池中我们会预先创建一定数量的连接对象，当需要数据库连接的时候，只要从数据库连接池中取出一个，使用完毕之后就再放回去，这些连接对象是以一种循环队列来存放的，取的时候从头开始，放回的时候放在尾部。4、 通过设置最大连接数量来防止系统无止尽的与数据库连接5、 连接池中可以设置监听机制，用来测试连接的数量 连接池中的属性 连接池的使用 自定义数据库连接池 代码实现 Codepackage 连接池;import java.io.PrintWriter;import java.sql.Connection;import java.sql.SQLException;import java.sql.SQLFeatureNotSupportedException;import java.util.ArrayList;import java.util.List;import java.util.logging.Logger;import javax.sql.DataSource;/** * * @author rong *这是一个数据库连接池 *1. 一开始先往连接池中放10个连接 *2. 来的程序通过getConnection()连接 *3. 用完通过addBack()归还 *4. 扩容 *//** * * @author rong *有缺陷 *1. 需要额外记住addBack()方法 *2. 无法面向接口编程 *DaoSource datasource=new MyDataSource(); * *JAVA多态 *编译时候看左边，运行时候看右边 *解释：编译的时候看接口中有没有定义这个方法，运行的时候是运行继承类口的类中的方法 */public class MyDataSource implements DataSource&#123; List&lt;Connection&gt; list=new ArrayList&lt;Connection&gt;(); public MyDataSource()&#123; for(int i=0;i&lt;10;i++)&#123; Connection conn = JDBCUtil.getConn(); list.add(conn); &#125; &#125; //该连接池对外公布的获取连接的方法 @Override public Connection getConnection() throws SQLException &#123; // TODO Auto-generated method stub if(list.size()==0)&#123;//连接不够再创建5个 for(int i=0;i&lt;5;i++)&#123; Connection conn = JDBCUtil.getConn(); list.add(conn); &#125; &#125; Connection connection = list.remove(0);//永远移除第一个 return connection; &#125; public void addBack(Connection conn)&#123; list.add(conn); &#125; //---------------后面的方法暂时用不到-----------------------// @Override public PrintWriter getLogWriter() throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public void setLogWriter(PrintWriter out) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public void setLoginTimeout(int seconds) throws SQLException &#123; // TODO Auto-generated method stub &#125; @Override public int getLoginTimeout() throws SQLException &#123; // TODO Auto-generated method stub return 0; &#125; @Override public Logger getParentLogger() throws SQLFeatureNotSupportedException &#123; // TODO Auto-generated method stub return null; &#125; @Override public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125; @Override public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException &#123; // TODO Auto-generated method stub return false; &#125; @Override public Connection getConnection(String username, String password) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125;&#125; 出现的问题： 需要额外记住 addBack方法 单例。 无法面向接口编程。 UserDao dao = new UserDaoImpl();dao.insert(); DataSource dataSource = new MyDataSource(); 因为接口里面没有定义addBack方法。 4. 怎么解决? 以addBack 为切入点。 解决自定义数据库连接池出现的问题。 由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。 我们打算修改接口中的那个close方法。 原来的Connection对象的close方法，是真的关闭连接。打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。 如何扩展某一个方法? 原有的方法逻辑，不是我们想要的。 想修改自己的逻辑 直接改源码 无法实现。 继承， 必须得知道这个接口的具体实现是谁。 使用装饰者模式。 开源连接池DBCP（database connection pool） 导入jar文件 不使用配置文件： public void testDBCP01(){ Connection conn = null; PreparedStatement ps = null; try { //1. 构建数据源对象 BasicDataSource dataSource = new BasicDataSource(); //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。 //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admin&quot;); ps.setInt(2, 1000); ps.executeUpdate(); } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } 使用配置文件方式： Connection conn = null; PreparedStatement ps = null; try { BasicDataSourceFactory factory = new BasicDataSourceFactory(); Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;); properties.load(is); DataSource dataSource = factory.createDataSource(properties); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;liangchaowei&quot;); ps.setInt(2, 100); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 配置文件dbcpconfig.properties Code#连接设置driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/jdbcusername=rootpassword=#&lt;!-- 初始化连接 --&gt;initialSize=10#最大连接数量maxActive=50#&lt;!-- 最大空闲连接 --&gt;maxIdle=20#&lt;!-- 最小空闲连接 --&gt;minIdle=5#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;maxWait=60000#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。connectionProperties=useUnicode=true;characterEncoding=gbk#指定由连接池所创建的连接的自动提交（auto-commit）状态。defaultAutoCommit=true#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLEdefaultTransactionIsolation=READ_UNCOMMITTED C3P0 拷贝jar文件 到 lib目录 不使用配置文件方式Connection conn = null; PreparedStatement ps = null; try { //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 使用配置文件方式Codepackage 连接池;import java.sql.Connection;import org.junit.Test;import com.mchange.v2.c3p0.ComboPooledDataSource;/** * C3P0数据库连接（使用XML作为配置文件） * 注意：当配置文件的名字为c3p0-config.xml时，在new ComboPooledDataSource()对象 * 时，会自动使用类加载器加载XML文件 * * @author rong * */public class C3P0Demo1 &#123; @Test public void test1()&#123; ComboPooledDataSource comboPooledDataSource = new ComboPooledDataSource(); //注意： Connection conn=null; java.sql.PreparedStatement ps=null; try &#123; //获取连接对象 conn = comboPooledDataSource.getConnection(); //准备查询sql String sql=&quot;insert into stu value(16,?,?,42)&quot;; //获取statement ps= conn.prepareStatement(sql); ps.setString(1, &quot;胖虎&quot;); ps.setString(2, &quot;男&quot;); ps.executeUpdate(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; JDBCUtil.release(conn, ps); &#125; &#125;&#125; XML配置文件Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;!-- default-config 默认的配置， --&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost/student&lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;!-- This app is massive! --&gt; &lt;named-config name=&quot;oracle&quot;&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;50&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;1000&lt;/property&gt; &lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt; &lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;!-- he&apos;s important, but there&apos;s only one of him --&gt; &lt;user-overrides user=&quot;master-of-the-universe&quot;&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;1&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;50&lt;/property&gt; &lt;/user-overrides&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; DBUtils增删改//dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //增加 //queryRunner.update(&quot;insert into account values (null , ? , ? )&quot;, &quot;aa&quot; ,1000); //删除 //queryRunner.update(&quot;delete from account where id = ?&quot;, 5); //更新 //queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 10000000 , 6); 查询（两种方式） 直接new接口的匿名实现类 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;(){ //去执行查询，查询到的数据还是在那个result里面，然后调用下面的handle方法，由用户手动封装 @Override public Account handle(ResultSet rs) throws SQLException { Account account = new Account(); while(rs.next()){ String name = rs.getString(&quot;name&quot;); int money = rs.getInt(&quot;money&quot;); account.setName(name); account.setMoney(money); } return account; } }, 6); System.out.println(account.toString()); 直接使用框架已经写好的实现类。 * 查询单个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //查询单个对象 Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 8); * 查询多个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); List&lt;Account&gt; list = queryRunner.query(&quot;select * from account &quot;, new BeanListHandler&lt;Account&gt;(Account.class)); ResultSetHandler 常用的实现类以下两个是使用频率最高的 BeanHandler, 查询到的单个数据封装成一个对象 BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt; ArrayHandler, 查询到的单个数据封装成一个数组 ArrayListHandler, 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 MapHandler, 查询到的单个数据封装成一个map MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 ColumnListHandlerKeyedHandlerScalarHandler 总结数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 queryRunner.update();增删改 queryRunner.query查","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://SlectRxz.github.io/categories/JDBC/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"事务","slug":"java基础/事务","date":"2019-03-03T16:00:00.000Z","updated":"2019-03-06T03:28:49.248Z","comments":true,"path":"2019/03/04/java基础/事务/","link":"","permalink":"http://SlectRxz.github.io/2019/03/04/java基础/事务/","excerpt":"包括事务的特性ACID","text":"包括事务的特性ACID 事务事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库 rollback ; 数据回滚，回到最初的状态。 关闭自动提交功能。 演示事务 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); @Test public void testTransaction(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); int a = 10 /0 ; //加钱， 给ID为2 加100块钱 ps.setInt(1, -100); ps.setInt(2, 2); ps.executeUpdate(); //成功： 提交事务。 conn.commit(); } catch (SQLException e) { try { //事变： 回滚事务 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } } 注意： 关闭事务conn.setAutoCommit(false); 事务的提交conn.commit(); 回滚事务 conn.rollback(); 事务的特性ACID（面试会问） 原子性 指的是 事务中包含的逻辑，不可分割。 一致性 指的是 事务执行前后。数据完整性 隔离性 指的是 事务在执行期间不应该受到其他事务的影响 持久性 指的是 事务执行成功，那么数据应该持久保存到磁盘上。 事务的安全隐患 不考虑隔离级别设置，那么会出现以下（读和写）问题。 读 脏读 不可重读读 幻读. 脏读 一个事务读到另外一个事务还未提交的数据 不可重复读 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。 读未提交 演示 设置A窗口的隔离级别为 读未提交 两个窗口都分别开启事务 写 丢失更新 读已提交演示 设置A窗口的隔离级别为 读已提交 A B 两个窗口都开启事务， 在B窗口执行更新操作。 在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。 这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题 ，不可重复读。 可串行化 如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。 但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。 按效率划分，从高到低 读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 可串行化 按拦截程度 ，从高到底 可串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交 事务总结需要掌握的 在代码里面会使用事务 conn.setAutoCommit(false); conn.commit(); conn.rollback(); 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 事务是会自动提交的。 需要了解的安全隐患读 脏读 一个事务读到了另一个事务未提交的数据 不可重复读 一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致 幻读 一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。 写 丢失更新。 隔离级别读未提交 引发问题： 脏读 读已提交 解决： 脏读 ， 引发： 不可重复读 可重复读 解决： 脏读 、 不可重复读 ， 未解决： 幻读 可串行化 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读 Oracle 默认的隔离级别是 读已提交 丢失更新 解决丢失更新 悲观锁 可以在查询的时候，加入 for update 乐观锁 要求程序员自己控制。 总结事务使用命令行演示 使用代码演示 脏读、 不可重复读、 幻读 丢失更新 悲观锁 乐观锁 4个隔离级别 读未提交 读已提交 可重复读 可串行化","categories":[{"name":"JDBC","slug":"JDBC","permalink":"http://SlectRxz.github.io/categories/JDBC/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"四大域对象","slug":"java基础/javaWeb基础之域对象","date":"2019-02-27T16:00:00.000Z","updated":"2019-04-10T09:53:47.427Z","comments":true,"path":"2019/02/28/java基础/javaWeb基础之域对象/","link":"","permalink":"http://SlectRxz.github.io/2019/02/28/java基础/javaWeb基础之域对象/","excerpt":"四大域对象的生命周期、作用范围、作用的总结。","text":"四大域对象的生命周期、作用范围、作用的总结。 根据有作用范围由小到大：page(jsp有效)——》page域指的是pageContext.request(一次请求)—》request域request HttpServletContextsession(一次会话)—》session域session HttpSessionapplication(当前web应用)—》application域指的是application ServletContext；之所以他们是域对象，原因是他们都内置了map集合，都有setAttribute和getAttribute方法。 一、 PageContext域1.生命周期：当对JSP的请求开始，当相应结束时销毁。 jsp页面被执行，声明周期开始； jsp页面执行完毕，声明周期结束；2.作用范围：整个JSP页面，是四大作用域中最小的一个。3.作用： 获取其它八大隐式对象，可以认为是一个入口对象。 获取其所有域中的数据 pageContext 操作所有域中属性的方法public java.lang.Object getAttribute(java.lang.String name,int scope) public void setAttribute(java.lang.String name, java.lang.Object value,int scope)public void removeAttribute(java.lang.String name,int scope) pageContext 中代表域的常量 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPEfindAttribute方法,在四大域中搜寻属性，搜寻的顺序是page域、request域、session域、application域，从小域到大域开始搜索，如果搜索到就直接获取该值，如果所有域中都找不到，返回一个null(与el表达式不同，此处返回null，对网页是不友好的) （3）跳转到其他资源 其身上提供了forward和include方法，简化重定向和转发的操作二、Request域1.生命周期： 在Service方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。 用户发送一个请求，开始，服务器返回响应，请求结束，生命周期结束；2.作用范围：整个请求链（请求转发也存在）3.作用：在整个请求链中共享数据，经常用到：在servlet中处理好的数据交给JSP显示，此时参数就可以放在Request域中。三、HttpSession 域1.生命周期： 在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个session并返回。（1）当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。（2）如果服务器非正常关闭，没有到期的session也会跟着销毁。（3）如果调用session提供的invalidate()，可以立即销毁session。用户打开浏览器访问，创建session（开始），session超时或者被声明失效，该对象生命周期结束；2.作用范围：一次会话。HttpSession 在服务器中，为浏览器创建独一无二的内存空间，在其中保存会话相关的信息注意：服务器正常关闭，再启动，Session对象会进行钝化和活化操作。同时如果服务器钝化的时间在session 默认销毁时间之内， 则活化后session还是存在的。否则Session不存在。 如果JavaBean 数据在session钝化时，没有实现Serializable 则当Session活化时，会消失。 四、ServletContext1.生命周期： 当WEB应用被加载进容器创建代表整个WEB应用的ServletContext对象； 当服务器关闭或WEB应用被移除时，ServletContext对象跟着被销毁。2.作用范围：整个WEB应用。3、作用：a)在不同Servlet 之间转发this.getServletContext().getRequestDispatcher(“/servlet/Demo10Servlet”).forward(request,response);方法执行结束，service就会返回到服务器，再有服务器去调用目标servlet，其中request会重新创建，并将之前的request的数据拷贝进去。b)读取资源文件。1、由于相对路径默认相对的是java虚拟机启动的目录，所以我们直接写相对路径将会是相对于tomcat/bin目录，所以是拿不到资源的。如果写成绝对路径，当项目发布到其他环境时，绝对路径就错了。为了解决这个问题ServletContext提供了：this.getServletContext().getRealPath(“/1.properties”)，给进一个资源的虚拟路径，将会返回该资源在当前环境下的真实路径。 this.getServletContext().getResourceAsStream(“/1.properties”)，给一个资源的虚拟路径返回到该资源真实路径的流。2、当在非servlet下获取资源文件时，就没有ServletContext对象用了，此时只能用类加载器classLoader.getResourceAsStream(“../../1.properties”)，此方法利用类加载器直接将资源加载到内存中，有更新延迟的问题，以及如果文件太大，占用内存过大。classLoader.getResource(“../1.properties”).getPath()，直接返回资源的真实路径，没有更新延迟的问题。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"监听器与过滤器","slug":"java基础/Listener&Filter","date":"2019-02-26T16:00:00.000Z","updated":"2019-03-07T08:43:07.629Z","comments":true,"path":"2019/02/27/java基础/Listener&Filter/","link":"","permalink":"http://SlectRxz.github.io/2019/02/27/java基础/Listener&Filter/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Listener &amp; FilterListener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 监听器使用： 定义一个类，实现接口 注册 | 配置监听器 1.监听三个作用域创建和销毁request —httpServletRequest session —httpSession application — ServletContext 1. ServletContextListener servletcontext在什么时候创建？ 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 2. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 public class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 销毁了&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 初始化了&quot;); } } &lt;listener&gt; &lt;listener-class&gt;com.itheima.listener.MyRequestListener&lt;/listener-class&gt; &lt;/listener&gt; 3. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;创建session了&quot;); } @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;销毁session了&quot;); } } 作用： ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 2.监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 （就是监听这个值在不在session中） 1. 让javaBean 实现该接口即可 @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被绑定进来了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被解除绑定&quot;); } HttpSessionActivationListener 用于监听检测现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作注意：serializable接口，标志着该类可以实现序列化与反序列化，要想该类能够实现序列化与反序列化，必须继承该类 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 1. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:8080 3. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\\tomcat\\apache-tomcat-7.0.52\\work\\Catalina\\localhost\\ListenerDemo\\itheima &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;itheima&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { } } 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 ###Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain chain.doFilter(request, response); 放行， 让请求到达下一个目标。 &lt;url-pattern&gt;/*&lt;/url-pattern&gt;写法格式与servlet一样。/*代表着你过滤谁 全路径匹配 以 / 开始 /LoginServlet 只有访问这个servlet时才拦截 以目录匹配 以 / 开始 以 * 结束 /demo01/* 只有访问demo01目录下的文件才会拦截 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。 自动登录 需求分析 1. 搭建环境 搭建数据库 搭建页面 登录servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String autoLogin = request.getParameter(&quot;auto_login&quot;); UserBean user = new UserBean(); user.setUsername(userName); user.setPassword(password); UserDao dao = new UserDaoImpl(); UserBean userBean = dao.login(user); if(userBean != null){ //成功了，进入首页 request.getSession().setAttribute(&quot;userBean&quot;, userBean); response.sendRedirect(&quot;index.jsp&quot;); }else{ //不成功... request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response); } } catch (SQLException e) { e.printStackTrace(); } } 过滤器代码(见AutoLogin代码) 过滤器的核心不是完成拦截不给 ， 还是放行显示。 它的核心是在放行之前，帮用户完成登录的功能。 实现思路 先判断session是否有效， 如果有效，就不用取cookie了，直接放行。 如果session失效了，那么就取 cookie。 没有cookie 放行 有cookie 1. 取出来cookie的值，然后完成登录 2. 把这个用户的值存储到session中 3. 放行。 /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest req, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { HttpServletRequest request = (HttpServletRequest) req; //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); //先判断，现在session中还有没有那个userBean. UserBean userBean = (UserBean) request.getSession().getAttribute(&quot;userBean&quot;); //还有，有效。 if(userBean != null){ chain.doFilter(request, response); }else{ //代表session失效了。 //2. 看cookie。 //1. 来请求的时候，先从请求里面取出cookie , 但是cookie有很多的key-value Cookie[] cookies = request.getCookies(); //2. 从一堆的cookie里面找出我们以前给浏览器发的那个cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;auto_login&quot;); //第一次来 if(cookie == null){ chain.doFilter(request, response); }else{ //不是第一次。 String value = cookie.getValue(); String username = value.split(&quot;#itheima#&quot;)[0]; String password = value.split(&quot;#itheima#&quot;)[1]; //完成登录 UserBean user = new UserBean(); user.setUsername(username); user.setPassword(password); UserDao dao = new UserDaoImpl(); userBean = dao.login(user); //使用session存这个值到域中，方便下一次未过期前还可以用。 request.getSession().setAttribute(&quot;userBean&quot;, userBean); chain.doFilter(request, response); } } } catch (Exception e) { e.printStackTrace(); chain.doFilter(req, response); } } BeanUtils的使用 导包注意：BeanUtils可以帮我们转换int，String等类型，但是日期类型转换不了总结如下： 如果form参数是String类型，javabean属性String类型 —- 调用BeanUtils.populate 将form数据封装 javabean 如果JavaBean属性类型不是String —- 将form数据封装javabean 需要转换器 —– 在BeanUtils API 提供很多默认转换器（完成常见转换） 如果需要转换类型非常特殊，可以通过自定义转换器完成 定义类实现Converter接口，实现convert方法 ，在populate调用之前通过ConvertUtils.register注册转换器 BeanUtils.populate(bean, map); //注册自己的日期转换器 ConvertUtils.register(new MyDateConverter(), Date.class); //转化数据 Map map = request.getParameterMap(); UserBean bean = new UserBean(); 转化map中的数据，放置到bean对象身上 BeanUtils.populate(bean, map); 总结Listener8个 三种类型 针对三个作用域的创建和销毁 针对三个作用域的值改变 【添加 | 替换 | 移除】 针对session中的值 【钝化 活化】 ， 【绑定 解绑】 钝化 ( 序列化 ) 内存中的对象存储到硬盘 超时失效。 session销毁了。 非正常关闭服务器， 钝化 。 正常关闭服务器 销毁 设置了session，多久时间。 context.xml 活化 (反序列化) 从硬盘里面读取到内存 ServletContextListner ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。HttpSessionListener ： 统计在线人数HttpSessionActivationListener ： 钝化活化处理 ##Filter 使用频率更高 如果要写一个过滤器。 定义一个类，实现接口 Filter 注册 . web.xml . 与servlet相似。 过滤器放行。 chain.doFilter(request, response); 过滤器生命周期 创建： 服务器加载这个项目的时候创建实例 销毁： 关闭服务器或者从服务器中移除项目的时候。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Spring学习日志（1）","slug":"java/Spring学习(1)","date":"2019-02-24T16:00:00.000Z","updated":"2019-12-20T12:05:27.222Z","comments":true,"path":"2019/02/25/java/Spring学习(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/02/25/java/Spring学习(1)/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Spring的简介什么是Spring Spring是一个开源框架，于2003年兴起的轻量级java开发框架，简单而言，Spring是一个分层的JAVASE/EEfull-stack（一站式）开源框架 Spring入门（IOC）一、什么是IOC IOC（Inversion of Control）：控制反转。控制反转：将对象的控制权反转交给Spring 导包 (官网：http://SPring.io/) 引入约束文件 在spring的解压路径下spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Spring底层实现原理： Spring学习路线 把类交给Spring处理，有两种方式 1 . 通过XML配置方式Codepackage Spring.demo1;/** * 业务管理层的接口 * @author rong * */public interface UserService &#123; public void add();&#125; Codepackage Spring.demo1;/** * 业务管理层的实现类 * @author rong * */public class UserServiceImp implements UserService &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void add() &#123; // TODO Auto-generated method stub System.out.println(&quot;UserServiceImp被执行了&quot;+name); &#125;&#125; Codepackage Spring.demo1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Test &#123; @org.junit.Test public void demo1()&#123;// UserService user=new UserServiceImp(); UserServiceImp user=new UserServiceImp(); user.setName(&quot;张三&quot;); user.add(); &#125; /** * Spring 方式的调用 */ @org.junit.Test public void demo2()&#123; /** * 创建Spring工厂 */ ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;application.xml&quot;); UserService User = (UserService) applicationContext.getBean(&quot;UserService&quot;); User.add(); &#125; @org.junit.Test public void demo3()&#123; /** * 加载磁盘上的配置文件 */ ApplicationContext applicationContext=new FileSystemXmlApplicationContext(&quot;D:\\\\111\\\\application.xml&quot;); UserService user = (UserService) applicationContext.getBean(&quot;UserService&quot;); user.add(); &#125;&#125; XML配置文件其中包括了属性的注入（通过构造函数或Set方法）SPEL的/font&gt;的注入集合的注入的注入Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring 入门的配置 id 相当于Spring生成类时，该类的一个编号，，，用于getBean() name 作用与上面相同 class 生成类的地址 包名.类名 init-method Spring在初始化该类的时候所执行的方法 destory-method Spring在关闭工厂的时候所执行的方法 scope 所创建的类是 单例模式-无论getBean几次，都只new一次（singleton） 多例模式-getBean几次就new几次 （prototype） request 生成的对象存放在域中 session 同上 globalsession 作用见word factory-method 在类初始化时，若不写默认调用无参的构造方法，若想指定构造方法，则使用该方法 --&gt; &lt;bean id=&quot;UserService&quot; class=&quot;Spring.demo1.UserServiceImp&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;Custom&quot; class=&quot;Spring.demo2.CustomImp&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; scope=&quot;prototype&quot; &gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;Spring.demo3.person&quot; &gt; &lt;/bean&gt; &lt;!-- 属性的注入 有两种方式 1.通过构造方式（有参构造） &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; 2.通过类的set方法 &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; 注意： 当成员不在是简单的属性，而实某一个对象时，value变为ref --&gt; &lt;bean id=&quot;car1&quot; class=&quot;Spring.demo4.car1&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;12220.0&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;东风&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; &lt;/bean &gt; --&gt; &lt;!-- 改用P名称空间注入 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot; p:name=&quot;东风&quot; p:price=&quot;4212.0&quot; &gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; --&gt; &lt;!-- 改用P名称 空间注入 注意： P名称空间注入走的也是set方法, 官方目的是简化set注入的property标签的写法 有set方法就不要有 有参的构造方法 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot; p:name=&quot;张三&quot; p:car-ref=&quot;car1&quot;&gt; &lt;/bean&gt; --&gt; &lt;!-- SPEL注入 使用#&#123;&#125;作为定界符 就是给改变了 value的赋值 没有改变的是 property 可以为数、字符串、boolean、其他对象、其他对象的属性和方法、支持运算符 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;张三&apos;&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 调用其他类的方法 --&gt; &lt;bean id=&quot;calculate&quot; class=&quot;Spring.demo4.calculate&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;calculate.name&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 集合属性的注入======================一般用于不同的框架的整合= --&gt; &lt;bean id=&quot;collectionBean&quot; class=&quot;Spring.demo5.collectionBean&quot;&gt; &lt;!-- int数组的注入 --&gt; &lt;property name=&quot;arr&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- List&lt;String&gt;集合注入 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set&lt;String&gt;set集合注入 --&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- map&lt;int,String&gt;集合的注入 --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;张三&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;2&quot; value=&quot;李四&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;3&quot; value=&quot;王五&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2 . 通过注解方式 导包除了引入基本的开发包，还需要引入AOP包 引入约束文件哪里找？spring-framework-4.2.4.RELEASE-docs\\spring-framework-reference\\html中找xsd-configuration.html中找到Context约束（其中包含了beans约束，beans约束是Spring中最基本的约束） 开启组件扫描(在XML文件中)Code &lt;!--=====扫描是为了扫描类上的注解 ============--&gt;&lt;context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan&gt; 编写测试类 Codepackage demo1;public interface UserDao &#123; public void sava();&#125; Codepackage demo1;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(value=&quot;UserDaoImp&quot;)//相当于&lt;bean id=&quot;UserDaoImp&quot; class=&quot;demo1.UserDaoImp&quot;&gt;&lt;/bean&gt;public class UserDaoImp implements UserDao &#123; @Value(&quot;张三&quot;) private String name; //可以不提供set方法，则需要将属性的注解添加到属性上；若有set方法，则需要将属性的注入添加到set方法上 /*@Value(&quot;张三&quot;) public void setName(String name) &#123; this.name = name; &#125;*/ @Override public void sava() &#123; // TODO Auto-generated method stub System.out.println(&quot;sava()方法执行了。。&quot;); &#125; @Override public String toString() &#123; return &quot;UserDaoImp [name=&quot; + name + &quot;]&quot;; &#125;&#125; 说明：属性注入的注解分为以下类型 普通类型 @value（“”）设置普通属性的值 对象类型@Autowired：设置对象的属性的值。注意：按照类型完成属性注入，而不是名称，与Component（“CLassName”）无关 一般我们习惯按名称匹配下面两个同时写 @Autowired@Qualifier(value=”ClassName”) //强制使它按照名称的属性注入@Resource(name=”ClassName”)：完成对象属性的注入，等价于上面连续两个(开发中常用) Bean的其他注解 Codepackage demo2;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component(value=&quot;custom&quot;)//&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt;@Scope(&quot;prototype&quot;)public class custom &#123; @PostConstruct//初始化注解，相当于nit-method=&quot;init&quot; public void init()&#123; System.out.println(&quot;初始化方法执行了&quot;); &#125; public void save()&#123; System.out.println(&quot;save方法执行了&quot;); &#125; @PreDestroy//destory注解，相当于destory-method=&quot;destory&quot; public void destory()&#123; System.out.println(&quot;destory方法执行了&quot;); &#125;&#125; 说明： 生命周期相关的注解Code&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt; @PostConstruct：初始化方法@PreDestory：销毁方法 Bean的作用范围注解(重要)@Scope( “ ”) ：作用范围 Prototype : 多例 Request : Session: Globalsession:测试案例： Codepackage demo2;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void test1()&#123; ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); custom c = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c); custom c2 = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c2); &#125;&#125; 输出结果： Code初始化方法执行了demo2.custom@1d9d4b初始化方法执行了demo2.custom@1227d8d 说明：由于使用了@Scope(“prototype”)，多例模式初始化了两次，得到两个不同的id； 3 . 两种方式的比较 适用场景 XML：可以使用任何场景 结构清晰，维护方便 注解：必须修改源代码（如果你无法修改源代码，只能用XML） 开发方便，速度快 4 . XML与注解的整合开发思路：用XML用来管理类的注入，用注解完成属性的注入。测试案例：Codepackage Demo3;import org.springframework.stereotype.Component;//@Component(&quot;order&quot;)public class order &#123; public void play() &#123; System.out.println(&quot;生产产品&quot;); &#125;&#125; Codepackage Demo3;import javax.annotation.Resource;import org.springframework.stereotype.Component;//@Component(&quot;orderService&quot;)//相当于&lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;public class orderService &#123; @Resource(name=&quot;order&quot;)//这个name就是配置文件(applicationContext.xml)里面的或者 //如果是用的类上注解等同于@Component(value=”id/name”)中的id private order od; public orderService() &#123; System.out.println(&quot;无参构造方法被调用...&quot;); // TODO Auto-generated constructor stub &#125; public void t()&#123; od.play(); &#125;&#125; Codepackage Demo3;import javax.annotation.Resource;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class Test &#123; @Resource(name=&quot;orderService&quot;) private orderService se; @org.junit.Test public void test1()&#123; se.t(); &#125;&#125; 配置文件Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--=====扫描是为了扫描类上的注解 ============--&gt; &lt;!-- context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan--&gt; &lt;context:annotation-config/&gt; &lt;!-- =======在没有扫描的情况下，使用注解 @Resource @value、@Autowired、@Qulifier --&gt; &lt;bean id=&quot;peopleImp&quot; class=&quot;Demo1.peopleImp&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;order&quot; class=&quot;Demo3.order&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"Servlet注解开发","slug":"java基础/Servlet注解","date":"2019-02-22T16:00:00.000Z","updated":"2019-02-23T07:56:01.625Z","comments":true,"path":"2019/02/23/java基础/Servlet注解/","link":"","permalink":"http://SlectRxz.github.io/2019/02/23/java基础/Servlet注解/","excerpt":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter","text":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter 在Servlet3.0中新增注解的功能，降低了配置XML所花费的时间与精力。注意：Tmocat7.0以上支持 一、@WebServlet注解 作用：用来配置Servlet，其将会在服务器启动时被tomcat容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet，个人感觉就是替代了传统的在web.xml中的配置。 参数说明 属性名 类型 属性描述 name String 指定Servlet的name属性，相当于 value String[] 等价于urlPatterns,二者不能共存. urlpatterns String[] 指定一组servlet的url的匹配模式,等价于标签. loadOnStartup int 指定servlet的加载顺序,等价于标签. initParams WebInitParam[] 指定一组初始化参数,等价于标签. asyncSupported boolean 申明servlet是否支持异步操作模式,等价于标签. displayName String servlet的显示名,等价于标签. description String servlet的描述信息,等价于标签. 与传统Servlet相比注解实现 Codepackage annotate;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name=&quot;test2&quot;, value=&quot;/test2&quot; )public class test2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;页面执行了。。。&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 传统的Servlet的配置需要在Web.xml中添加Servlet的映射 Code&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;servlet-class&gt;annotate.test1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;url-pattern&gt;/test1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 二、@WebFilter 用来配置过滤器","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"注解开发","slug":"注解开发","permalink":"http://SlectRxz.github.io/tags/注解开发/"}]},{"title":"MVC+三层架构开发模式","slug":"java/MVC开发模式","date":"2019-01-16T16:00:00.000Z","updated":"2019-03-06T11:49:33.666Z","comments":true,"path":"2019/01/17/java/MVC开发模式/","link":"","permalink":"http://SlectRxz.github.io/2019/01/17/java/MVC开发模式/","excerpt":"Web开发模式","text":"Web开发模式 MVC Model:javabean:封装业务数据，模型 View：jsp：显示数据，视图 Controller:servlet:调度jsp和javabean资源，控制器 三层结构： dao层： 和数据访问相关的操作 service层： 和业务逻辑相关的操作 web层： 和用户直接交互相关的操作（传接参数，跳转页面） MVC+三层架构个人理解： service层(业务逻辑层)，比如说当我们添加用户时需要判断用户的id是否为空，此时service层负责判断后再调用dao层的方法，dao层只负责对数据的增删查改。 servlet负责调用业务逻辑（页面的调度），而不处理业务逻辑。真正处理业务逻辑的是service层。 从servlet-&gt;jsp (页面跳转过程) Code //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;);request.setCharacterEncoding(&quot;utf-8&quot;);//拿到对象 ，通过调用dao中的方法Contact contact=new ContactPerson();List&lt;Person&gt; list = contact.search();////shift+alt+A 区块选择，按一次进入选择模式，再按一次回来/** * ctrl+F 正则替换 ^(.*)$ \\1&quot;; * ^一行表示 * $结束表示 * \\1匹配里面的一行内容 替换为这个&quot;; *///将对象保存在域中request.setAttribute(&quot;contacts&quot;,list);//跳转到显示页面request.getRequestDispatcher(&quot;/listContact.jsp&quot;).forward(request, response); 从jsp-&gt;servlet一般我们用${pageContext.request.contextPath }来获取当前路径/QueryContactServlet?id=${con.id}是页面跳转的同时将id作为参数传递过去 Code&lt;!-- 直接用EL表达式从域对象中获取数据--&gt;&lt;c:forEach items=&quot;$&#123;contacts&#125;&quot; var=&quot;con&quot; varStatus=&quot;varsta&quot;&gt; &lt;tr&gt; &lt;th&gt;$&#123;varsta.count&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.name&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.gender&#125; &lt;/th&gt; &lt;th&gt;$&#123;con.email &#125;&lt;/th&gt; &lt;th&gt;$&#123;con.qq&#125;&lt;/th&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/QueryContactServlet?id=$&#123;con.id&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/DeleteContactServlet?id=$&#123;con.id&#125;&quot;&gt;删除&lt;/a&gt; //说明，此处的pageContext.request相当于pageContext.getRequest()方法，其在于先得到request对象，再调用request的方法。 &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 注意：此处设计到EL表达式 语法：${表达式或变量}表达式/变量是从域对象中得到的，也就是说，我们必须先往域对象中存储输出对象的某个成员：${student.name},其中student的对象必须有方法getName() form表单形式：Code&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/AddContactServlet&quot; method=&quot;post&quot;&gt; 项目结构：注意：不管是获取数据还是发送数据，都是以对象为基本单位，即JavaBean。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java反射","slug":"java/反射","date":"2019-01-06T16:00:00.000Z","updated":"2019-01-07T07:37:34.823Z","comments":true,"path":"2019/01/07/java/反射/","link":"","permalink":"http://SlectRxz.github.io/2019/01/07/java/反射/","excerpt":"Java反射机制","text":"Java反射机制 Java反射机制一、什么是反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 “程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。Java不是动态语言。但是Java有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的class。 二、理解Java反射要想理解反，必须得从“正”开始理解，一般而言，先有类再去实例化对象。Codepackage com.wz.reflectdemo;import java.util.Date;//先有类public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date();//再产对象 System.out.println(date); &#125;&#125; 而“反”就是通过对象找到类。在Object类中提供一个方法得到class对象。Codepublic final Class &lt;?&gt;getClass() 注：反射之中的所有泛型都定义为？，返回值为Object 三、Class类对象的实例化java.lang.Class是一个类，它与一般类一样继承Object。这个类是反射操作的源头，即所有的反射都从此类开始进行，下面介绍获取的三种方式。 方式一：调用Object的getClass()方法Codepackage com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;?&gt; cls = date.getClass(); System.out.println(cls); &#125;&#125; 运行结果：Codeclass java.until.Date 说明：这种方式相当于通过实例对象反向得到Class对象。 方式二、使用“类.class”获得Codepackage com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; //Date date = new Date(); Class&lt;?&gt; cls = Date.class; System.out.println(cls); &#125;&#125; 运行结果：Codeclass java.until.Date 说明：方法一中取得Class对象之前需要实例化，但是直接通过类名.Class没有实例化。 方法三、forName(String className) 注意：注意此字符串必须是真实路径，就是带包名的类路径，包名.类名Codepublic static Class&lt;?&gt;forName(String className) throws ClassNotFoundException 代码如下：Codepackage com.wz.reflectdemo;//import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(cls); &#125;&#125; 运行结果：Codeclass java.until.Date 注意：三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 四、反射实例化对象通过前面的步骤得到了Class对象，接下来利用反射实例化得到对象，得到方法和属性。 1、获取实例对象Codepublic T newInstance() throws InstantiationException,IllegalAccessException eg:Codepackage com.wz.reflectdemo;class Book&#123; public Book()&#123; System.out.println(&quot;Book类的无参构造方法&quot;); &#125; @Override public String toString() &#123; return &quot;This a book !&quot;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book); &#125;&#125; 运行结果：CodeBook类的无参构造方法This a book ! 注意：newInstance()只能调用默认无参构造方法。当我们所实例化的类中没有提供无参的构造方法时，会报错。此时我们需要获取有参的构造方法。 在Class类中，提供了方法来获取构造函数：（1）获取所有的构造函数：Codepublic Constructor&lt;?&gt;[] getConstructors() throws SecurityException （2）获取指定参数顺序的构造函数：Codepublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityExceptio 说明：以上两个类都返回“java.lang.reflect.Constructor”类的对象。该类中提供明确传递有参构造的方法：Codepublic T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException 实例：Codepackage com.wz.reflectdemo;import java.lang.reflect.Constructor;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); /*Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book);*/ Constructor&lt;?&gt; con = cls.getConstructor(String.class,double.class); Object obj = con.newInstance(&quot;Java开发&quot;,79.8);//实例化对象 System.out.println(obj); &#125;&#125; 执行结果：Code图书名称：Java开发 ,价格：79.8 2、调用方法和属性在Class类中获取方法有以下方式： （1）取得一个类中的全部方法Codepublic Method[] getMethods() throws SecurityException （2）得到指定方法Codepublic Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throwsNoSuchMethodException, SecurityException 以上方法返回都是“java.lang.reflect.Method”对象，在这个类中有一个调用方法：Codepublic Object invoke(Object obj, Object... args) throws IllegalAccessException,IllegalArgumentException, InvocationTargetException eg:Codepackage com.wz.reflectdemo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance(); Method setMet = cls.getMethod(&quot;setTitle&quot;, String.class); setMet.invoke(obj, &quot;Java开发&quot;);//等价于Book类的setTitle(&quot;Java开发&quot;) Method getMet = cls.getMethod(&quot;getTitle&quot;); System.out.println(getMet.invoke(obj));//等价于Book类的getTitle() &#125;&#125; 输出结果：Codejava 开发","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java注解","slug":"java/注解","date":"2019-01-04T16:00:00.000Z","updated":"2019-03-08T02:18:48.571Z","comments":true,"path":"2019/01/05/java/注解/","link":"","permalink":"http://SlectRxz.github.io/2019/01/05/java/注解/","excerpt":"有关java注解","text":"有关java注解 Java注解 出处：https://blog.csdn.net/briblue/article/details/73824058 注解的定义： 官方定义：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的 （看不懂） 注意：=注解要求：在开发中地位，类似于dom4j解析XML文件，XML文件的解析程序员不会去解析，配置XML文件。 容易理解的： 注解就是一个标签，标签上有着各种各样的含义，不同的标签可以贴在不同的代码上 自定义注解格式： 注解通过 @interface 关键字进行定义。 CodePublic @interface TestAnnotation&#123;&#125;@TestAnnotationPublic void Test()&#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，它的目的是给普通的注解进行说明的，说明某一注解的存活期、范围等等。 格式: public @interface 注解名称{ public 属性类型 属性名称1(); public 属性类型 属性名称2() default 默认值; }支持类型：基础类型，String，annotation，枚举类型，字节码class类型注意：不支持自定义类型元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable @RetentionRetention的英文为保留期的意思，当其应用到某一个注解上时，表达了这个注解的存活时间它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 可以理解为当使用@Retention解释标签时，指定了该标签的生命周期。Code@Retention(Retention.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码指定了标签TestAnotation可在程序运行的时候获取到。 @Documented作用：将注解的元素包含到JavaDoc当中。 @Target作用：指定了注解运用在何处。可以理解为当被@Target注解，就被限定了应用场景。类比标签，原本标签可以贴到任何地方，当我限制后，只能贴到指定的地方。@Target有下面的取值： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。Code@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。这样引用网上的例子理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。老子的孙子长大了，自然也是富豪。这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理(注：好的产品经理一般都是懂技术的，更容易沟通)。Code@interface Persons&#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;coder&quot;)@person(role=&quot;PM&quot;)public class CM&#123;&#125; 注意上面的代码，Repeatable注解了Person，而@Repeatable后面括号里的类相当于一个容器注解 容器注解就是用来存放其他注解的地方，本身也是一个注解Code@interface Persons&#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 CM 贴上，相当于同时给他贴了程序员、产品经理的标签。我们可能对于 @Person(role=”PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"JSP基础语法","slug":"java基础/JSP基础(一)","date":"2018-11-12T02:01:44.000Z","updated":"2018-12-03T08:37:26.813Z","comments":true,"path":"2018/11/12/java基础/JSP基础(一)/","link":"","permalink":"http://SlectRxz.github.io/2018/11/12/java基础/JSP基础(一)/","excerpt":"JSP基础语法","text":"JSP基础语法 ##Jsp基础## 4.1 Jsp引入 Servlet的作用： 用java语言开发动态资源的技术！！！Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！ Jsp就是servlet！！！ 4.2 Jsp的特点 1）jsp的运行必须交给tomcat服务器！！！！ tomcat的work目录： tomcat服务器存放jsp运行时的临时文件 2）jsp页面既可以写html代码，也可以写java代码。 （html页面不能写java代码 。而jsp页面可以写java代码） 4.3 体验jsp页面作用 需求：显示当前时间到浏览器上 可以把jsp页面当做html页面在tomcat中访问！！！ 4.4 Jsp的执行过程 问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 1）访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件 (01.hello.jsp-&gt; _01_hello_jsp.java) （翻译） 2）tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） 3）tomcat服务器构造_01_hello_jsp类对象 4）tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 1.第一次访问jsp：2.走（1）（2）（3）（4）3.第n次访问jsp：4.走（4）注意： 1）jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译（2）的过程 4.5 疑问 问题： 为什么Jsp就是servlet！！！ jsp翻译的java文件： public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage { 结论： Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 1）构造方法（第1次访问） 2）init方法（第1次访问） 3）service方法 4）destroy方法 Jsp的生命周期 1）翻译： jsp-&gt;java文件 2）编译： java文件-&gt;class文件（servlet程序） 3）构造方法（第1次访问） 4）init方法（第1次访问）：_jspInit() 5）service方法：_jspService() 6）destroy方法：_jspDestroy() ##Jsp语法## 5.1 Jsp模板 jsp页面中的html代码就是jsp的模板 5.2 Jsp表达式 语法：&lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式计算的结果 注意： 1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容 2）表达式后面不需要带分号结束。 5.3 Jsp的脚本 语法：&lt;%java代码 %&gt; 作用： 执行java代码 注意： 原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 就是在service方法中执行了一段java代码 5.4 Jsp的声明 语法：&lt;%! 变量或方法 %&gt; 作用： 声明jsp的变量或方法 注意: 1）变量翻译成成员变量，方法翻译成成员方法。 5.5 Jsp的注释 语法： &lt;%– jsp注释 –%&gt; 注意; 1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 ##Jsp的三大指令## 6.1 include指令 作用： 在当前页面用于包含其他页面 语法： &lt;%@include file=”common/header.jsp”%&gt; 注意： 1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一 个java源文件，再编译运行！！，这种包含叫静态包含（源码包含） 2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、 body） 6.2 page指令 作用： 告诉tomcat服务器如何翻译jsp文件 &lt;%@ page language=”java” –告诉服务器使用什么动态语言来翻译jsp文件 import=”java.util.*” –告诉服务器java文件使用什么包 导入包，多个包之间用逗号分割 pageEncoding=”utf-8” –告诉服务器使用什么编码翻译jsp文件（成java文件） contentType=”text/html; charset=utf-8” 服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage=”error.jsp” isErrorPage=”false” buffer=”8kb” session=”true” isELIgnored=”false” %&gt; 6.3 taglib指令 总结： 1）编码实战： 1.1 servlet应用 1.2 初步了解软件开发流程 2）Jsp基础 2.1 Jsp的执行原理（翻译-》编译-》servlet的生命周期） 2.2 语法（jsp表达式，jsp脚本） 2.3 指令 include指令 page指令","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"背景音乐添加步骤","slug":"addmusic","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-12T03:15:28.400Z","comments":true,"path":"2018/11/04/addmusic/","link":"","permalink":"http://SlectRxz.github.io/2018/11/04/addmusic/","excerpt":"关于博客如何添加背景音乐","text":"关于博客如何添加背景音乐 1、打开网易云音乐首页，然后搜索你要添加的背景音乐 2、搜索到歌曲点击生成外链播放器，进去下一个界面3、打开主题下的_partial文件夹下的left-col.ejs文件，选择iframe插件，赋值HTML代码到&lt;div&gt;&lt;/div&gt;中 注意：因为我想把这个播放器放在博客页面的左侧栏里，所以就把以上代码复制到主题文件夹下实现左侧栏的那个模板文件里，也就是left-col.ejs文件，（需要值得注意的是，因为所使用的主题不同，可能文件也就不一样，但是大致原理就如刚才我所提到的：想放在哪个区域，就把代码复制到实现那块区域的模板文件里）。 我的主题目录是YourBlogName\\themes\\smackdown\\layout\\_partial\\left-col.ejs。Code&lt;div style=&quot;position:absolute;bottom:100px;left:15px;width:60%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=250 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=543681750&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 注意： width与height调节播放页的大小","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://SlectRxz.github.io/categories/环境搭建/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"算法","slug":"背包问题","date":"2018-10-14T13:58:57.005Z","updated":"2019-12-20T12:18:13.284Z","comments":true,"path":"2018/10/14/背包问题/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/背包问题/","excerpt":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。","text":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 Code blockCode#include&lt;iostream&gt;#define MAX 20#define max(a,b) a&gt;b?a:busing namespace std;int D[MAX][MAX];int fill(int n,int v[],int b[],int c)&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=c;j++) &#123; If( j&lt;v[ I ] ) D[i][j]=D[i-1][j]; else D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);//解释：当背包的容量慢慢增加，此时大于这个物品v[i]，那么，我们需要判断//放物品 与 不放物品的价值哪个高。。。。。 &#125; return 1;&#125;int main()&#123; int n,v[MAX],b[MAX],c; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; cin&gt;&gt;c; fill(n,v,b,c); cout&lt;&lt;D[n][c];&#125;","categories":[{"name":"代码总结","slug":"代码总结","permalink":"http://SlectRxz.github.io/categories/代码总结/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://SlectRxz.github.io/tags/算法/"}]},{"title":"My first blog","slug":"hello-world","date":"2018-10-14T07:40:00.425Z","updated":"2018-11-08T09:07:05.337Z","comments":true,"path":"2018/10/14/hello-world/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/hello-world/","excerpt":"博客搭建记录","text":"博客搭建记录 找了很多教程，也看了一些视频，最后终于将其搭建好了，第一次写，有误请指正。 ####搭建环境准备： 安装Git：Git下载包64位. 下载node.js node.js下载地址 安装Hexo 利用npm命令即可安装。单击鼠标i右键，选着Git Bash","categories":[{"name":"搭建说明","slug":"搭建说明","permalink":"http://SlectRxz.github.io/categories/搭建说明/"}],"tags":[{"name":"blog记录","slug":"blog记录","permalink":"http://SlectRxz.github.io/tags/blog记录/"}]},{"title":"Linux基础（四）","slug":"Linux基础（四）","date":"2017-05-12T02:01:44.000Z","updated":"2018-10-16T11:40:21.032Z","comments":true,"path":"2017/05/12/Linux基础（四）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/12/Linux基础（四）/","excerpt":"Linux网络配置与使用","text":"Linux网络配置与使用 4、虚拟机linux上网问题4.1、VMware中虚拟机网络的三种设置第一种：桥接（bridged）第二种：NAT第三种：Host only 。该模式下仅主机可以上网，虚拟机不能上网。 4.2、虚拟机上网方式1：NAT方式设置步骤：第一步：在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择NAT模式第二步： vi /etc/network/interfaces，打开该文件，将内容编辑成为： auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 第三步：执行/etc/init.d/networking restart重启网卡 4.3、虚拟机上网方式2：桥接方式第一步：桥接。在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择桥接模式。第二步：桥接到可以上网的网卡。在菜单栏 编辑 -&gt; 虚拟网络编辑器，选择桥接到自己Windows中可以上网的网卡上（一般就是Wifi网络或者有线网络）第三步：设置dhcp并重启网卡。 vi /etc/network/interfaces，打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 保存退出。然后命令行执行/etc/init.d/networking restart重启网卡 4.4、总结第一，NAT方式设置上网比较简单，但是不能用在嵌入式开发中。第二，桥接方式设置上网较繁琐，但是在嵌入式开发中比较有用。 使用技巧：1、使用shell的Tab键自动补全Tab在linux命令行输入中可以自动完成。在linux 命令行中使用Tab键会极大提高输入效率2、使用shell的历史记录shell会记录用户执行命令的历史记录，而我们一般使用命令都会在短时间内集中反复使用因此当你需要使用一条刚才还使用过的命令时，不需再次花时间输入，只要按下键盘上下箭头按键，就可实现上下翻页，翻出刚才用过的命令，直接回车执行。就好像电话机的通话记录和快速回拨一样。3、linux命令行中一些符号的含义： . 代表当前目录 .. 代表上一层目录，当前目录的父目录 - 代表前一个目录，我刚才从哪个目录cd过来 ~ 代表当前用户的宿主目录 / 代表根目录 $ 普通用户的命令行提示符 # root用户的命令行提示符 * 万能匹配符 宿主目录：所谓宿主目录，就是操作系统为当前用户所设计的用来存放文件、工作的默认目录。如Windows中的“我的文档”目录，就是Windows为我们设计的宿主目录。Linux中每个用户都有自己的宿主目录，这个目录对于普通用户来说，在/home/username/，而对于root用户来说，在/root。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（三）","slug":"Linux基础（三）","date":"2017-05-11T02:01:44.000Z","updated":"2019-09-12T14:24:40.727Z","comments":true,"path":"2017/05/11/Linux基础（三）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/11/Linux基础（三）/","excerpt":"vi编辑器的使用","text":"vi编辑器的使用 3、编辑器vi的使用（vi和vim的联系）什么是编辑器？编辑器就是一款软件，它的主要作用就是用来编辑。譬如编写文件，编写代码。Windows中的常用编辑器，如自带的notepad。比较好用的notepad++，UltraEditor，SlickEditorLinux中常用编辑器，自带的最古老的vi。比较好用的vim，gedit。注：vi和vim的关系：vim是vi的升级版，推荐使用vim。我们在后面提到vi时，其实都是指vim。 3.1、vi基础使用使用vi来打开/创建一个文件，vi pathname vi的两种模式：命令模式：当vi打开时默认为命令模式，要转入输入模式，需要按a或者i键。在命令模式下，此时键盘上输入的所有东西都被vi当作命令来对待。在命令模式下，最好不要乱输入。此时应该输入相应的命令，来让vi做相应的事。输入模式：输入模式用来向文件输入内容。可以从命令模式中按a或者i进入输入模式。进入输入模式后，就可以随意按键盘进行输入了。输入完成后如果要保存，要先退回到命令模式（因为保存也是一种命令）。在输入模式下按ESC键退回到命令模式。注：注意看屏幕左下角，当命令模式时无提示信息或者提示文件名等信息，等处于输入模式时，提示 – INSERT –在命令模式下如何保存：:wq 保存并且退出:w 只保存不推出:q 不保存退出 进来看了一下没改退出:q! 不保存强制退出:wq! 保存并强制退出 3.2、vi的高级使用 查找在命令模式下，输入/xxx，就可以查找到xxx 快速切换行在命令模式下，输入:num，就可以快速切换到num行 设置显示行号在命令模式下，输入:set nu，就可以显示行号 注：设置不显示行号，命令模式输入:set nonu设置永久显示行号，需要修改vi的配置文件。打开vi的配置文件~/.vimrc，在其中输入set nu即可。 行删除命令模式下，先将光标移动到要删除的行，然后输入dd如果要删除连续多行，譬如要删除连续的3行，使用3dd 行复制粘贴复制：命令模式下，nyy粘贴：命令模式下，p细节，复制时要把光标放在多行的第一行，粘贴时实际粘贴到当前光标所在行的下一行。 3.3、linux中权限表示&amp;管理3.3.1、普通用户与特权用户 su命令切换用户Windows中有普通用户和特权用户，特权用户是Administrator，普通用户可以有很多个。特权用户是系统的管理员，对系统内所有文件具有操作权限。每个普通用户只能处理自己的文件，不能访问其他用户的文件，更不能随意处理操作系统的文件。Linux中也有普通用户和特权用户的区别。特权用户就是root用户。普通用户权限受到限制，譬如说普通用户不能cd /root，普通用户不能使用apt-get install 来装软件。 可以使用su 用户名来在不同用户间切换。譬如要从普通用户切换到root，可以su root，然后输入root的密码即可转入root用户。从root要切换到普通用户gec，则su gec即可。 3.3.2、rwx与权限表示ls -l显示详细信息drwxr-xr-x 10个字符，第一个表示文件类型。剩下的9个分成3组，表示文件权限。前三个表示此文件的属主对文件的权限中间三个表示此文件属主所在的组对文件的权限最后三个表示其他用户对文件的权限rwx怎么解析：r代表可读，w代表可写，x代表可执行rwx：可读，可写，可执行r-x: 可读，不可写，可执行r–: 可读，不可写，不可执行 3.3.3、使用sudo暂时获取root权限这是ubuntu的一个特点，在ubuntu中可以使用sudo命令让普通用户暂时获取root用户的权限，而不必进行用户切换。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（二）","slug":"Linux基础（二）","date":"2017-05-08T02:01:44.000Z","updated":"2018-10-16T11:40:15.881Z","comments":true,"path":"2017/05/08/Linux基础（二）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/08/Linux基础（二）/","excerpt":"关于Linux的基本介绍以及简单命令的概述","text":"关于Linux的基本介绍以及简单命令的概述 2、linux基础知识与技能2.1、linux内核、发行版linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。ubuntu、redhat就是linux的不同的发行版。 2.2、GUI（图形用户界面）和cmdline（命令行）GUI：grahics user interface，图形用户界面。cmdline：command line，命令行。人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。但是，在linux中我们常用命令行，在Windows中常用GUI 2.3、linux常用命令：(1) ls（list，列表）作用：使用列表把当前文件夹下所有文件显示出来 ls -a 显示所有文件，包括隐藏文件 ls -l 以详细信息显示 ls -a -l ls -l -a ls -la ls -al 四种方式都是可以的 ls -al ~ ：列出自己主文件夹下的所有隐藏文件与相关的文件属性 (2) cd（change directory，更改目录）作用：用来切换目录涉及到相对路径和绝对路径cd .. ..代表上一层目录 .代表当前目录 (3) pwd（print work directory，打印工作目录）作用：打印出当前的绝对路径 (4) mkdir（make directory，创建文件夹）作用：创建空文件夹 mkdir -p 级联创建文件夹(5) mv（move，移动）作用：在目录间移动文件，重命名文件 mv 源文件pathname 目的文件pathname (6) touch作用：创建空文件 touch pathname (7) cp（copy，复制）作用：复制文件或文件夹 cp 源文件pathname 目标文件pathname cp -r 用来复制文件夹 cp -f 强制复制实际操作时，一般都是cp -f复制文件，cp -rf复制文件夹 (8) rm（remove，去除，删除）作用：用来删除文件，文件夹 rm 文件pathname rm -r 文件夹pathname (9) cat作用：直接在命令行下显示文件内容 也可以用来向文件输入，暂时不管 (10)rmdir（remove directory，删除文件夹）作用：删除空文件夹rmdir和rm -r的区别：rmdir只能删除空文件夹，而rm -r可以删除空文件夹和非空文件夹 (11) ln（link，连接文件）基础：windows中快捷方式，实际上快捷方式和它指向的文件是独立的两个文件，两个都占硬盘空间，只不过用户访问快捷方式时，其效果等同于访问指向的文件。 linux中有两种连接文件：一种叫软连接（符号连接），等同于windows中快捷方式一种叫硬连接创建软连接文件： ln -s 源文件名 符号连接文件名举例：ln -s src.c，linker.c， linker.c就是src.c的一个符号连接文件 硬连接：ln 源文件名 连接文件名硬连接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬连接存在，这个文件就不会被真正删除。只有等所有的连接文件都删除掉了，这个文件才会被真正从硬盘上删除。 基础知识：1、ls -l显示的详细信息中：-rw-r–r–drwxr-xr-x一共10个字符，第一个字符表示文件类型，后面9个字符表示文件权限。文件类型： 表示普通文件。普通文件指文本文件和二进制 文件，如a.c 1.txt a.out都是普通文件d 表示文件夹，d是directory的缩写l 表示符号连接文件，后面会用-&gt;打印出它指向的文件s 表示socket文件p 表示管道文件 pipe","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（一）","slug":"Linux基础（一）","date":"2017-05-05T02:01:44.000Z","updated":"2018-10-16T11:40:10.897Z","comments":true,"path":"2017/05/05/Linux基础（一）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/05/Linux基础（一）/","excerpt":"操作系统、相对路径与绝对路径的简介","text":"操作系统、相对路径与绝对路径的简介 1、操作系统基础概念1.1、Windows与linux的关系当前主流的操作系统：windows、、android、iOS、symbian、linux/unix Windows：傻瓜式、好学习、工资低Linux：linux认为每一个用户都是专业人士，操作麻烦，学习比较难，免费的、开源的，linux性能好，可移植性好，好的设计理念Android：移动操作系统，android基于linuxiOS：很优秀，创造性，走钢丝 嵌入式操作系统：linux + WinCE当前：消费电子Android，工业linux 1.2、多机开发：双系统与虚拟机开发嵌入式程序，需要linux环境。但是因为：windows中有许多很好用的软件，如notepad++、SourceInsight，所以也需要windows。 第一种：双系统 不方便第二种：虚拟机 方便，损失性能，与 真机微小差异第三种：两台电脑：不方便 现实中：个人开发者：虚拟机大公司：服务器+客户端 1.3、搭建开发环境涉及到两个东西：虚拟机软件+linux系统虚拟机软件：就是一个单纯的在windows中运行的软件，跟word、360没有本质区别。现在主流的虚拟机软件有VMWare和VirtualBox虚拟机软件在windows系统中运行，运行后它会模拟出来一个电脑，所以叫虚拟机。然后我们可以在该虚拟机中安装别的操作系统。当前，可以先使用事先安装好的aston_ubuntu，密码是root。自己上网搜索安装教程。 1.4、隐藏文件与非隐藏文件Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件和文件夹。Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls） 1.5、相对路径与绝对路径什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。举例：D:\\winshare\\enum.c全路径pathnameD:\\winshare路径 path`enum.c文件名 name 绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\\），linux中从根目录/开始相对路径：指明路径的时候，是从当前所在的位置开始的。 举例：D:\\我的文档\\123\\123.txtD:\\我的文档\\abc\\abc.txt当前在123.txt，但是要去abc.txt方式1：采用绝对路径。D:\\我的文档\\abc\\abc.txt方式2：采用相对路径。../abc/abc.txt从当前路径开始，往上走一层，再往下走一层（abc）就到了 测试：/abc/123/def.txt 是linux绝对路径abc/123/def.txt 不是linux绝对路径F:\\abc\\123\\def.txt 是windows绝对路径abc\\123\\def.txt 不是windows绝对路径","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]}]}