{"meta":{"title":"荣先森","subtitle":null,"description":null,"author":"Rong","url":"http://SlectRxz.github.io"},"pages":[],"posts":[{"title":"四大域对象","slug":"java/javaWeb基础之域对象","date":"2019-02-27T16:00:00.000Z","updated":"2019-02-27T13:15:55.247Z","comments":true,"path":"2019/02/28/java/javaWeb基础之域对象/","link":"","permalink":"http://SlectRxz.github.io/2019/02/28/java/javaWeb基础之域对象/","excerpt":"四大域对象的生命周期、作用范围、作用的总结。","text":"四大域对象的生命周期、作用范围、作用的总结。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960根据有作用范围由小到大：page(jsp有效)------》page域指的是pageContext.request(一次请求)---》request域request HttpServletContextsession(一次会话)---》session域session HttpSessionapplication(当前web应用)---》application域指的是application ServletContext；之所以他们是域对象，原因是他们都内置了map集合，都有setAttribute和getAttribute方法。一、PageContext域1.生命周期：当对JSP的请求开始，当相应结束时销毁。 jsp页面被执行，声明周期开始； jsp页面执行完毕，声明周期结束；2.作用范围：整个JSP页面，是四大作用域中最小的一个。3.作用： （1）获取其它八大隐式对象，可以认为是一个入口对象。 （2）获取其所有域中的数据 pageContext 操作所有域中属性的方法 public java.lang.Object getAttribute(java.lang.String name,int scope) public void setAttribute(java.lang.String name, java.lang.Object value,int scope) public void removeAttribute(java.lang.String name,int scope) pageContext 中代表域的常量 PageContext.APPLICATION_SCOPE PageContext.SESSION_SCOPE PageContext.REQUEST_SCOPE PageContext.PAGE_SCOPE findAttribute方法,在四大域中搜寻属性，搜寻的顺序是page域、request域、session域、application域，从小域到大域开始搜索，如果搜索到就直接获取该值，如果所有域中都找不到，返回一个null(与el表达式不同，此处返回null，对网页是不友好的) （3）跳转到其他资源 其身上提供了forward和include方法，简化重定向和转发的操作二、Request域1.生命周期： 在Service方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。 用户发送一个请求，开始，服务器返回响应，请求结束，生命周期结束；2.作用范围：整个请求链（请求转发也存在）3.作用：在整个请求链中共享数据，经常用到：在servlet中处理好的数据交给JSP显示，此时参数就可以放在Request域中。三、HttpSession 域1.生命周期： 在第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有就在内存中创建一个session并返回。（1）当一段时间内session没有被使用（默认为30分钟），则服务器会销毁该session。（2）如果服务器非正常关闭，没有到期的session也会跟着销毁。（3）如果调用session提供的invalidate()，可以立即销毁session。用户打开浏览器访问，创建session（开始），session超时或者被声明失效，该对象生命周期结束；2.作用范围：一次会话。HttpSession 在服务器中，为浏览器创建独一无二的内存空间，在其中保存会话相关的信息注意：服务器正常关闭，再启动，Session对象会进行钝化和活化操作。同时如果服务器钝化的时间在session 默认销毁时间之内， 则活化后session还是存在的。否则Session不存在。 如果JavaBean 数据在session钝化时，没有实现Serializable 则当Session活化时，会消失。四、ServletContext1.生命周期： 当WEB应用被加载进容器创建代表整个WEB应用的ServletContext对象； 当服务器关闭或WEB应用被移除时，ServletContext对象跟着被销毁。2.作用范围：整个WEB应用。3、作用： a)在不同Servlet 之间转发 this.getServletContext().getRequestDispatcher(&quot;/servlet/Demo10Servlet&quot;).forward(request,response); 方法执行结束，service就会返回到服务器，再有服务器去调用目标servlet，其中request会重新创建，并将之前的request的数据拷贝进去。 b)读取资源文件。1、由于相对路径默认相对的是java虚拟机启动的目录，所以我们直接写相对路径将会是相对于tomcat/bin目录，所以是拿不到资源的。如果写成绝对路径，当项目发布到其他环境时，绝对路径就错了。 为了解决这个问题ServletContext提供了：this.getServletContext().getRealPath(&quot;/1.properties&quot;)，给进一个资源的虚拟路径，将会返回该资源在当前环境下的真实路径。 this.getServletContext().getResourceAsStream(&quot;/1.properties&quot;)，给一个资源的虚拟路径返回到该资源真实路径的流。 2、当在非servlet下获取资源文件时，就没有ServletContext对象用了，此时只能用类加载器 classLoader.getResourceAsStream(&quot;../../1.properties&quot;)，此方法利用类加载器直接将资源加载到内存中，有更新延迟的问题，以及如果文件太大，占用内存过大。 classLoader.getResource(&quot;../1.properties&quot;).getPath()，直接返回资源的真实路径，没有更新延迟的问题。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"监听器与过滤器","slug":"java/javaWeb基础之Listener&Filter","date":"2019-02-26T16:00:00.000Z","updated":"2019-02-27T13:15:33.427Z","comments":true,"path":"2019/02/27/java/javaWeb基础之Listener&Filter/","link":"","permalink":"http://SlectRxz.github.io/2019/02/27/java/javaWeb基础之Listener&Filter/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Listener &amp; FilterListener 监听器 能做什么事？ 监听某一个事件的发生。 状态的改变。 监听器的内部机制 其实就是接口回调. 接口回调 需求： A在执行循环，当循环到5的时候， 通知B。 事先先把一个对象传递给 A ， 当A 执行到5的时候，通过这个对象，来调用B中的方法。 但是注意，不是直接传递B的实例，而是传递一个接口的实例过去。 Web监听器 总共有8个 划分成三种类型 监听器使用： 定义一个类，实现接口 注册 | 配置监听器 1.监听三个作用域创建和销毁request —httpServletRequest session —httpSession application — ServletContext 1. ServletContextListener servletcontext在什么时候创建？ 1. 启动服务器的时候 servletContext销毁： 2. 关闭服务器. 从服务器移除项目 2. ServletRequestListener request创建: 访问服务器上的任意资源都会有请求出现。 访问 html： 会 访问 jsp: 会 访问 servlet : 会 request销毁： 服务器已经对这次请求作出了响应。 public class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 销毁了&quot;); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(&quot;servletrequest 初始化了&quot;); } } &lt;listener&gt; &lt;listener-class&gt;com.itheima.listener.MyRequestListener&lt;/listener-class&gt; &lt;/listener&gt; 3. HttpSessionListener session的创建 只要调用getSession html: 不会 jsp: 会 getSession(); servlet: 会 session的销毁 超时 30分钟 非正常关闭 销毁 正常关闭服务器(序列化) public class MySessionListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent se) { System.out.println(&quot;创建session了&quot;); } @Override public void sessionDestroyed(HttpSessionEvent se) { System.out.println(&quot;销毁session了&quot;); } } 作用： ServletContextListener 利用它来，在servletcontext创建的时候， 1. 完成自己想要的初始化工作 2. 执行自定义任务调度。 执行某一个任务。 Timer HttpSessionListener 统计在线人数. 2.监听三个作用域属性状态变更 可以监听在作用域中值 添加 | 替换 | 移除的动作。 servletContext — ServletContextAttributeListener request — ServletRequestAttributeListener session — HttpSessionAttributeListener 监听httpSession里面存值的状态变更 这一类监听器不用注册。 HttpSessionBindingListener 监听对象与session 绑定和解除绑定 的动作 （就是监听这个值在不在session中） 1. 让javaBean 实现该接口即可 @Override public void valueBound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被绑定进来了&quot;); } @Override public void valueUnbound(HttpSessionBindingEvent event) { System.out.println(&quot;对象被解除绑定&quot;); } HttpSessionActivationListener 用于监听检测现在session的值 是 钝化 （序列化）还是活化 （反序列化）的动作注意：serializable接口，标志着该类可以实现序列化与反序列化，要想该类能够实现序列化与反序列化，必须继承该类 钝化 （序列化） 把内存中的数据 存储到硬盘上 活化 （反序列化） 把硬盘中的数据读取到内存中。 session的钝化活化的用意何在 session中的值可能会很多， 并且我们有很长一段时间不使用这个内存中的值， 那么可以考虑把session的值可以存储到硬盘上【钝化】，等下一次在使用的时候，在从硬盘上提取出来。 【活化】 如何让session的在一定时间内钝化. 做配置即可 1. 在tomcat里面 conf/context.xml 里面配置 对所有的运行在这个服务器的项目生效 2. 在conf/Catalina/localhost/context.xml 配置 对 localhost生效。 localhost:8080 3. 在自己的web工程项目中的 META-INF/context.xml 只对当前的工程生效。 maxIdleSwap ： 1分钟不用就钝化 directory ： 钝化后的那个文件存放的目录位置。 D:\\tomcat\\apache-tomcat-7.0.52\\work\\Catalina\\localhost\\ListenerDemo\\itheima &lt;Context&gt; &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt; &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;itheima&quot;/&gt; &lt;/Manager&gt; &lt;/Context&gt; Filter 过滤器 ， 其实就是对客户端发出来的请求进行过滤。 浏览器发出， 然后服务器派servlet处理。 在中间就可以过滤， 其实过滤器起到的是拦截的作用。 作用 对一些敏感词汇进行过滤 统一设置编码 自动登录 … 如何使用Filter 定义一个类， 实现Filter public class FilterDemo implements Filter { public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(&quot;来到过虑器了。。。&quot;); chain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { } } 注册过滤器 在web.xml里面注册，注册的手法与servlet基本一样。 &lt;filter&gt; &lt;display-name&gt;FilterDemo&lt;/display-name&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;filter-class&gt;com.itheima.filter.FilterDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的生命周期 创建 在服务器启动的时候就创建。 销毁 服务器停止的时候。 ###Filter执行顺序 客户端发出请求，先经过过滤器， 如果过滤器放行，那么才能到servlet 如果有多个过滤器， 那么他们会按照注册的映射顺序 来 排队。 只要有一个过滤器， 不放行，那么后面排队的过滤器以及咱们的servlet都不会收到请求。 Filter细节： init方法的参数 FilterConfig , 可以用于获取filter在注册的名字 以及初始化参数。 其实这里的设计的初衷与ServletConfig是一样的。 如果想放行，那么在doFilter 方法里面操作，使用参数 chain chain.doFilter(request, response); 放行， 让请求到达下一个目标。 /* 写法格式与servlet一样。 全路径匹配 以 / 开始 /LoginServlet 以目录匹配 以 / 开始 以 * 结束 /demo01/* 以后缀名匹配 以 * 开始 以后缀名结束 .jsp .html *.do 针对 dispatcher 设置 REQUEST ： 只要是请求过来，都拦截，默认就是REQUEST FORWARD : 只要是转发都拦截。 ERROR ： 页面出错发生跳转 INCLUDE ： 包含页面的时候就拦截。 自动登录 需求分析 1. 搭建环境 搭建数据库 搭建页面 登录servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String autoLogin = request.getParameter(&quot;auto_login&quot;); UserBean user = new UserBean(); user.setUsername(userName); user.setPassword(password); UserDao dao = new UserDaoImpl(); UserBean userBean = dao.login(user); if(userBean != null){ //成功了，进入首页 request.getSession().setAttribute(&quot;userBean&quot;, userBean); response.sendRedirect(&quot;index.jsp&quot;); }else{ //不成功... request.getRequestDispatcher(&quot;login.jsp&quot;).forward(request, response); } } catch (SQLException e) { e.printStackTrace(); } } 过滤器代码 过滤器的核心不是完成拦截不给 ， 还是放行显示。 它的核心是在放行之前，帮用户完成登录的功能。 实现思路 先判断session是否有效， 如果有效，就不用取cookie了，直接放行。 如果session失效了，那么就取 cookie。 没有cookie 放行 有cookie 1. 取出来cookie的值，然后完成登录 2. 把这个用户的值存储到session中 3. 放行。 /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ public void doFilter(ServletRequest req, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { HttpServletRequest request = (HttpServletRequest) req; //先判断，现在session中还有没有那个userBean. UserBean userBean = (UserBean) request.getSession().getAttribute(&quot;userBean&quot;); //还有，有效。 if(userBean != null){ chain.doFilter(request, response); }else{ //代表session失效了。 //2. 看cookie。 //1. 来请求的时候，先从请求里面取出cookie , 但是cookie有很多的key-value Cookie[] cookies = request.getCookies(); //2. 从一堆的cookie里面找出我们以前给浏览器发的那个cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;auto_login&quot;); //第一次来 if(cookie == null){ chain.doFilter(request, response); }else{ //不是第一次。 String value = cookie.getValue(); String username = value.split(&quot;#itheima#&quot;)[0]; String password = value.split(&quot;#itheima#&quot;)[1]; //完成登录 UserBean user = new UserBean(); user.setUsername(username); user.setPassword(password); UserDao dao = new UserDaoImpl(); userBean = dao.login(user); //使用session存这个值到域中，方便下一次未过期前还可以用。 request.getSession().setAttribute(&quot;userBean&quot;, userBean); chain.doFilter(request, response); } } } catch (Exception e) { e.printStackTrace(); chain.doFilter(req, response); } } BeanUtils的使用 BeanUtils.populate(bean, map); //注册自己的日期转换器 ConvertUtils.register(new MyDateConverter(), Date.class); //转化数据 Map map = request.getParameterMap(); UserBean bean = new UserBean(); 转化map中的数据，放置到bean对象身上 BeanUtils.populate(bean, map); 总结Listener8个 三种类型 针对三个作用域的创建和销毁 针对三个作用域的值改变 【添加 | 替换 | 移除】 针对session中的值 【钝化 活化】 ， 【绑定 解绑】 钝化 ( 序列化 ) 内存中的对象存储到硬盘 超时失效。 session销毁了。 非正常关闭服务器， 钝化 。 正常关闭服务器 销毁 设置了session，多久时间。 context.xml 活化 (反序列化) 从硬盘里面读取到内存 ServletContextListner ： 应用被部署的时候， 服务器加载这个项目的时候，做一些初始化工作， 任务调度。HttpSessionListener ： 统计在线人数HttpSessionActivationListener ： 钝化活化处理 ##Filter 使用频率更高 如果要写一个过滤器。 定义一个类，实现接口 Filter 注册 . web.xml . 与servlet相似。 过滤器放行。 chain.doFilter(request, response); 过滤器生命周期 创建： 服务器加载这个项目的时候创建实例 销毁： 关闭服务器或者从服务器中移除项目的时候。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"javaWeb基础","slug":"javaWeb基础","permalink":"http://SlectRxz.github.io/tags/javaWeb基础/"}]},{"title":"Spring学习日志（1）","slug":"java/Spring学习(1)","date":"2019-02-24T16:00:00.000Z","updated":"2019-02-27T02:00:53.542Z","comments":true,"path":"2019/02/25/java/Spring学习(1)/","link":"","permalink":"http://SlectRxz.github.io/2019/02/25/java/Spring学习(1)/","excerpt":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较","text":"Spring框架的IOC开发的两种模式，包括XML开发与注解开发的比较 Spring的简介什么是Spring Spring是一个开源框架，于2003年兴起的轻量级java开发框架，简单而言，Spring是一个分层的JAVASE/EEfull-stack（一站式）开源框架 Spring入门（IOC）一、什么是IOC IOC（Inversion of Control）：控制反转。控制反转：将对象的控制权反转交给Spring 导包 (官网：http://SPring.io/) 引入约束文件 在spring的解压路径下spring-framework-4.2.4.RELEASE\\docs\\spring-framework-reference\\html\\xsd-configuration.html 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; Spring底层实现原理： Spring学习路线 把类交给Spring处理，有两种方式 1 . 通过XML配置方式123456789package Spring.demo1;/** * 业务管理层的接口 * @author rong * */public interface UserService &#123; public void add();&#125; 123456789101112131415161718package Spring.demo1;/** * 业务管理层的实现类 * @author rong * */public class UserServiceImp implements UserService &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public void add() &#123; // TODO Auto-generated method stub System.out.println(&quot;UserServiceImp被执行了&quot;+name); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package Spring.demo1;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Test &#123; @org.junit.Test public void demo1()&#123;// UserService user=new UserServiceImp(); UserServiceImp user=new UserServiceImp(); user.setName(&quot;张三&quot;); user.add(); &#125; /** * Spring 方式的调用 */ @org.junit.Test public void demo2()&#123; /** * 创建Spring工厂 */ ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;application.xml&quot;); UserService User = (UserService) applicationContext.getBean(&quot;UserService&quot;); User.add(); &#125; @org.junit.Test public void demo3()&#123; /** * 加载磁盘上的配置文件 */ ApplicationContext applicationContext=new FileSystemXmlApplicationContext(&quot;D:\\\\111\\\\application.xml&quot;); UserService user = (UserService) applicationContext.getBean(&quot;UserService&quot;); user.add(); &#125;&#125; XML配置文件其中包括了属性的注入（通过构造函数或Set方法）SPEL的/font&gt;的注入集合的注入的注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring 入门的配置 id 相当于Spring生成类时，该类的一个编号，，，用于getBean() name 作用与上面相同 class 生成类的地址 包名.类名 init-method Spring在初始化该类的时候所执行的方法 destory-method Spring在关闭工厂的时候所执行的方法 scope 所创建的类是 单例模式-无论getBean几次，都只new一次（singleton） 多例模式-getBean几次就new几次 （prototype） request 生成的对象存放在域中 session 同上 globalsession 作用见word factory-method 在类初始化时，若不写默认调用无参的构造方法，若想指定构造方法，则使用该方法 --&gt; &lt;bean id=&quot;UserService&quot; class=&quot;Spring.demo1.UserServiceImp&quot; &gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;Custom&quot; class=&quot;Spring.demo2.CustomImp&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot; scope=&quot;prototype&quot; &gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;Spring.demo3.person&quot; &gt; &lt;/bean&gt; &lt;!-- 属性的注入 有两种方式 1.通过构造方式（有参构造） &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; 2.通过类的set方法 &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; 注意： 当成员不在是简单的属性，而实某一个对象时，value变为ref --&gt; &lt;bean id=&quot;car1&quot; class=&quot;Spring.demo4.car1&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;奔驰&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;price&quot; value=&quot;12220.0&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;东风&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;1212.0&quot;&gt;&lt;/property&gt; &lt;/bean &gt; --&gt; &lt;!-- 改用P名称空间注入 --&gt; &lt;bean id=&quot;car2&quot; class=&quot;Spring.demo4.car2&quot; p:name=&quot;东风&quot; p:price=&quot;4212.0&quot; &gt; &lt;/bean&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; --&gt; &lt;!-- 改用P名称 空间注入 注意： P名称空间注入走的也是set方法, 官方目的是简化set注入的property标签的写法 有set方法就不要有 有参的构造方法 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot; p:name=&quot;张三&quot; p:car-ref=&quot;car1&quot;&gt; &lt;/bean&gt; --&gt; &lt;!-- SPEL注入 使用#&#123;&#125;作为定界符 就是给改变了 value的赋值 没有改变的是 property 可以为数、字符串、boolean、其他对象、其他对象的属性和方法、支持运算符 --&gt; &lt;!-- &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;张三&apos;&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- 调用其他类的方法 --&gt; &lt;bean id=&quot;calculate&quot; class=&quot;Spring.demo4.calculate&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;staff&quot; class=&quot;Spring.demo4.staff&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;calculate.name&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 集合属性的注入======================一般用于不同的框架的整合= --&gt; &lt;bean id=&quot;collectionBean&quot; class=&quot;Spring.demo5.collectionBean&quot;&gt; &lt;!-- int数组的注入 --&gt; &lt;property name=&quot;arr&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- List&lt;String&gt;集合注入 --&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Set&lt;String&gt;set集合注入 --&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;value&gt;王五&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- map&lt;int,String&gt;集合的注入 --&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;1&quot; value=&quot;张三&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;2&quot; value=&quot;李四&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;3&quot; value=&quot;王五&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2 . 通过注解方式 导包除了引入基本的开发包，还需要引入AOP包 引入约束文件哪里找？spring-framework-4.2.4.RELEASE-docs\\spring-framework-reference\\html中找xsd-configuration.html中找到Context约束（其中包含了beans约束，beans约束是Spring中最基本的约束） 开启组件扫描(在XML文件中)12 &lt;!--=====扫描是为了扫描类上的注解 ============--&gt;&lt;context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan&gt; 编写测试类 12345package demo1;public interface UserDao &#123; public void sava();&#125; 1234567891011121314151617181920212223242526package demo1;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(value=&quot;UserDaoImp&quot;)//相当于&lt;bean id=&quot;UserDaoImp&quot; class=&quot;demo1.UserDaoImp&quot;&gt;&lt;/bean&gt;public class UserDaoImp implements UserDao &#123; @Value(&quot;张三&quot;) private String name; //可以不提供set方法，则需要将属性的注解添加到属性上；若有set方法，则需要将属性的注入添加到set方法上 /*@Value(&quot;张三&quot;) public void setName(String name) &#123; this.name = name; &#125;*/ @Override public void sava() &#123; // TODO Auto-generated method stub System.out.println(&quot;sava()方法执行了。。&quot;); &#125; @Override public String toString() &#123; return &quot;UserDaoImp [name=&quot; + name + &quot;]&quot;; &#125;&#125; 说明：属性注入的注解分为以下类型 普通类型 @value（“”）设置普通属性的值 对象类型@Autowired：设置对象的属性的值。注意：按照类型完成属性注入，而不是名称，与Component（“CLassName”）无关 一般我们习惯按名称匹配下面两个同时写 @Autowired@Qualifier(value=”ClassName”) //强制使它按照名称的属性注入@Resource(name=”ClassName”)：完成对象属性的注入，等价于上面连续两个(开发中常用) Bean的其他注解 1234567891011121314151617181920212223package demo2;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component(value=&quot;custom&quot;)//&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt;@Scope(&quot;prototype&quot;)public class custom &#123; @PostConstruct//初始化注解，相当于nit-method=&quot;init&quot; public void init()&#123; System.out.println(&quot;初始化方法执行了&quot;); &#125; public void save()&#123; System.out.println(&quot;save方法执行了&quot;); &#125; @PreDestroy//destory注解，相当于destory-method=&quot;destory&quot; public void destory()&#123; System.out.println(&quot;destory方法执行了&quot;); &#125;&#125; 说明： 生命周期相关的注解1&lt;bean id=&quot;custom&quot; class=&quot;demo2&quot; init-method=&quot;init&quot; destory-method=&quot;destory&quot;&gt;&lt;/bean&gt; @PostConstruct：初始化方法@PreDestory：销毁方法 Bean的作用范围注解(重要)@Scope( “ ”) ：作用范围 Prototype : 多例 Request : Session: Globalsession:测试案例： 123456789101112131415package demo2;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; @org.junit.Test public void test1()&#123; ApplicationContext applicationContext=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); custom c = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c); custom c2 = (custom) applicationContext.getBean(&quot;custom&quot;); System.out.println(c2); &#125;&#125; 输出结果： 1234初始化方法执行了demo2.custom@1d9d4b初始化方法执行了demo2.custom@1227d8d 说明：由于使用了@Scope(“prototype”)，多例模式初始化了两次，得到两个不同的id； 3 . 两种方式的比较 适用场景 XML：可以使用任何场景 结构清晰，维护方便 注解：必须修改源代码（如果你无法修改源代码，只能用XML） 开发方便，速度快 4 . XML与注解的整合开发思路：用XML用来管理类的注入，用注解完成属性的注入。测试案例：123456789package Demo3;import org.springframework.stereotype.Component;//@Component(&quot;order&quot;)public class order &#123; public void play() &#123; System.out.println(&quot;生产产品&quot;); &#125;&#125; 12345678910111213141516package Demo3;import javax.annotation.Resource;import org.springframework.stereotype.Component;//@Component(&quot;orderService&quot;)//相当于&lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;public class orderService &#123; @Resource(name=&quot;order&quot;)//这个name就是配置文件(applicationContext.xml)里面的或者 //如果是用的类上注解等同于@Component(value=”id/name”)中的id private order od; public orderService() &#123; System.out.println(&quot;无参构造方法被调用...&quot;); // TODO Auto-generated constructor stub &#125; public void t()&#123; od.play(); &#125;&#125; 12345678910111213141516package Demo3;import javax.annotation.Resource;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class Test &#123; @Resource(name=&quot;orderService&quot;) private orderService se; @org.junit.Test public void test1()&#123; se.t(); &#125;&#125; 配置文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--=====扫描是为了扫描类上的注解 ============--&gt; &lt;!-- context:component-scan base-package=&quot;demo1,demo2&quot;&gt;&lt;/context:component-scan--&gt; &lt;context:annotation-config/&gt; &lt;!-- =======在没有扫描的情况下，使用注解 @Resource @value、@Autowired、@Qulifier --&gt; &lt;bean id=&quot;peopleImp&quot; class=&quot;Demo1.peopleImp&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;order&quot; class=&quot;Demo3.order&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;orderService&quot; class=&quot;Demo3.orderService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"框架学习","slug":"框架学习","permalink":"http://SlectRxz.github.io/tags/框架学习/"}]},{"title":"Servlet注解开发","slug":"java/Servlet注解","date":"2019-02-22T16:00:00.000Z","updated":"2019-02-23T07:56:01.625Z","comments":true,"path":"2019/02/23/java/Servlet注解/","link":"","permalink":"http://SlectRxz.github.io/2019/02/23/java/Servlet注解/","excerpt":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter","text":"Servlet 3.0支持注解开发，包括@WebServlet,@WebFilter 在Servlet3.0中新增注解的功能，降低了配置XML所花费的时间与精力。注意：Tmocat7.0以上支持 一、@WebServlet注解 作用：用来配置Servlet，其将会在服务器启动时被tomcat容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet，个人感觉就是替代了传统的在web.xml中的配置。 参数说明 属性名 类型 属性描述 name String 指定Servlet的name属性，相当于 value String[] 等价于urlPatterns,二者不能共存. urlpatterns String[] 指定一组servlet的url的匹配模式,等价于标签. loadOnStartup int 指定servlet的加载顺序,等价于标签. initParams WebInitParam[] 指定一组初始化参数,等价于标签. asyncSupported boolean 申明servlet是否支持异步操作模式,等价于标签. displayName String servlet的显示名,等价于标签. description String servlet的描述信息,等价于标签. 与传统Servlet相比注解实现 12345678910111213141516171819202122232425262728package annotate;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(name=&quot;test2&quot;, value=&quot;/test2&quot; )public class test2 extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;utf-8&quot;); request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(&quot;页面执行了。。。&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 传统的Servlet的配置需要在Web.xml中添加Servlet的映射 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;description&gt;This is the description of my J2EE component&lt;/description&gt; &lt;display-name&gt;This is the display name of my J2EE component&lt;/display-name&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;servlet-class&gt;annotate.test1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;test1&lt;/servlet-name&gt; &lt;url-pattern&gt;/test1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 二、@WebFilter 用来配置过滤器","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"注解开发","slug":"注解开发","permalink":"http://SlectRxz.github.io/tags/注解开发/"}]},{"title":"MVC+三层架构开发模式","slug":"java/MVC开发模式","date":"2019-01-16T16:00:00.000Z","updated":"2019-02-27T11:39:49.056Z","comments":true,"path":"2019/01/17/java/MVC开发模式/","link":"","permalink":"http://SlectRxz.github.io/2019/01/17/java/MVC开发模式/","excerpt":"Web开发模式","text":"Web开发模式 MVC Model:javabean:封装业务数据，模型 View：jsp：显示数据，视图 Controller:servlet:调度jsp和javabean资源，控制器 三层结构： dao层： 和数据访问相关的操作 service层： 和业务逻辑相关的操作 web层： 和用户直接交互相关的操作（传接参数，跳转页面） MVC+三层架构个人理解： service层(业务逻辑层)，比如说当我们添加用户时需要判断用户的id是否为空，此时service层负责判断后再调用dao层的方法，dao层只负责对数据的增删查改。 servlet负责调用业务逻辑（页面的调度），而不处理业务逻辑。真正处理业务逻辑的是service层。 从servlet-&gt;jsp (页面跳转过程) 123456789101112131415161718 //设置编码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;);request.setCharacterEncoding(&quot;utf-8&quot;);//拿到对象 ，通过调用dao中的方法Contact contact=new ContactPerson();List&lt;Person&gt; list = contact.search();////shift+alt+A 区块选择，按一次进入选择模式，再按一次回来/** * ctrl+F 正则替换 ^(.*)$ \\1&quot;; * ^一行表示 * $结束表示 * \\1匹配里面的一行内容 替换为这个&quot;; *///将对象保存在域中request.setAttribute(&quot;contacts&quot;,list);//跳转到显示页面request.getRequestDispatcher(&quot;/listContact.jsp&quot;).forward(request, response); 从jsp-&gt;servlet一般我们用${pageContext.request.contextPath }来获取当前路径/QueryContactServlet?id=${con.id}是页面跳转的同时将id作为参数传递过去 123456789101112131415&lt;!-- 直接用EL表达式从域对象中获取数据--&gt;&lt;c:forEach items=&quot;$&#123;contacts&#125;&quot; var=&quot;con&quot; varStatus=&quot;varsta&quot;&gt; &lt;tr&gt; &lt;th&gt;$&#123;varsta.count&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.name&#125;&lt;/th&gt; &lt;th&gt;$&#123;con.gender&#125; &lt;/th&gt; &lt;th&gt;$&#123;con.email &#125;&lt;/th&gt; &lt;th&gt;$&#123;con.qq&#125;&lt;/th&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/QueryContactServlet?id=$&#123;con.id&#125;&quot;&gt;修改&lt;/a&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/DeleteContactServlet?id=$&#123;con.id&#125;&quot;&gt;删除&lt;/a&gt; //说明，此处的pageContext.request相当于pageContext.getRequest()方法，其在于先得到request对象，再调用request的方法。 &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; 注意：此处设计到EL表达式 语法：${表达式或变量}表达式/变量是从域对象中得到的，也就是说，我们必须先往域对象中存储输出对象的某个成员：${student.name},其中student的对象必须有方法getName() form表单形式：1&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/AddContactServlet&quot; method=&quot;post&quot;&gt; 项目结构：注意：不管是获取数据还是发送数据，都是以对象为基本单位，即JavaBean。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java反射","slug":"java/反射","date":"2019-01-06T16:00:00.000Z","updated":"2019-01-07T07:37:34.823Z","comments":true,"path":"2019/01/07/java/反射/","link":"","permalink":"http://SlectRxz.github.io/2019/01/07/java/反射/","excerpt":"Java反射机制","text":"Java反射机制 Java反射机制一、什么是反射机制 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 “程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。Java不是动态语言。但是Java有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的class。 二、理解Java反射要想理解反，必须得从“正”开始理解，一般而言，先有类再去实例化对象。1234567891011package com.wz.reflectdemo;import java.util.Date;//先有类public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date();//再产对象 System.out.println(date); &#125;&#125; 而“反”就是通过对象找到类。在Object类中提供一个方法得到class对象。1public final Class &lt;?&gt;getClass() 注：反射之中的所有泛型都定义为？，返回值为Object 三、Class类对象的实例化java.lang.Class是一个类，它与一般类一样继承Object。这个类是反射操作的源头，即所有的反射都从此类开始进行，下面介绍获取的三种方式。 方式一：调用Object的getClass()方法12345678910package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; Date date = new Date(); Class&lt;?&gt; cls = date.getClass(); System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：这种方式相当于通过实例对象反向得到Class对象。 方式二、使用“类.class”获得123456789101112package com.wz.reflectdemo;import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) &#123; //Date date = new Date(); Class&lt;?&gt; cls = Date.class; System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 说明：方法一中取得Class对象之前需要实例化，但是直接通过类名.Class没有实例化。 方法三、forName(String className) 注意：注意此字符串必须是真实路径，就是带包名的类路径，包名.类名1public static Class&lt;?&gt;forName(String className) throws ClassNotFoundException 代码如下：1234567891011package com.wz.reflectdemo;//import java.util.Date;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;java.util.Date&quot;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名 System.out.println(cls); &#125;&#125; 运行结果：1class java.until.Date 注意：三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。 四、反射实例化对象通过前面的步骤得到了Class对象，接下来利用反射实例化得到对象，得到方法和属性。 1、获取实例对象1public T newInstance() throws InstantiationException,IllegalAccessException eg:123456789101112131415161718192021222324252627package com.wz.reflectdemo;class Book&#123; public Book()&#123; System.out.println(&quot;Book类的无参构造方法&quot;); &#125; @Override public String toString() &#123; return &quot;This a book !&quot;; &#125;&#125;public class TestDemo &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book); &#125;&#125; 运行结果：12Book类的无参构造方法This a book ! 注意：newInstance()只能调用默认无参构造方法。当我们所实例化的类中没有提供无参的构造方法时，会报错。此时我们需要获取有参的构造方法。 在Class类中，提供了方法来获取构造函数：（1）获取所有的构造函数：1public Constructor&lt;?&gt;[] getConstructors() throws SecurityException （2）获取指定参数顺序的构造函数：1public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityExceptio 说明：以上两个类都返回“java.lang.reflect.Constructor”类的对象。该类中提供明确传递有参构造的方法：12public T newInstance(Object... initargs) throws InstantiationException, IllegalAccessException,IllegalArgumentException, InvocationTargetException 实例：1234567891011121314151617181920package com.wz.reflectdemo;import java.lang.reflect.Constructor;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); /*Object obj = cls.newInstance();//相当于使用new调用无参构造实例化对象 Book book = (Book)obj; System.out.println(book);*/ Constructor&lt;?&gt; con = cls.getConstructor(String.class,double.class); Object obj = con.newInstance(&quot;Java开发&quot;,79.8);//实例化对象 System.out.println(obj); &#125;&#125; 执行结果：1图书名称：Java开发 ,价格：79.8 2、调用方法和属性在Class类中获取方法有以下方式： （1）取得一个类中的全部方法1public Method[] getMethods() throws SecurityException （2）得到指定方法12public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throwsNoSuchMethodException, SecurityException 以上方法返回都是“java.lang.reflect.Method”对象，在这个类中有一个调用方法：12public Object invoke(Object obj, Object... args) throws IllegalAccessException,IllegalArgumentException, InvocationTargetException eg:12345678910111213141516171819package com.wz.reflectdemo;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; cls = Class.forName(&quot;com.wz.reflectdemo.Book&quot;); Object obj = cls.newInstance(); Method setMet = cls.getMethod(&quot;setTitle&quot;, String.class); setMet.invoke(obj, &quot;Java开发&quot;);//等价于Book类的setTitle(&quot;Java开发&quot;) Method getMet = cls.getMethod(&quot;getTitle&quot;); System.out.println(getMet.invoke(obj));//等价于Book类的getTitle() &#125;&#125; 输出结果：1java 开发","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Java注解","slug":"java/注解","date":"2019-01-04T16:00:00.000Z","updated":"2019-01-05T12:37:55.948Z","comments":true,"path":"2019/01/05/java/注解/","link":"","permalink":"http://SlectRxz.github.io/2019/01/05/java/注解/","excerpt":"有关java注解","text":"有关java注解 Java注解 出处：https://blog.csdn.net/briblue/article/details/73824058 注解的定义： 官方定义：Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java 注解是从 Java5 开始添加到 Java 的 （看不懂） 容易理解的：注解就是一个标签，标签上有着各种各样的含义，不同的标签可以贴在不同的代码上 自定义注解格式： 注解通过 @interface 关键字进行定义。 12345Public @interface TestAnnotation&#123;&#125;@TestAnnotationPublic void Test()&#123;&#125; 创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。你可以简单理解为将 TestAnnotation 这张标签贴到 Test 这个类上面。不过，要想注解能够正常工作，还需要介绍一下一个新的概念那就是元注解。 元注解元注解是可以注解到注解上的注解，它的目的是给普通的注解进行说明的，说明某一注解的存活期、范围等等。元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable @RetentionRetention的英文为保留期的意思，当其应用到某一个注解上时，表达了这个注解的存活时间它的取值如下： RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 可以理解为当使用@Retention解释标签时，指定了该标签的生命周期。123@Retention(Retention.RUNTIME)public @interface TestAnnotation&#123;&#125; 上面的代码指定了标签TestAnotation可在程序运行的时候获取到。 @Documented作用：将注解的元素包含到JavaDoc当中。 @Target作用：指定了注解运用在何处。可以理解为当被@Target注解，就被限定了应用场景。类比标签，原本标签可以贴到任何地方，当我限制后，只能贴到指定的地方。@Target有下面的取值： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举 @InheritedInherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。说的比较抽象。代码来解释。12345678@Inherited@Retention(RetentionPolicy.RUNTIME)@interface Test &#123;&#125;@Testpublic class A &#123;&#125;public class B extends A &#123;&#125; 注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。这样引用网上的例子理解： 老子非常有钱，所以人们给他贴了一张标签叫做富豪。老子的儿子长大后，只要没有和老子断绝父子关系，虽然别人没有给他贴标签，但是他自然也是富豪。老子的孙子长大了，自然也是富豪。这就是人们口中戏称的富一代，富二代，富三代。虽然叫法不同，好像好多个标签，但其实事情的本质也就是他们有一张共同的标签，也就是老子身上的那张富豪的标签。 @RepeatableRepeatable 自然是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。什么样的注解会多次应用呢？通常是注解的值可以同时取多个。举个例子，一个人他既是程序员又是产品经理(注：好的产品经理一般都是懂技术的，更容易沟通)。123456789101112@interface Persons&#123; Person[] value();&#125;@Repeatable(Persons.class)@interface Person&#123; String role default &quot;&quot;;&#125;@Person(role=&quot;coder&quot;)@person(role=&quot;PM&quot;)public class CM&#123;&#125; 注意上面的代码，Repeatable注解了Person，而@Repeatable后面括号里的类相当于一个容器注解 容器注解就是用来存放其他注解的地方，本身也是一个注解123@interface Persons&#123; Person[] value();&#125; 按照规定，它里面必须要有一个 value 的属性，属性类型是一个被 @Repeatable 注解过的注解数组，注意它是数组。如果不好理解的话，可以这样理解。Persons 是一张总的标签，上面贴满了 Person 这种同类型但内容不一样的标签。把 Persons 给一个 CM 贴上，相当于同时给他贴了程序员、产品经理的标签。我们可能对于 @Person(role=”PM”) 括号里面的内容感兴趣，它其实就是给 Person 这个注解的 role 属性赋值为 PM ，大家不明白正常，马上就讲到注解的属性这一块。","categories":[{"name":"Java","slug":"Java","permalink":"http://SlectRxz.github.io/categories/Java/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"JSP基础语法","slug":"java/JSP基础(一)","date":"2018-11-12T02:01:44.000Z","updated":"2018-12-03T08:37:26.813Z","comments":true,"path":"2018/11/12/java/JSP基础(一)/","link":"","permalink":"http://SlectRxz.github.io/2018/11/12/java/JSP基础(一)/","excerpt":"JSP基础语法","text":"JSP基础语法 ##Jsp基础## 4.1 Jsp引入 Servlet的作用： 用java语言开发动态资源的技术！！！Jsp的作用：用java语言（+html语言）开发动态资源的技术！！！ Jsp就是servlet！！！ 4.2 Jsp的特点 1）jsp的运行必须交给tomcat服务器！！！！ tomcat的work目录： tomcat服务器存放jsp运行时的临时文件 2）jsp页面既可以写html代码，也可以写java代码。 （html页面不能写java代码 。而jsp页面可以写java代码） 4.3 体验jsp页面作用 需求：显示当前时间到浏览器上 可以把jsp页面当做html页面在tomcat中访问！！！ 4.4 Jsp的执行过程 问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 1）访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把jsp文件翻译成java源文件 (01.hello.jsp-&gt; _01_hello_jsp.java) （翻译） 2）tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） 3）tomcat服务器构造_01_hello_jsp类对象 4）tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 1.第一次访问jsp：2.走（1）（2）（3）（4）3.第n次访问jsp：4.走（4）注意： 1）jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译（2）的过程 4.5 疑问 问题： 为什么Jsp就是servlet！！！ jsp翻译的java文件： public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent { HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage { 结论： Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 1）构造方法（第1次访问） 2）init方法（第1次访问） 3）service方法 4）destroy方法 Jsp的生命周期 1）翻译： jsp-&gt;java文件 2）编译： java文件-&gt;class文件（servlet程序） 3）构造方法（第1次访问） 4）init方法（第1次访问）：_jspInit() 5）service方法：_jspService() 6）destroy方法：_jspDestroy() ##Jsp语法## 5.1 Jsp模板 jsp页面中的html代码就是jsp的模板 5.2 Jsp表达式 语法：&lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式计算的结果 注意： 1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容 2）表达式后面不需要带分号结束。 5.3 Jsp的脚本 语法：&lt;%java代码 %&gt; 作用： 执行java代码 注意： 原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 就是在service方法中执行了一段java代码 5.4 Jsp的声明 语法：&lt;%! 变量或方法 %&gt; 作用： 声明jsp的变量或方法 注意: 1）变量翻译成成员变量，方法翻译成成员方法。 5.5 Jsp的注释 语法： &lt;%– jsp注释 –%&gt; 注意; 1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 ##Jsp的三大指令## 6.1 include指令 作用： 在当前页面用于包含其他页面 语法： &lt;%@include file=”common/header.jsp”%&gt; 注意： 1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面(index.jsp)中,合并成翻译成一 个java源文件，再编译运行！！，这种包含叫静态包含（源码包含） 2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！（如html、head、 body） 6.2 page指令 作用： 告诉tomcat服务器如何翻译jsp文件 &lt;%@ page language=”java” –告诉服务器使用什么动态语言来翻译jsp文件 import=”java.util.*” –告诉服务器java文件使用什么包 导入包，多个包之间用逗号分割 pageEncoding=”utf-8” –告诉服务器使用什么编码翻译jsp文件（成java文件） contentType=”text/html; charset=utf-8” 服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage=”error.jsp” isErrorPage=”false” buffer=”8kb” session=”true” isELIgnored=”false” %&gt; 6.3 taglib指令 总结： 1）编码实战： 1.1 servlet应用 1.2 初步了解软件开发流程 2）Jsp基础 2.1 Jsp的执行原理（翻译-》编译-》servlet的生命周期） 2.2 语法（jsp表达式，jsp脚本） 2.3 指令 include指令 page指令","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://SlectRxz.github.io/categories/JavaWeb/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"背景音乐添加步骤","slug":"addmusic","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-12T03:15:28.400Z","comments":true,"path":"2018/11/04/addmusic/","link":"","permalink":"http://SlectRxz.github.io/2018/11/04/addmusic/","excerpt":"关于博客如何添加背景音乐","text":"关于博客如何添加背景音乐 1、打开网易云音乐首页，然后搜索你要添加的背景音乐 2、搜索到歌曲点击生成外链播放器，进去下一个界面3、打开主题下的_partial文件夹下的left-col.ejs文件，选择iframe插件，赋值HTML代码到&lt;div&gt;&lt;/div&gt;中 注意：因为我想把这个播放器放在博客页面的左侧栏里，所以就把以上代码复制到主题文件夹下实现左侧栏的那个模板文件里，也就是left-col.ejs文件，（需要值得注意的是，因为所使用的主题不同，可能文件也就不一样，但是大致原理就如刚才我所提到的：想放在哪个区域，就把代码复制到实现那块区域的模板文件里）。 我的主题目录是YourBlogName\\themes\\smackdown\\layout\\_partial\\left-col.ejs。123&lt;div style=&quot;position:absolute;bottom:100px;left:15px;width:60%&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=250 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=543681750&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/div&gt; 注意： width与height调节播放页的大小","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://SlectRxz.github.io/categories/环境搭建/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"算法","slug":"first","date":"2018-10-14T13:58:57.005Z","updated":"2018-10-16T12:22:42.879Z","comments":true,"path":"2018/10/14/first/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/first/","excerpt":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。","text":"算法- 0-1背包问题问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 问题描述： 有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 这个问题的特点是：每种物品只有一件，可以选择放或者不放。（放是1，不放是0） D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);D[i][j]表示第前i件物品，j是其背包的容量，其价值用二维词典D[ ][ ]记录其值储存不同的j（背包容量）能装的最大价值 Code block123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#define MAX 20#define max(a,b) a&gt;b?a:busing namespace std;int D[MAX][MAX];int fill(int n,int v[],int b[],int c)&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=c;j++) &#123; If( j&lt;v[ I ] ) D[i][j]=D[i-1][j]; else D[i][j]=max(D[i-1][j],D[i-1][j-v[i]]+b[i]);//解释：当背包的容量慢慢增加，此时大于这个物品v[i]，那么，我们需要判断//放物品 与 不放物品的价值哪个高。。。。。 &#125; return 1;&#125;int main()&#123; int n,v[MAX],b[MAX],c; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i]; cin&gt;&gt;c; fill(n,v,b,c); cout&lt;&lt;D[n][c];&#125;","categories":[{"name":"0-1背包问题","slug":"0-1背包问题","permalink":"http://SlectRxz.github.io/categories/0-1背包问题/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://SlectRxz.github.io/tags/算法/"}]},{"title":"My first blog","slug":"hello-world","date":"2018-10-14T07:40:00.425Z","updated":"2018-11-08T09:07:05.337Z","comments":true,"path":"2018/10/14/hello-world/","link":"","permalink":"http://SlectRxz.github.io/2018/10/14/hello-world/","excerpt":"博客搭建记录","text":"博客搭建记录 找了很多教程，也看了一些视频，最后终于将其搭建好了，第一次写，有误请指正。 ####搭建环境准备： 安装Git：Git下载包64位. 下载node.js node.js下载地址 安装Hexo 利用npm命令即可安装。单击鼠标i右键，选着Git Bash","categories":[{"name":"搭建说明","slug":"搭建说明","permalink":"http://SlectRxz.github.io/categories/搭建说明/"}],"tags":[{"name":"blog记录","slug":"blog记录","permalink":"http://SlectRxz.github.io/tags/blog记录/"}]},{"title":"Linux基础（四）","slug":"Linux基础（四）","date":"2017-05-12T02:01:44.000Z","updated":"2018-10-16T11:40:21.032Z","comments":true,"path":"2017/05/12/Linux基础（四）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/12/Linux基础（四）/","excerpt":"Linux网络配置与使用","text":"Linux网络配置与使用 4、虚拟机linux上网问题4.1、VMware中虚拟机网络的三种设置第一种：桥接（bridged）第二种：NAT第三种：Host only 。该模式下仅主机可以上网，虚拟机不能上网。 4.2、虚拟机上网方式1：NAT方式设置步骤：第一步：在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择NAT模式第二步： vi /etc/network/interfaces，打开该文件，将内容编辑成为： auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 第三步：执行/etc/init.d/networking restart重启网卡 4.3、虚拟机上网方式2：桥接方式第一步：桥接。在菜单栏 虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 网络适配器，右侧选择桥接模式。第二步：桥接到可以上网的网卡。在菜单栏 编辑 -&gt; 虚拟网络编辑器，选择桥接到自己Windows中可以上网的网卡上（一般就是Wifi网络或者有线网络）第三步：设置dhcp并重启网卡。 vi /etc/network/interfaces，打开该文件，将内容编辑成为：auto loiface lo inet loopback auto eth0iface eth0 inet dhcpaddress 192.168.1.141netmask 255.255.255.0gateway 192.168.1.1 保存退出。然后命令行执行/etc/init.d/networking restart重启网卡 4.4、总结第一，NAT方式设置上网比较简单，但是不能用在嵌入式开发中。第二，桥接方式设置上网较繁琐，但是在嵌入式开发中比较有用。 使用技巧：1、使用shell的Tab键自动补全Tab在linux命令行输入中可以自动完成。在linux 命令行中使用Tab键会极大提高输入效率2、使用shell的历史记录shell会记录用户执行命令的历史记录，而我们一般使用命令都会在短时间内集中反复使用因此当你需要使用一条刚才还使用过的命令时，不需再次花时间输入，只要按下键盘上下箭头按键，就可实现上下翻页，翻出刚才用过的命令，直接回车执行。就好像电话机的通话记录和快速回拨一样。3、linux命令行中一些符号的含义： . 代表当前目录 .. 代表上一层目录，当前目录的父目录 - 代表前一个目录，我刚才从哪个目录cd过来 ~ 代表当前用户的宿主目录 / 代表根目录 $ 普通用户的命令行提示符 # root用户的命令行提示符 * 万能匹配符 宿主目录：所谓宿主目录，就是操作系统为当前用户所设计的用来存放文件、工作的默认目录。如Windows中的“我的文档”目录，就是Windows为我们设计的宿主目录。Linux中每个用户都有自己的宿主目录，这个目录对于普通用户来说，在/home/username/，而对于root用户来说，在/root。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（三）","slug":"Linux基础（三）","date":"2017-05-11T02:01:44.000Z","updated":"2018-10-16T11:40:22.000Z","comments":true,"path":"2017/05/11/Linux基础（三）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/11/Linux基础（三）/","excerpt":"vi编辑器的使用","text":"vi编辑器的使用 3、编辑器vi的使用（vi和vim的联系）什么是编辑器？编辑器就是一款软件，它的主要作用就是用来编辑。譬如编写文件，编写代码。Windows中的常用编辑器，如自带的notepad。比较好用的notepad++，UltraEditor，SlickEditorLinux中常用编辑器，自带的最古老的vi。比较好用的vim，gedit。注：vi和vim的关系：vim是vi的升级版，推荐使用vim。我们在后面提到vi时，其实都是指vim。 3.1、vi基础使用使用vi来打开/创建一个文件，vi pathname vi的两种模式：命令模式：当vi打开时默认为命令模式，要转入输入模式，需要按a或者i键。在命令模式下，此时键盘上输入的所有东西都被vi当作命令来对待。在命令模式下，最好不要乱输入。此时应该输入相应的命令，来让vi做相应的事。输入模式：输入模式用来向文件输入内容。可以从命令模式中按a或者i进入输入模式。进入输入模式后，就可以随意按键盘进行输入了。输入完成后如果要保存，要先退回到命令模式（因为保存也是一种命令）。在输入模式下按ESC键退回到命令模式。注：注意看屏幕左下角，当命令模式时无提示信息或者提示文件名等信息，等处于输入模式时，提示 – INSERT –在命令模式下如何保存：:wq 保存并且退出:w 只保存不推出:q 不保存退出 进来看了一下没改退出:q! 不保存强制退出:wq! 保存并强制退出 3.2、vi的高级使用 查找在命令模式下，输入/xxx，就可以查找到xxx 快速切换行在命令模式下，输入:num，就可以快速切换到num行 设置显示行号在命令模式下，输入:set nu，就可以显示行号 注：设置不显示行号，命令模式输入:set nonu设置永久显示行号，需要修改vi的配置文件。打开vi的配置文件~/.vimrc，在其中输入set nu即可。 行删除命令模式下，先将光标移动到要删除的行，然后输入dd如果要删除连续多行，譬如要删除连续的3行，使用3dd 行复制粘贴复制：命令模式下，nyy粘贴：命令模式下，p细节，复制时要把光标放在多行的第一行，粘贴时实际粘贴到当前光标所在行的下一行。 3.3、linux中权限表示&amp;管理3.3.1、普通用户与特权用户 su命令切换用户Windows中有普通用户和特权用户，特权用户是Administrator，普通用户可以有很多个。特权用户是系统的管理员，对系统内所有文件具有操作权限。每个普通用户只能处理自己的文件，不能访问其他用户的文件，更不能随意处理操作系统的文件。Linux中也有普通用户和特权用户的区别。特权用户就是root用户。普通用户权限受到限制，譬如说普通用户不能cd /root，普通用户不能使用apt-get install 来装软件。 可以使用su 用户名来在不同用户间切换。譬如要从普通用户切换到root，可以su root，然后输入root的密码即可转入root用户。从root要切换到普通用户gec，则su gec即可。 3.3.2、rwx与权限表示ls -l显示详细信息drwxr-xr-x 10个字符，第一个表示文件类型。剩下的9个分成3组，表示文件权限。前三个表示此文件的属主对文件的权限中间三个表示此文件属主所在的组对文件的权限最后三个表示其他用户对文件的权限rwx怎么解析：r代表可读，w代表可写，x代表可执行rwx：可读，可写，可执行r-x: 可读，不可写，可执行r–: 可读，不可写，不可执行 3.3.3、使用sudo暂时获取root权限这是ubuntu的一个特点，在ubuntu中可以使用sudo命令让普通用户暂时获取root用户的权限，而不必进行用户切换。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（二）","slug":"Linux基础（二）","date":"2017-05-08T02:01:44.000Z","updated":"2018-10-16T11:40:15.881Z","comments":true,"path":"2017/05/08/Linux基础（二）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/08/Linux基础（二）/","excerpt":"关于Linux的基本介绍以及简单命令的概述","text":"关于Linux的基本介绍以及简单命令的概述 2、linux基础知识与技能2.1、linux内核、发行版linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。ubuntu、redhat就是linux的不同的发行版。 2.2、GUI（图形用户界面）和cmdline（命令行）GUI：grahics user interface，图形用户界面。cmdline：command line，命令行。人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。但是，在linux中我们常用命令行，在Windows中常用GUI 2.3、linux常用命令：(1) ls（list，列表）作用：使用列表把当前文件夹下所有文件显示出来 ls -a 显示所有文件，包括隐藏文件 ls -l 以详细信息显示 ls -a -l ls -l -a ls -la ls -al 四种方式都是可以的 ls -al ~ ：列出自己主文件夹下的所有隐藏文件与相关的文件属性 (2) cd（change directory，更改目录）作用：用来切换目录涉及到相对路径和绝对路径cd .. ..代表上一层目录 .代表当前目录 (3) pwd（print work directory，打印工作目录）作用：打印出当前的绝对路径 (4) mkdir（make directory，创建文件夹）作用：创建空文件夹 mkdir -p 级联创建文件夹(5) mv（move，移动）作用：在目录间移动文件，重命名文件 mv 源文件pathname 目的文件pathname (6) touch作用：创建空文件 touch pathname (7) cp（copy，复制）作用：复制文件或文件夹 cp 源文件pathname 目标文件pathname cp -r 用来复制文件夹 cp -f 强制复制实际操作时，一般都是cp -f复制文件，cp -rf复制文件夹 (8) rm（remove，去除，删除）作用：用来删除文件，文件夹 rm 文件pathname rm -r 文件夹pathname (9) cat作用：直接在命令行下显示文件内容 也可以用来向文件输入，暂时不管 (10)rmdir（remove directory，删除文件夹）作用：删除空文件夹rmdir和rm -r的区别：rmdir只能删除空文件夹，而rm -r可以删除空文件夹和非空文件夹 (11) ln（link，连接文件）基础：windows中快捷方式，实际上快捷方式和它指向的文件是独立的两个文件，两个都占硬盘空间，只不过用户访问快捷方式时，其效果等同于访问指向的文件。 linux中有两种连接文件：一种叫软连接（符号连接），等同于windows中快捷方式一种叫硬连接创建软连接文件： ln -s 源文件名 符号连接文件名举例：ln -s src.c，linker.c， linker.c就是src.c的一个符号连接文件 硬连接：ln 源文件名 连接文件名硬连接实际上和源文件在硬盘中是同一个东西，效果类似于硬盘上的一个文件，在文件系统上，在我们看来有好多个文件一样。每次删除一个文件时，只要他还有其他的硬连接存在，这个文件就不会被真正删除。只有等所有的连接文件都删除掉了，这个文件才会被真正从硬盘上删除。 基础知识：1、ls -l显示的详细信息中：-rw-r–r–drwxr-xr-x一共10个字符，第一个字符表示文件类型，后面9个字符表示文件权限。文件类型： 表示普通文件。普通文件指文本文件和二进制 文件，如a.c 1.txt a.out都是普通文件d 表示文件夹，d是directory的缩写l 表示符号连接文件，后面会用-&gt;打印出它指向的文件s 表示socket文件p 表示管道文件 pipe","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]},{"title":"Linux基础（一）","slug":"Linux基础（一）","date":"2017-05-05T02:01:44.000Z","updated":"2018-10-16T11:40:10.897Z","comments":true,"path":"2017/05/05/Linux基础（一）/","link":"","permalink":"http://SlectRxz.github.io/2017/05/05/Linux基础（一）/","excerpt":"操作系统、相对路径与绝对路径的简介","text":"操作系统、相对路径与绝对路径的简介 1、操作系统基础概念1.1、Windows与linux的关系当前主流的操作系统：windows、、android、iOS、symbian、linux/unix Windows：傻瓜式、好学习、工资低Linux：linux认为每一个用户都是专业人士，操作麻烦，学习比较难，免费的、开源的，linux性能好，可移植性好，好的设计理念Android：移动操作系统，android基于linuxiOS：很优秀，创造性，走钢丝 嵌入式操作系统：linux + WinCE当前：消费电子Android，工业linux 1.2、多机开发：双系统与虚拟机开发嵌入式程序，需要linux环境。但是因为：windows中有许多很好用的软件，如notepad++、SourceInsight，所以也需要windows。 第一种：双系统 不方便第二种：虚拟机 方便，损失性能，与 真机微小差异第三种：两台电脑：不方便 现实中：个人开发者：虚拟机大公司：服务器+客户端 1.3、搭建开发环境涉及到两个东西：虚拟机软件+linux系统虚拟机软件：就是一个单纯的在windows中运行的软件，跟word、360没有本质区别。现在主流的虚拟机软件有VMWare和VirtualBox虚拟机软件在windows系统中运行，运行后它会模拟出来一个电脑，所以叫虚拟机。然后我们可以在该虚拟机中安装别的操作系统。当前，可以先使用事先安装好的aston_ubuntu，密码是root。自己上网搜索安装教程。 1.4、隐藏文件与非隐藏文件Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件和文件夹。Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls） 1.5、相对路径与绝对路径什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。举例：D:\\winshare\\enum.c全路径pathnameD:\\winshare路径 path`enum.c文件名 name 绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\\），linux中从根目录/开始相对路径：指明路径的时候，是从当前所在的位置开始的。 举例：D:\\我的文档\\123\\123.txtD:\\我的文档\\abc\\abc.txt当前在123.txt，但是要去abc.txt方式1：采用绝对路径。D:\\我的文档\\abc\\abc.txt方式2：采用相对路径。../abc/abc.txt从当前路径开始，往上走一层，再往下走一层（abc）就到了 测试：/abc/123/def.txt 是linux绝对路径abc/123/def.txt 不是linux绝对路径F:\\abc\\123\\def.txt 是windows绝对路径abc\\123\\def.txt 不是windows绝对路径","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://SlectRxz.github.io/categories/Linux基础/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://SlectRxz.github.io/tags/学习/"}]}]}